<!DOCTYPE html>
<!-- saved from url=(0117)http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_5_3_index_lifecycle_management -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.8">
<title>Lab Guide: Elasticsearch Engineer II</title>
<style>
.header {
  font-size: 36px;
  line-height: 49px;
  font-family: "Open Sans","arial, helvetica, sans-serif";
  display: block;
  -webkit-font-smoothing: antialiased;
  font-weight: 300;
}

.logo {
  vertical-align: top;
  border: 0;
}

html {
  background-color: #e6e9e9;
  background-image: -webkit-linear-gradient(270deg,rgb(230,233,233) 0%,rgb(216,221,221) 100%);
  background-image: linear-gradient(270deg,rgb(230,233,233) 0%,rgb(216,221,221) 100%);
  -webkit-font-smoothing: antialiased;
}

.lab1_toggle {
  font-family: Helvetica, Arial, sans-serif;
  font-size: 2.0em;
  line-height: 1.8em;
  font-weight: bold;
  text-align: center;
}

.virtual_div {
  text-align: center;
  background-color: beige;
  border-color: black;
  border-width: thin;
  border-style: solid;
  padding: 1em 1em 1em;
}

.left {
  text-align: left;
}

body {
  margin: 0 auto;
  padding: 2em 2em 4em;
  max-width: 80%;
  font-family: Helvetica, Arial, sans-serif;
  font-size: 1.2em;
  line-height: 1.5em;
  color: #545454;
  background-color: #ffffff;
  box-shadow: 0 0 2px rgba(0, 0, 0, 0.06);
}

h1, h2, h3, h4, h5, h6 {
  color: white;
  font-weight: 400;
  line-height: 1.5em;
  background-color: rgb(7,165,222);
  font: Arial;
  padding-left: 15px;
  box-shadow: 10px 10px 5px rgb(144, 144, 145);
}
h2, h3 {
  background: #3399cc; /* Old browsers */
  background: -moz-linear-gradient(top,  #3399cc 0%, #003366 0%, #3399cc 100%); /* FF3.6-15 */
  background: -webkit-linear-gradient(top,  #3399cc 0%,#003366 0%,#3399cc 100%); /* Chrome10-25,Safari5.1-6 */
  background: linear-gradient(to bottom,  #3399cc 0%,#003366 0%,#3399cc 100%); /* W3C, IE10+, FF16+, Chrome26+, Opera12+, Safari7+ */
  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#3399cc', endColorstr='#3399cc',GradientType=0 ); /* IE6-9 */
}

h1 {
  background: #3399cc;
  background: -moz-linear-gradient(top,  #3399cc 0%, #207cca 0%, #009999 100%); /* FF3.6-15 */
  background: -webkit-linear-gradient(top,  #3399cc 0%,#207cca 0%,#009999 100%); /* Chrome10-25,Safari5.1-6 */
  background: linear-gradient(to bottom,  #3399cc 0%,#207cca 0%,#009999 100%); /* W3C, IE10+, FF16+, Chrome26+, Opera12+, Safari7+ */
  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#3399cc', endColorstr='#009999',GradientType=0 ); /* IE6-9 */
}

h3 {
  font-weight: bold;
}

p.summary {
  margin-top: 3em;
  margin-bottom: 3em;
}

a {
  color: #0083e8;
}

b, strong {
  font-weight: 600;
}

samp {
  display: none;
}

img {
  -webkit-animation: colorize 2s cubic-bezier(0, 0, .78, .36) 1;
  animation: colorize 2s cubic-bezier(0, 0, .78, .36) 1;
  background: transparent;
  border: 10px solid rgba(0, 0, 0, 0.12);
  border-radius: 4px;
  display: block;
  margin: 1.3em auto;
  max-width: 95%;
}

video {
  border: 10px solid rgba(0, 0, 0, 0.12);
  border-radius: 4px;
  display: block;
  margin: 1.3em auto;
  max-width: 95%;
}

@-webkit-keyframes colorize {
  0% {
      -webkit-filter: grayscale(100%);
  }
  100% {
      -webkit-filter: grayscale(0%);
  }
}

@keyframes colorize {
  0% {
      filter: grayscale(100%);
  }
  100% {
      filter: grayscale(0%);
  }
}

pre code {
  padding: 0;
  color: #3f3b36;
  background-color: transparent;
  font-size: 1.0rem;
  line-height: 2rem;
  text-shadow: none;
}

code {
  background-color: rgba(27,31,35,.05);
  border-radius: 3px;
  font-size: 85%;
  padding: .2em .4em;
  font-weight: lighter;
  font-family: Monaco,'MonacoRegular',monospace;
}

.answerInput {
  padding-right: 0.5rem;
  padding-left: 0.5rem;
  color: #3f3b36;
  border: 1px solid #39bdb1;
  border-radius: 5rem;
  font-weight: lighter;
  font-family: Monaco,'MonacoRegular',monospace;
  font-size: 0.8rem;
}

.answerInput:focus{
  outline: none;
}

pre {
  width: 92%;
  overflow: auto;
  margin: 1rem 0;
  margin-top: 1rem;
  margin-right: 0px;
  margin-bottom: 1rem;
  margin-left: 0px;
  padding: 1rem 0.8rem 1rem 1.2rem;
  padding-top: 1rem;
  padding-right: 0.8rem;
  padding-bottom: 1rem;
  padding-left: 1.2rem;
  color: #3f3b36;
  border: 1px solid #39bdb1;
  border-left: 1rem solid #39bdb1;
  font: lighter 1.0rem/2rem Monaco,'MonacoRegular',monospace;
  font-style: normal;
  font-variant-ligatures: normal;
  font-variant-caps: normal;
  font-variant-numeric: normal;
  font-weight: lighter;
  font-stretch: normal;
  font-size: 1.0rem;
  line-height: 1.4rem;
  font-family: Monaco, MonacoRegular, monospace;
  background: url(images/pre.png) repeat 0 -0.9rem;
  background-image: url(images/pre.png);
  background-position-x: 0px;
  background-position-y: -0.9rem;
  background-repeat-x: repeat;
  background-repeat-y: repeat;
  background-attachment: initial;
  background-origin: initial;
  background-clip: initial;
  background-color: initial;
  background-size: 1px 4rem;
  box-shadow: 10px 10px 5px rgb(144, 144, 145);
}

pre.bash {
  background-color: black;
  color: white;
  font-family: Monaco,MonacoRegular,monospace;
}

div[class="listingblock bash"] div[class="content"] pre {
  background-color: black;
}

div[class="listingblock bash"] div[class="content"] pre code {
  color: white;
  font-family: Monaco,MonacoRegular,monospace;
  line-height: 1.4rem;
}

hr {
  margin-bottom: 4em;
  margin-top: 4em;
  border : 0;
  height: 1px;
  background-image: linear-gradient(to right, #66ccff, #006699, #66ccff);
}

ol li {
  margin-top: 3rem;
}

ul li {
  margin-top: 0
}

kbd {
  font-family: Courier, Monaco,'MonacoRegular',monospace;
  font-weight: bold;
  font-size: 1.2rem;
  line-height: 1.5rem;
}

.kbd {
  font-family: Courier, Monaco,'MonacoRegular',monospace;
  font-weight: bold;
  font-size: 1.2rem;
  line-height: 1.5rem;
}

h2 {
  font-size: 2.5rem;
}

table.labTable {
  border: 1px solid #1C6EA4;
  /* background-color: #EEEEEE;*/
  width: 70%;
  text-align: left;
  border-collapse: collapse;
}

table.labTable td, table.labTable th {
  border: 3px solid #1C6EA4;
  padding: 3px 2px;
}

table.labTable tbody td {
  font-size: 16px;
}

table.labTable tr:nth-child(even) {
  background: #D0E4F5;
}

table.labTable thead {
  background: #1C6EA4;
  background: -moz-linear-gradient(top, #5592bb 0%, #327cad 66%, #1C6EA4 100%);
  background: -webkit-linear-gradient(top, #5592bb 0%, #327cad 66%, #1C6EA4 100%);
  background: linear-gradient(to bottom, #5592bb 0%, #327cad 66%, #1C6EA4 100%);
  border-bottom: 2px solid #444444;
}

table.labTable thead th {
  font-size: 15px;
  font-weight: bold;
  color: #FFFFFF;
  border-left: 2px solid #D0E4F5;
}

table.labTable thead th:first-child {
  border-left: none;
}

table.relevance {
    border: 1px solid black;
    font-size: 0.8em;
    border-collapse: collapse;
}
.relevance th {
    text-align: left;
    white-space: nowrap;
    border-top: 1px solid black;
}

.relevance tr {
    border-top: 1px solid #dddddd;
}

.relevance td, .relevance th {
  padding: 2px 5px;
  vertical-align: top;
  text-overflow: TODO;
}

</style>

<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<link rel="shortcut icon" href="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/images/favicon.ico" type="image/x-icon">
<script type="text/javascript" src="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/includes/elastic_training.js"></script>
</head><body class="article"><img class="logo" src="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/images/elastic-logo.svg" width="300">

<!-- Include an extra training.js to make development easier. -->
<script type="text/javascript" src="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/commons/instructions/includes/elastic_training.js"></script>


<div id="header">
<h1>Lab Guide: Elasticsearch Engineer II</h1>
<div id="toc" class="toc">
<div id="toctitle"></div>
<ul class="sectlevel1">
<li><a href="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_setup_welcome_to_engineer_ii">Lab Setup: Welcome to Engineer II</a></li>
<li><a href="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_1_1_denormalization">Lab 1.1: Denormalization</a></li>
<li><a href="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_1_2_nested_and_join_data_types">Lab 1.2: Nested and Join Data Types</a></li>
<li><a href="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_1_3_field_modeling_and_the_elastic_common_schema">Lab 1.3: Field Modeling and the Elastic Common Schema</a></li>
<li><a href="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_1_4_analyzers">Lab 1.4: Analyzers</a></li>
<li><a href="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_2_1_update_and_delete_by_query_and_reindex_apis">Lab 2.1: Update and Delete by Query and Reindex APIs</a></li>
<li><a href="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_2_2_ingest_nodes_and_pipelines">Lab 2.2: Ingest Nodes and Pipelines</a></li>
<li><a href="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_2_3_painless_scripting">Lab 2.3: Painless Scripting</a></li>
<li><a href="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_3_1_securing_elasticsearch">Lab 3.1: Securing Elasticsearch</a></li>
<li><a href="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_3_2_development_vs_production_mode">Lab 3.2: Development vs. Production Mode</a></li>
<li><a href="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_3_3_scaling_elasticsearch">Lab 3.3: Scaling Elasticsearch</a></li>
<li><a href="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_4_1_cluster_backup">Lab 4.1: Cluster Backup</a></li>
<li><a href="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_4_2_overview_of_upgrades_and_cluster_restart">Lab 4.2: Overview of Upgrades and Cluster Restart</a></li>
<li><a href="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_4_3_topology_awareness">Lab 4.3: Topology Awareness</a></li>
<li><a href="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_4_4_multi_cluster_setups">Lab 4.4: Multi Cluster Setups</a></li>
<li><a href="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_5_1_controlling_shard_allocation">Lab 5.1: Controlling Shard Allocation</a></li>
<li><a href="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_5_2_index_management">Lab 5.2: Index Management</a></li>
<li><a href="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_5_3_index_lifecycle_management">Lab 5.3: Index Lifecycle Management</a></li>
<li><a href="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_6_1_challenges_of_distributed_operations">Lab 6.1: Challenges of Distributed Operations</a></li>
<li><a href="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_6_2_aliases_and_templates">Lab 6.2: Aliases and Templates</a></li>
<li><a href="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_6_3_controlling_dynamic_behaviors">Lab 6.3: Controlling Dynamic Behaviors</a></li>
<li><a href="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_6_4_common_causes_of_poor_search_performance">Lab 6.4: Common Causes of Poor Search Performance</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<hr>
</div>
</div>
<div class="sect1">
<h2 id="_lab_setup_welcome_to_engineer_ii">Lab Setup: Welcome to Engineer II</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab, you will access your classroom lab instance
and startup a 3-node Elasticsearch cluster, along with a Kibana
instance.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>From within the Strigo UI, click on the <strong>"My Lab"</strong> icon in the left
toolbar (if you do not have access to the virtual environment, click
<a href="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/local_lab.html" target="_blank" rel="noopener">here</a> to see how to run the labs on your local
machine): <span class="image"><img src="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/images/lab00_strigo_lab_icon.png" alt="lab00 strigo lab icon"></span> A command prompt
will open, and you will be logged in to a Linux machine that is
configured to provide easy SSH access to three servers named <code>server1</code>,
<code>server2</code> and <code>server3</code> that have Elasticsearch downloaded and ready to be
executed.</p>
</li>
<li>
<p>SSH onto <code>server1</code>:</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>ssh server1</code></pre>
</div>
</div>
</li>
<li>
<p>View the contents of the <code>elastic</code> user home folder by entering <code>ls -l</code>.
You should see Elasticsearch and Kibana directories:</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>[elastic@server1 ~]$ ls -l
total 8
drwxr-xr-x  9 elastic elastic 4096 Nov 26 15:20 elasticsearch
drwxr-xr-x 11 elastic elastic 4096 Nov 16 02:41 kibana</code></pre>
</div>
</div>
</li>
<li>
<p>View the contents of <code>elasticsearch/config/elasticsearch.yml</code> file using
a text editor of your choice: nano, emacs, or vi. If you are not
familiar with command-line editors, we suggest you use nano (click
<a href="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/nano_tutorial.html" target="_blank" rel="noopener">here</a> for tips on using nano). This is not the
default config file, but one provided for this training. Notice the
<code>node.name</code> is set to an environment variable named <strong>NODENAME</strong>. (We added a
command into <code>/etc/profile</code> to dynamically define this variable.)</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>cluster.name: my_cluster
node.name: ${NODENAME}
network.host: _site_
discovery.seed_hosts: ["server1", "server2", "server3"]</code></pre>
</div>
</div>
</li>
<li>
<p>Start Elasticsearch using the following command:</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>./elasticsearch/bin/elasticsearch</code></pre>
</div>
</div>
</li>
<li>
<p>Within Strigo, open a new console by clicking the plus sign "<strong>+</strong>" next
to the tab of your current console, and you should see a command prompt:
<span class="image"><img src="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/images/lab01_06v.png" alt="image" width="50.0%" height="50.0%"></span></p>
</li>
<li>
<p>SSH onto <code>server2</code>:</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>ssh server2</code></pre>
</div>
</div>
</li>
<li>
<p>Once <code>node1</code> is started (you need to wait for <code>node1</code> to elect itself master), start Elasticsearch on <code>server2</code>, which will startup <code>node2</code>:</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>./elasticsearch/bin/elasticsearch</code></pre>
</div>
</div>
</li>
<li>
<p>Now, you will add one more node to your cluster. So, open a new
console tab and SSH onto <code>server3</code>:</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>ssh server3</code></pre>
</div>
</div>
</li>
<li>
<p>Once <code>node2</code> is started, start Elasticsearch on <code>server3</code>, which will startup <code>node3</code>:</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>./elasticsearch/bin/elasticsearch</code></pre>
</div>
</div>
</li>
<li>
<p>Finally, you will start Kibana on <code>server1</code>. So, open a new console tab
and SSH onto <code>server1</code>:</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>ssh server1</code></pre>
</div>
</div>
</li>
<li>
<p>Start Kibana on <code>server1</code> using the following command:</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>./kibana/bin/kibana</code></pre>
</div>
</div>
</li>
<li>
<p>Now that Kibana is running, click

  <script language="JavaScript">
      if (window.location.host) {
          document.write('<a target="_blank" href="/app/kibana#/dev_tools/console?_g=()" >here</a>' );
      } else {
          document.write('<a target="_blank" href="http://localhost:5601/app/kibana#/dev_tools/console?_g=()">here</a>')
      }
  </script><a target="_blank" href="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/app/kibana#/dev_tools/console?_g=()">here</a>

to connect.</p>
</li>
<li>
<p>Check if all nodes are running via the Kibana Dev Tools Console before going to the next step.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cat/nodes</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>172.18.0.2 30 72 10 0.46 0.41 0.18 dim * node1
172.18.0.3 37 72  9 0.46 0.41 0.18 dim - node2
172.18.0.4 32 72  4 0.46 0.41 0.18 dim - node3</code></pre>
</div>
</div>
</li>
<li>
<p>Now that you have your 3-node cluster up and running, you can access the

  <script language="JavaScript">
      if (window.location.host) {
          document.write('<a target="_blank" href="' + window.location.protocol + '//' + window.location.hostname + ':443' + '" >blogs search page</a> ' );
      } else {
          document.write('<a target="_blank" href="http://localhost:443">blogs search page</a>')
      }
  </script><a target="_blank" href="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com:443/">blogs search page</a> 

and play around with it.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary:</strong> In this lab, you accessed your classroom lab instance and
started up a 3-node Elasticsearch cluster, along with a Kibana instance.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_setup">End of Lab Setup</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_1_1_denormalization">Lab 1.1: Denormalization</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab, you will explore how to denormalize data and how
denormalized data relate to mappings.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Based on the following simplified Java classes, create a sample blog document
using the JSON syntax.
The blog document should be fully denormalized.
<em>(<strong>TIP:</strong> think about the output of a toString method in the <code>Blogs</code> class.)</em></p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>class Blog {
  String id;
  String title;
  String[] products;
  Author[] authors;

  /* list of methods */
  ...
}

class Author {
  String name;
  Company company;

  /* list of methods */
  ...
}

public class Company {
  String name;
  Country country;

  /* list of methods */
  ...
}

public class Country {
  String name;
  String code;

  /* list of methods */
  ...
}</code></pre>
</div>
</div>
<div class="openblock solution" id="solution0"><input id="question0" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer0" style="display: block;">
<div class="content">
<div class="paragraph">
<p>Usually, the best way to start creating a model it to write a sample document.
To get started, the sample document doesn’t need to be very complex.
It is ok to use simple values such as <code>someid</code> and <code>Author1</code>.
(It even helps you to focus on the model instead of on the data.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{
  "id": "someid",
  "title": "My Blog Title",
  "products": [ "logstash", "beats" ],
  "authors": [
    {
      "name": "Author1",
      "company": {
        "name": "Company1",
        "country": {
          "name": "Country1",
          "code": "C1"
        }
      }
    }
  ]
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Now that the document is defined, the next step is to define the mappings.
Create a new index named <code>denormalized_blogs</code> with a mapping that corresponds
to the denormalized document above.
<em>(<strong>TIP:</strong> you can either create the mappings manually, one field at a time, or
index the document into a temporary index, and then adjust the mappings.)</em></p>
<div class="openblock solution" id="solution1"><input id="question1" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer1" style="display: block;">
<div class="content">
<div class="paragraph">
<p>To define a good mapping, you need to think about the usage of each field:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>id</code> field will only be used for exact matches. So, one <code>keyword</code>
field is enough.</p>
</li>
<li>
<p>The <code>title</code> field will be used for full-text queries and sorting.
Therefore, you need to configure multi-field with both <code>text</code> and <code>keyword</code>.
As titles are in English, using the <code>english</code> analyzer might improve the
search experience.</p>
</li>
<li>
<p>Even though the <code>products</code> field can have an array of strings, there is no
dedicated array type in Elasticsearch.
Any field can contain zero or more values by default, so you only need to
define it as a string.
In this case, both <code>text</code> and <code>keyword</code> seem applicable.</p>
</li>
<li>
<p>The <code>authors</code> field is an <code>object</code> with two <code>properties</code>.</p>
</li>
<li>
<p>The <code>author.name</code> field will be used in full-text queries and aggs.</p>
</li>
<li>
<p>The <code>author.company</code> field is an object with two <code>properties</code>.</p>
</li>
<li>
<p>The <code>author.company.name</code> field will be used in full-text queries and aggs.</p>
</li>
<li>
<p>The <code>author.company.country</code> field is an object with two <code>properties</code>.</p>
</li>
<li>
<p>The <code>author.company.country.name</code> field will be used in full-text queries
and aggs.</p>
</li>
<li>
<p>The <code>author.company.country.code</code> field will be used in term queries and
aggs.
Therefore, one <code>keyword</code> field is enough.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT denormalized_blogs
{
  "mappings": {
    "properties": {
      "id": {
        "type": "keyword"
      },
      "title": {
        "type": "text",
        "analyzer": "english",
        "fields": {
          "keyword": {
            "type": "keyword"
          }
        }
      },
      "products": {
        "type": "text",
        "fields": {
          "keyword": {
            "type": "keyword"
          }
        }
      },
      "authors": {
        "type": "object",
        "properties": {
          "name": {
            "type": "text",
            "fields": {
              "keyword": {
                "type": "keyword"
              }
            }
          },
          "company": {
            "type": "object",
            "properties": {
              "name": {
                "type": "text",
                "fields": {
                  "keyword": {
                    "type": "keyword"
                  }
                }
              },
              "country": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "text",
                    "fields": {
                      "keyword": {
                        "type": "keyword"
                      }
                    }
                  },
                  "code": {
                    "type": "keyword"
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Now, execute the following command to index three different blogs.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST denormalized_blogs/_bulk
{"index":{"_id":1}}
{"id":"1","title":"Time Series with Kibana","authors":[{"name":"Alex Francoeur","company":{"country":{"code":"FR","name":"France"},"name":"ACME"}},{"name":"Chris Cowan","company":{"country":{"code":"NI","name":"Nigeria"},"name":"Elastic"}}]}
{"index":{"_id":2}}
{"id":"2","title":"Memory Issues We'll Remember","authors":[{"name":"Chris Overton","company":{"country":{"code":"FR","name":"France"},"name":"Globex"}},{"name":"Alex Brasetvik","company":{"country":{"code":"BR","name":"Brazil"},"name":"Elastic"}}]}
{"index":{"_id":3}}
{"id":"3","title":"Making Kibana Accessible","authors":[{"name":"Alex Francoeur","company":{"country":{"code":"FR","name":"France"},"name":"ACME"}},{"name":"Chris Cowan","company":{"country":{"code":"NI","name":"Nigeria"},"name":"Elastic"}},{"name":"Tim Roes","company":{"country":{"code":"JP","name":"Japan"},"name":"Soylent"}}]}</code></pre>
</div>
</div>
</li>
<li>
<p>Write and execute a query that returns all blogs written by a <code>chris</code> who
works at <code>Globex</code>.</p>
<div class="openblock solution" id="solution2"><input id="question2" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer2" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET denormalized_blogs/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "authors.name": "chris"
          }
        },
        {
          "match": {
            "authors.company.name.keyword": "Globex"
          }
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Write and execute an aggregation that returns the top 5 companies that
have an author who wrote a blog.</p>
<div class="openblock solution" id="solution3"><input id="question3" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer3" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET denormalized_blogs/_search
{
  "size": 0,
  "aggs": {
    "NAME": {
      "terms": {
        "field": "authors.company.name.keyword",
        "size": 5
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Write and execute a query that returns all blogs written by any <code>alex</code> who
works at <code>Elastic</code>.
How many documents do you expect to get back?</p>
<div class="openblock solution" id="solution4"><input id="question4" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer4" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET denormalized_blogs/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "authors.name": "alex"
          }
        },
        {
          "match": {
            "authors.company.name.keyword": "Elastic"
          }
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
<div class="paragraph">
<p><strong>NOTE</strong>: The response of the previous query was unexpected. You are going to
understand the why in the next lesson.</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary</strong>: In this lab, you explored how to denormalize data and how
denormalized data relate to mappings.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_1_1">End of Lab 1.1</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_1_2_nested_and_join_data_types">Lab 1.2: Nested and Join Data Types</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab, you will define and implement a nested type.
You will also compare the result of normal queries with the result of <code>nested</code>
ones.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>In the previous lab, you wrote and executed the following query to return all
blogs written by any <code>alex</code> who works at <code>Elastic</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET denormalized_blogs/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "authors.name": "alex"
          }
        },
        {
          "match": {
            "authors.company.name.keyword": "Elastic"
          }
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, the query above returns a document that contains an <code>alex</code> who works
at <code>ACME</code>.
As discussed in this lesson, this happens because internally Lucene flattens
the data.
Next, we will fix that.</p>
</div>
</li>
<li>
<p><strong>EXAM PREP</strong>: Use the <code>denormalized_blogs</code> mapping to create a new index named
<code>nested_blogs</code> that has <code>authors</code> mapped as <code>nested</code> instead of <code>object</code>.</p>
<div class="openblock solution" id="solution5"><input id="question5" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer5" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT nested_blogs
{
  "mappings": {
    "properties": {
      "id": {
        "type": "keyword"
      },
      "title": {
        "type": "text",
        "fields": {
          "keyword": {
            "type": "keyword"
          }
        }
      },
      "products": {
        "type": "text",
        "fields": {
          "keyword": {
            "type": "keyword"
          }
        }
      },
      "authors": {
        "type": "nested",
        "properties": {
          "name": {
            "type": "text",
            "fields": {
              "keyword": {
                "type": "keyword"
              }
            }
          },
          "company": {
            "type": "object",
            "properties": {
              "name": {
                "type": "text",
                "fields": {
                  "keyword": {
                    "type": "keyword"
                  }
                }
              },
              "country": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "text",
                    "fields": {
                      "keyword": {
                        "type": "keyword"
                      }
                    }
                  },
                  "code": {
                    "type": "keyword"
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Why don’t you have to also map <code>company</code> and <code>country</code> as <code>nested</code>?</p>
<div class="openblock solution" id="solution6"><input id="question6" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer6" style="display: block;">
<div class="content">
<div class="paragraph">
<p>Even though company and country are objects and you might want to query
multiple fields within the same query, they are not arrays.
As you can only have a single company per author and a single country per
company, there is no need to use the <code>nested</code> datatype.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>Now that you have a new index we need to index some data.
Run the following command to load the same documents into the new index.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST nested_blogs/_bulk
{"index":{"_id":1}}
{"id":"1","title":"Time Series with Kibana","authors":[{"name":"Alex Francoeur","company":{"country":{"code":"FR","name":"France"},"name":"ACME"}},{"name":"Chris Cowan","company":{"country":{"code":"NI","name":"Nigeria"},"name":"Elastic"}}]}
{"index":{"_id":2}}
{"id":"2","title":"Memory Issues We'll Remember","authors":[{"name":"Chris Overton","company":{"country":{"code":"FR","name":"France"},"name":"Globex"}},{"name":"Alex Brasetvik","company":{"country":{"code":"BR","name":"Brazil"},"name":"Elastic"}}]}
{"index":{"_id":3}}
{"id":"3","title":"Making Kibana Accessible","authors":[{"name":"Alex Francoeur","company":{"country":{"code":"FR","name":"France"},"name":"ACME"}},{"name":"Chris Cowan","company":{"country":{"code":"NI","name":"Nigeria"},"name":"Elastic"}},{"name":"Tim Roes","company":{"country":{"code":"JP","name":"Japan"},"name":"Soylent"}}]}</code></pre>
</div>
</div>
</li>
<li>
<p><strong>EXAM PREP</strong>: Next, modify the query from the first step to execute a <code>nested</code> query.
It should return a single document now.</p>
<div class="openblock solution" id="solution7"><input id="question7" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer7" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET nested_blogs/_search
{
  "query": {
    "nested": {
      "path": "authors",
      "query": {
        "bool": {
          "must": [
            {
              "match": {
                "authors.name": "alex"
              }
            },
            {
              "match": {
                "authors.company.name.keyword": "Elastic"
              }
            }
          ]
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Next, we are going to compare a normal aggregation to a <code>nested</code>
aggregation.
Run the following aggregation and analyze the results.
Are there any problems?</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET denormalized_blogs/_search
{
  "size": 0,
  "aggs": {
    "NAME": {
      "terms": {
        "field": "authors.company.name.keyword"
      },
      "aggs": {
        "NAME": {
          "terms": {
            "field": "authors.name.keyword"
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="openblock solution" id="solution8"><input id="question8" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer8" style="display: block;">
<div class="content">
<div class="paragraph">
<p>The result returns many authors as a sub-bucket of a company that they don’t work
for.
For example, <code>Elastic</code> has <code>Alex Francoeur</code>, <code>Chris Overton</code>, <code>Tim Roes</code>
as sub-buckets, even though they work for different companies.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>Based on the previous aggregation, write a nested version and execute it
against the <code>nested_blogs</code> index.
You do not want see any author as a sub-bucket of a company that they don’t work for.</p>
<div class="openblock solution" id="solution9"><input id="question9" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer9" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET nested_blogs/_search
{
  "size": 0,
  "aggs": {
    "NAME": {
      "nested": {
        "path": "authors"
      },
      "aggs": {
        "NAME": {
          "terms": {
            "field": "authors.company.name.keyword"
          },
          "aggs": {
            "NAME": {
              "terms": {
                "field": "authors.name.keyword"
              }
            }
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary:</strong> In this lab, you implemented a nested object field.
Nested and join datatypes are both good skills to know, but do
not forget the most important rule of modeling data in Elasticsearch,
which is to <strong><em>denormalize your data</em></strong>! Both nested objects and
parent/child relationships require expensive joins at runtime that are a
common cause of performance issues, and you should avoid nested types
and parent/child relationships whenever you can.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_1_2">End of Lab 1.2</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_1_3_field_modeling_and_the_elastic_common_schema">Lab 1.3: Field Modeling and the Elastic Common Schema</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab you will explore granular field modeling. You will also define field aliases.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Index the following three documents into an index called <code>version_test</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST version_test/_bulk
{"index":{"_id":1}}
{"version":"5.6.1"}
{"index":{"_id":2}}
{"version":"6.0.0"}
{"index":{"_id":3}}
{"version":"6.8.1"}</code></pre>
</div>
</div>
<div class="paragraph">
<p>These documents represent three versions: <strong>5.6.1</strong>, <strong>6.0.0</strong> and <strong>6.8.1</strong>.</p>
</div>
</li>
<li>
<p>Write a query that returns all documents with a minor version <strong>6</strong>.</p>
<div class="openblock solution" id="solution10"><input id="question10" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer10" style="display: block;">
<div class="content">
<div class="paragraph">
<p>This is not a trivial query to write. Assuming that there are no major versions larger than 9, the following wildcard query works:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET version_test/_search
{
  "query": {
    "wildcard": {
      "version.keyword": {
        "value": "??6??"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>By not structuring your data at ingestion time, you have to use expensive queries like the <code>wildcard</code> query.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>To illustrate how easier it is when you structure your data at ingestion time, index the same data into a new index <code>version_fixed</code>, applying granular fields:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST version_fixed/_bulk
{"index":{"_id":1}}
{"version":{ "display_name": "5.6.1", "major": 5, "minor": 6, "bugfix": 1}}
{"index":{"_id":2}}
{"version":{ "display_name": "6.0.0", "major": 6, "minor": 0, "bugfix": 0}}
{"index":{"_id":3}}
{"version":{ "display_name": "6.8.1", "major": 6, "minor": 8, "bugfix": 1}}</code></pre>
</div>
</div>
</li>
<li>
<p>Write a query that returns all documents with a minor version <strong>6</strong> from this new index.</p>
<div class="openblock solution" id="solution11"><input id="question11" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer11" style="display: block;">
<div class="content">
<div class="paragraph">
<p>This only requires a simple (and fast) query now: a <code>match</code> query that looks for all documents that have a <code>version.minor</code> field with a value of <strong>6</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET version_fixed/_search
{
  "query": {
    "match": {
      "version.minor": 6
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>To illustrate what happens when you do not follow a naming convention, index the following two simplified sample logs:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST loglevel_test1/_doc/
{
  "level": "info"
}

POST loglevel_test2/_doc/
{
  "log_level": "warn"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Both indexes contain documents that have a field with a <strong>log level</strong>. However, in the <code>loglevel_test1</code> index this field is called <code>level</code>, while in the <code>loglevel_test2</code> index it is called <code>log_level</code>.</p>
</div>
</li>
<li>
<p>Write a <code>terms</code> aggregation that returns the top <strong>log levels</strong> from accross the two <code>loglevel_test1</code> and <code>loglevel_test2</code> indexes.</p>
<div class="openblock solution" id="solution12"><input id="question12" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer12" style="display: block;">
<div class="content">
<div class="paragraph">
<p>This is far from easy. Because the fields that you want to aggregate on have different names in the two indexes, you cannot simply use a <code>terms</code> aggregation on a field. You would have to use a scripted aggregation. Scripted aggregations have not been covered in this module, but the request would look something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET loglevel*/_search
{
  "size": 0,
  "aggs": {
    "top_levels": {
      "terms": {
       "script": "if (doc.containsKey('level.keyword')) { return doc['level.keyword'].value } else { return doc['log_level.keyword'].value }"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>While scripted aggregations are very powerful, they are also very computationally expensive and should be avoided as much as possible.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>Let’s fix the problem using field aliases. By adding a field alias with the same name to the mappings of both indexes, pointing to our two different <strong>log level</strong> fields, you will be able to simply execute a <code>terms</code> aggregation on that field alias. Let’s adopt the <a href="https://www.elastic.co/guide/en/ecs/current/ecs-log.html">convention from Elastic Common Schema</a>, and call the field alias <code>log.level</code>.</p>
<div class="paragraph">
<p>Update the mapping of the <code>loglevel_test1</code> index and add a <code>log</code> field of type <code>object</code>, with a property <code>level</code> to it. Map <code>level</code> as an <code>alias</code> that points to the <code>level.keyword</code> field. Do the same for the <code>loglevel_test2</code> index, but now point the <code>level</code> alias to the <code>log_level.keyword</code> field.</p>
</div>
<div class="openblock solution" id="solution13"><input id="question13" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer13" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT loglevel_test1/_mapping
{
  "properties": {
    "log": {
      "properties": {
        "level": {
          "type": "alias",
          "path": "level.keyword"
        }
      }
    }
  }
}

PUT loglevel_test2/_mapping
{
  "properties": {
    "log": {
      "properties": {
        "level": {
          "type": "alias",
          "path": "log_level.keyword"
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>To validate that everything has been set up correctly, execute a <code>terms</code> aggregation on the <code>log.level</code> alias in both indexes.</p>
<div class="openblock solution" id="solution14"><input id="question14" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer14" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET loglevel*/_search
{
  "size": 0,
  "aggs": {
    "top_levels": {
      "terms": {
        "field": "log.level",
        "size": 10
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary:</strong> In this lab you have seen that by modeling your data granularly, and by using field aliases, you can avoid computationally expensive queries and aggregations.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_1_3">End of Lab 1.3</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_1_4_analyzers">Lab 1.4: Analyzers</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab, you will practice with the <strong>_analyze</strong> API to explore the
different ways to analyze text. Also, you will use your text analysis and mappings
skills to re-create the <code>blogs</code> index with a better configuration.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Test the following text using the <strong>_analyze</strong> API. Do not
specify an analyzer - just use the default one:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>"Introducing beta releases: Elasticsearch and Kibana Docker images!"</code></pre>
</div>
</div>
<div class="openblock solution" id="solution15"><input id="question15" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer15" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _analyze
{
  "text": "Introducing beta releases: Elasticsearch and Kibana Docker images!"
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>What was the default analyzer used in the previous step?</p>
<div class="openblock solution" id="solution16"><input id="question16" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer16" style="display: block;">
<div class="content">
<div class="paragraph">
<p>The <strong>standard</strong> analyzer is the default.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>Test the text again, but use the <strong>whitespace</strong> analyzer. What is the
difference?</p>
<div class="openblock solution" id="solution17"><input id="question17" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer17" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _analyze
{
  "analyzer": "whitespace",
  "text": "Introducing beta releases: Elasticsearch and Kibana Docker images!"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The whitespace analyzer does not lowercase terms and does not remove
punctuation.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>Change the analyzer a few more times, testing the <strong>stop</strong>, <strong>keyword</strong> and
<strong>english</strong> analyzers on the same text and comparing the different outputs.
Which analyzer do you think works the best for the blogs website?</p>
<div class="openblock solution" id="solution18"><input id="question18" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer18" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _analyze
{
  "analyzer": "stop",
  "text": "Introducing beta releases: Elasticsearch and Kibana Docker images!"
}

GET _analyze
{
  "analyzer": "keyword",
  "text": "Introducing beta releases: Elasticsearch and Kibana Docker images!"
}

GET _analyze
{
  "analyzer": "english",
  "text": "Introducing beta releases: Elasticsearch and Kibana Docker images!"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is hard to say which one is the best. Each dataset is different and
has its own details. You must test a lot and see which analyzer gives
you the best results. Often, you use a combination of multiple analyzers
in different multi-fields. In the blogs dataset, both the <strong>stop</strong> and the
<strong>english</strong> analyzer seem like a good choice.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>Let’s go one level lower than analyzers. Analyze the following text
using the <strong>standard</strong> tokenizer and the <strong>lowercase</strong> and <strong>snowball</strong> filters.
Now, compare the results with the output of the <strong>english</strong> analyzer. What
is different between these two techniques?</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>"text": "This release includes mainly bug fixes."</code></pre>
</div>
</div>
<div class="openblock solution" id="solution19"><input id="question19" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer19" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _analyze
{
  "tokenizer": "standard",
  "filter": ["lowercase","snowball"],
  "text": "This release includes mainly bug fixes."
}

GET _analyze
{
  "analyzer": "english",
  "text": "This release includes mainly bug fixes."
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice the <strong>english</strong> analyzer does not use the <strong>snowball</strong> stemmer. It uses
the <strong>english_stemmer</strong>, which stems "mainly" to "mainli" (instead of "main"
for the <strong>snowball</strong> stemmer). The <strong>english</strong> analyzer also removes stop words.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>Using <strong>_analyze</strong>, configure and test an analyzer that satisfies the
following:</p>
<div class="ulist">
<ul>
<li>
<p>uses the <strong>standard</strong> tokenizer</p>
</li>
<li>
<p>uses the <strong>lowercase</strong> token filter</p>
</li>
<li>
<p>uses the <strong>asciifolding</strong> token filter</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Test your analyzer with the exact text here by copy-and-pasting it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>"text": "Elasticsearch é um motor de buscas distribuído."</code></pre>
</div>
</div>
<div class="paragraph">
<p>Run the command with and without <strong>asciifolding</strong> to see its effect on
special characters.</p>
</div>
<div class="openblock solution" id="solution20"><input id="question20" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer20" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _analyze
{
  "tokenizer": "standard",
  "filter": ["lowercase", "asciifolding"],
  "text": "Elasticsearch é um motor de buscas distribuído."
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>In many use cases, the built-in analyzers are not perfect. Imagine we
want to search for <strong>C++</strong> or <strong>IT</strong>. Both the <strong>standard</strong> and the <strong>english</strong>
analyzers will not help much. Test the following sentence using the
analyze API:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>"text": "C++ can help it and your IT systems."</code></pre>
</div>
</div>
<div class="openblock solution" id="solution21"><input id="question21" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer21" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _analyze
{
  "analyzer": "english",
  "text": "C++ can help it and your IT systems."
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can see that <strong>C++</strong> became <strong>c</strong>, which is a different programming language.
The word <strong>IT</strong> has been removed completely, because it was lowercased to <strong>it</strong> and then dropped as a stopword.</p>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>EXAM PREP</strong>: To solve the problem discussed above, you need to write your own custom analyzer that
handles text like C++ and IT in a better manner.
Create an index named
<code>analysis_test</code> that has an analyzer named <code>my_analyzer</code> which satisfies the
following:</p>
<div class="ulist">
<ul>
<li>
<p>allow queries for <strong>C++</strong> to match only documents that contain <strong>C++</strong>
(<strong>TIP:</strong> transform <strong>c++</strong> and <strong>C++</strong> into <strong>cpp</strong>)</p>
</li>
<li>
<p>allow queries for <strong>IT</strong> to match only documents that contain <strong>IT</strong> and not
<strong>it</strong>. (<strong>TIP:</strong> transform <strong>IT</strong> into <strong>_IT_</strong> before lowercase)</p>
</li>
<li>
<p>lowercase all text</p>
</li>
<li>
<p>remove the default stop words</p>
</li>
<li>
<p>remove the following terms as well: <strong>can, we, our, you, your, all</strong></p>
</li>
</ul>
</div>
<div class="openblock solution" id="solution22"><input id="question22" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer22" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _analyze
{
  "analyzer": "english",
  "text": "C++ can help it and your IT systems."
}

PUT analysis_test
{
  "settings": {
    "analysis": {
      "char_filter": {
        "cpp_it": {
          "type": "mapping",
          "mappings": ["c++ =&gt; cpp", "C++ =&gt; cpp", "IT =&gt; _IT_"]
        }
      },
      "filter": {
        "my_stop": {
          "type": "stop",
          "stopwords": ["can", "we", "our", "you", "your", "all"]
        }
      },
      "analyzer": {
        "my_analyzer": {
          "tokenizer": "standard",
          "char_filter": ["cpp_it"],
          "filter": ["lowercase", "stop", "my_stop"]
        }
      }
    }
  }
}

GET analysis_test/_analyze
{
  "analyzer": "my_analyzer",
  "text": "C++ can help it and your IT systems."
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>OPTIONAL:</strong> Run the following two queries, which search for <strong>blogs</strong> that
contain <strong>c++</strong> in the <code>content</code> field and for <strong>IT</strong> in the <code>title</code> field.</p>
<div class="paragraph">
<p>Notice you get poor results in both cases
because of how the default <code>standard</code> analyzer processes <strong>c++</strong> and <strong>IT</strong>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "query": {
    "match": {
      "content": "c++"
    }
  }
}

GET blogs/_search
{
  "query": {
    "match": {
      "title": "IT"
    }
  }
}</code></pre>
</div>
</div>
</li>
<li>
<p><strong>EXAM PREP</strong>: Now, setup a new blogs index with the same data, but using a better,
more appropriate analyzer:</p>
<div class="ulist">
<ul>
<li>
<p>Create a new index named <code>blogs_analyzed</code> that uses your custom
<code>my_analyzer</code> from the previous step</p>
</li>
<li>
<p>Use the mappings from <code>blogs</code> and add a multi-field to
<strong>both</strong> the <code>content</code> and <code>title</code> fields named <code>my_analyzer</code>. These
multi-fields should be of type <code>text</code> and set the <code>analyzer</code> to <code>my_analyzer</code>.</p>
</li>
</ul>
</div>
<div class="openblock solution" id="solution23"><input id="question23" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer23" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT blogs_analyzed
{
  "settings": {
    "analysis": {
      "char_filter": {
        "cpp_it": {
          "type": "mapping",
          "mappings": [
            "c++ =&gt; cpp",
            "C++ =&gt; cpp",
            "IT =&gt; _IT_"
          ]
        }
      },
      "filter": {
        "my_stop": {
          "type": "stop",
          "stopwords": [
            "can",
            "we",
            "our",
            "you",
            "your",
            "all"
          ]
        }
      },
      "analyzer": {
        "my_analyzer": {
          "tokenizer": "standard",
          "char_filter": [
            "cpp_it"
          ],
          "filter": [
            "lowercase",
            "stop",
            "my_stop"
          ]
        }
      }
    }
  },
  "mappings": {
    "properties": {
      "author": {
        "type": "text",
        "fields": {
          "keyword": {
            "type": "keyword",
            "ignore_above": 256
          }
        }
      },
      "category": {
        "type": "keyword"
      },
      "content": {
        "type": "text",
        "fields": {
          "my_analyzer": {
            "type": "text",
            "analyzer": "my_analyzer"
          }
        }
      },
      "publish_date": {
        "type": "date"
      },
      "locales": {
        "type": "keyword"
      },
      "title": {
        "type": "text",
        "fields": {
          "keyword": {
            "type": "keyword",
            "ignore_above": 256
          },
          "my_analyzer": {
            "type": "text",
            "analyzer": "my_analyzer"
          }
        }
      },
      "url": {
        "type": "text",
        "fields": {
          "keyword": {
            "type": "keyword",
            "ignore_above": 256
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>OPTIONAL:</strong> Run the following command to index the current <code>blogs</code> into your new
<code>blogs_analyzed</code> index:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST _reindex?wait_for_completion=false
{
  "source": {"index": "blogs"},
  "dest":   {"index": "blogs_analyzed"}
}</code></pre>
</div>
</div>
</li>
<li>
<p><strong>OPTIONAL:</strong> Rerun the searches in the new index using the <code>.my_analyzer</code> field and
compare results.</p>
<div class="openblock solution" id="solution24"><input id="question24" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer24" style="display: block;">
<div class="content">
<div class="paragraph">
<p>You should only get 2 hits for "<strong>c++</strong>" and 1 hit for "<strong>IT</strong>" on the
<code>.my_analyzer</code> fields:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs_analyzed/_search
{
  "query": {
    "match": {
      "content.my_analyzer": "c++"
    }
  }
}

GET blogs_analyzed/_search
{
  "query": {
    "match": {
      "title.my_analyzer": "IT"
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary:</strong> In this lab, you have practiced with the <strong>_analyze</strong> API to explore the
different ways to analyze text. Also, you have used your text analysis and mappings
skills to re-create the <code>blogs</code> index with a better configuration.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_1_4">End of Lab 1.4</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_2_1_update_and_delete_by_query_and_reindex_apis">Lab 2.1: Update and Delete by Query and Reindex APIs</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab, you will fix some of the fields in the <code>blogs</code>
index using some of the tools you learned, including the Reindex API and
the Update By Query API.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>You are going to make several modifications to the <code>blogs</code> index, but we
want to be careful and not do anything that ruins our original blogs.
Therefore, you will reindex all of the blogs into a new index named
<code>blogs_fixed</code> that you will use throughout the lab. Run the following PUT
command, which creates <code>blogs_fixed</code> with an appropriate mapping:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT blogs_fixed
{
  "mappings": {
    "properties": {
      "author": {
        "type": "text",
        "fields": {
          "keyword": {
            "type": "keyword"
          }
        }
      },
      "category": {
        "type": "keyword"
      },
      "content": {
        "type": "text"
      },
      "locales": {
        "type": "keyword"
      },
      "publish_date": {
        "type": "date"
      },
      "seo_title": {
        "type": "text",
        "fields": {
          "keyword": {
            "type": "keyword"
          }
        }
      },
      "title": {
        "type": "text"
      },
      "url": {
        "type": "text",
        "fields": {
          "keyword": {
            "type": "keyword"
          }
        }
      },
      "number_of_views": {
        "type": "integer"
      },
      "reindexBatch": {
        "type": "byte"
      }
    }
  }
}</code></pre>
</div>
</div>
</li>
<li>
<p>Notice the <code>blogs_fixed</code> mapping has a byte field named <code>reindexBatch</code>.
Even though you didn’t learn how to use scripts yet, you are going to increment
this field every time you update the documents.
This is a best practice and allows you to handle issues that might happen
in the middle of updating.
When needed, use the code below to update the <code>reindexBatch</code> value.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>  "script": {
    "source": "ctx._source['reindexBatch'] = 1;"
  }</code></pre>
</div>
</div>
</li>
<li>
<p>Reindex <code>blogs</code> into <code>blogs_fixed</code>.
Make sure to use the script above to set the <code>reindexBatch</code> to 1.
You should see 1,594 blogs created in <code>blogs_fixed</code>. View some of the
documents in <code>blogs_fixed</code> and verify that the <code>reindexBatch</code> field was added
properly.</p>
<div class="openblock solution" id="solution25"><input id="question25" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer25" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST _reindex?wait_for_completion=false
{
  "source": {
    "index": "blogs"
  },
  "dest": {
    "index": "blogs_fixed"
  },
  "script": {
    "source": "ctx._source['reindexBatch'] = 1;"
  }
}

GET blogs_fixed/_search</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>In the previous lesson you learned how to define a custom analyzer, let’s add
this analyzer in your new <code>blogs_fixed</code> mapping.
The analysis settings are non dynamic and can’t be updated while the index is
open.
To update the analysis settings you need to close the index.
Use the following command to close the <code>blogs_fixed</code> index.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST blogs_fixed/_close</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that a closed index is blocked for read/write operations and does not
allow all operations that opened indices allow.
It is <strong>not</strong> possible to index documents or to search for documents in a closed
index.</p>
</div>
</li>
<li>
<p>Add the custom analyzer that you defined in the previous lesson.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT blogs_fixed/_settings
{
  "analysis": {
    "char_filter": {
      "cpp_it": {
        "type": "mapping",
        "mappings": [
          "c++ =&gt; cpp",
          "C++ =&gt; cpp",
          "IT =&gt; _IT_"
        ]
      }
    },
    "filter": {
      "my_stop": {
        "type": "stop",
        "stopwords": [
          "can",
          "we",
          "our",
          "you",
          "your",
          "all"
        ]
      }
    },
    "analyzer": {
      "my_analyzer": {
        "tokenizer": "standard",
        "char_filter": [
          "cpp_it"
        ],
        "filter": [
          "lowercase",
          "stop",
          "my_stop"
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
</li>
<li>
<p>You can now reopen this index.
When opening an index, the master is responsible for restarting the index shards
to reflect the new state of the index.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST blogs_fixed/_open</code></pre>
</div>
</div>
</li>
<li>
<p>Update the <code>blogs_fixed</code> mapping to add a multi-field <code>my_analyzer</code> for the
field <code>content</code> and <code>title</code>.</p>
<div class="openblock solution" id="solution26"><input id="question26" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer26" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT blogs_fixed/_mappings
{
  "properties": {
    "content": {
      "type": "text",
      "fields": {
        "my_analyzer": {
          "type": "text",
          "analyzer": "my_analyzer"
        }
      }
    },
    "title": {
      "type": "text",
      "fields": {
        "my_analyzer": {
          "type": "text",
          "analyzer": "my_analyzer"
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Now try to run a query on this new field.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs_fixed/_search
{
  "query": {
    "match": {
      "content.my_analyzer": "c++"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You didn’t get any results why?</p>
</div>
<div class="openblock solution" id="solution27"><input id="question27" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer27" style="display: block;">
<div class="content">
<div class="paragraph">
<p>The existing data was indexed before this analyzer had been defined so the new field has not yet been populated.</p>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>EXAM PREP</strong>: Using an <code>_update_by_query</code>, update all the documents in
<code>blogs_fixed</code> with a <code>reindexBatch</code> equal to 1.
Use the script given above to update the <code>reindexBatch</code> to 2 on all documents.</p>
<div class="openblock solution" id="solution28"><input id="question28" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer28" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST blogs_fixed/_update_by_query
{
  "query": {
    "match": {
      "reindexBatch": 1
    }
  },
  "script": {
    "source": "ctx._source['reindexBatch'] = 2;"
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Run your <code>_update_by_query</code> command again. Assuming that all documents were
previously updated in the first <code>_update_by_query</code>, this time the update
should return very quickly and show 0 documents being updated.</p>
</li>
<li>
<p>Try again to search on the <code>my_analyzer</code> field, you should get 2 documents.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs_fixed/_search
{
  "query": {
    "match": {
      "content.my_analyzer": "c++"
    }
  }
}</code></pre>
</div>
</div>
</li>
<li>
<p>Delete all the documents where the <code>category</code> is <code>Releases</code>.
You should delete 238 documents.</p>
<div class="openblock solution" id="solution29"><input id="question29" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer29" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST blogs_fixed/_delete_by_query
{
  "query": {
    "match": {
      "category": "Releases"
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary:</strong> In this lab, you fixed the mapping of the blogs index by using the
<code>_reindex</code> API.
You also learned how to update documents inside an index by using update and
delete by query.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_2_1">End of Lab 2.1</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_2_2_ingest_nodes_and_pipelines">Lab 2.2: Ingest Nodes and Pipelines</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab, you will use ingest pipelines to clean the data of your <code>blogs_fixed</code> index.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Let’s clean up the <code>locales</code> field in <code>blogs_fixed</code>. Run the
following <code>terms</code> aggregation and analyze the results. What could be
improved on the <code>locales</code> field?</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs_fixed/_search
{
  "size": 0,
  "aggs": {
    "locale_terms": {
      "terms": {
        "field": "locales",
        "size": 10
      }
    }
  }
}</code></pre>
</div>
</div>
</li>
<li>
<p><strong>EXAM PREP</strong>: The <code>locales</code> field is empty for 1,290 documents, which is over 90% of
the index. These particular documents should have the English locale
"<strong>en-en</strong>". Also, as discussed in the lecture, this field would be much
easier to search and aggregate on if it was indexed as an array instead
of a single comma-separated list of values. To fix <code>locales</code>, write a
pipeline that satisfies the following criteria:</p>
<div class="ulist">
<ul>
<li>
<p>The name of the pipeline is <code>fix_locales</code></p>
</li>
<li>
<p>The first processor is a <code>set</code> processor that checks if the <code>locales</code>
field is an empty string. If it is empty, assign it the value "<strong>en-en</strong>".
If it is not empty, leave the field as is.
<strong>TIP:</strong> To check if a field is empty you can use <code>ctx['field'].empty</code> in the
<code>if</code> option of your processor.</p>
</li>
<li>
<p>The second <code>set</code> processor should set <code>reindexBatch</code> to 3 for every
document</p>
</li>
<li>
<p>The third processor is a <code>split</code> processor that splits the <code>locales</code>
field into an array, using a comma as the separator</p>
</li>
</ul>
</div>
<div class="openblock solution" id="solution30"><input id="question30" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer30" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT _ingest/pipeline/fix_locales
{
  "processors": [
    {
      "set": {
        "if": "ctx['locales'].empty",
        "field": "locales",
        "value": "en-en"
      }
    },
    {
      "set": {
        "field": "reindexBatch",
        "value": 3
      }
    },
    {
      "split": {
        "field": "locales",
        "separator": ","
      }
    }
  ]
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Test the following two documents on your <code>fix_locales</code> pipeline:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{
  "locales": "de-de,fr-fr,ja-jp,ko-kr"
}

{
  "locales": ""
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If successful, the results should look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{
  "docs": [
    {
      "doc": {
        ...
        "_source": {
          "locales": [
            "de-de",
            "fr-fr",
            "ja-jp",
            "ko-kr"
          ],
          "reindexBatch": 3
        },
        ...
      }
    },
    {
      "doc": {
        ...
        "_source": {
          "locales": [
            "en-en"
          ],
          "reindexBatch": 3
        },
        ...
      }
    }
  ]
}</code></pre>
</div>
</div>
<div class="openblock solution" id="solution31"><input id="question31" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer31" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST _ingest/pipeline/fix_locales/_simulate
{
  "docs": [
    {
      "_source": {
        "locales": "de-de,fr-fr,ja-jp,ko-kr"
      }
    },
    {
      "_source": {
        "locales": ""
      }
    }
  ]
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>EXAM PREP</strong>: Using an <code>_update_by_query</code>, update all documents in <code>blogs_fixed</code> with a
<code>reindexBatch</code> equal to 2. Use the <code>fix_locales</code> pipeline to update the documents.</p>
<div class="openblock solution" id="solution32"><input id="question32" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer32" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST blogs_fixed/_update_by_query?pipeline=fix_locales
{
  "query": {
    "match": {
      "reindexBatch": 2
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>OPTIONAL:</strong> Check the stats of your pipeline by running the following query.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _nodes/stats/ingest?filter_path=nodes.*.ingest.pipelines.fix_locales</code></pre>
</div>
</div>
<div class="paragraph">
<p>This shows how many documents have been processed for each processor in your pipeline.</p>
</div>
</li>
<li>
<p>Run the <code>terms</code> aggregation again on the <code>locales</code> field. You should see
completely different results this time. Notice each locale is broken out
into a single value, so you are getting an accurate count of each
individual locale:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>"aggregations" : {
  "locale_terms" : {
    "doc_count_error_upper_bound" : 0,
    "sum_other_doc_count" : 0,
    "buckets" : [
      {
        "key" : "en-en",
        "doc_count" : 1290
      },
      {
        "key" : "fr-fr",
        "doc_count" : 43
      },
      {
        "key" : "de-de",
        "doc_count" : 41
      },
      {
        "key" : "ko-kr",
        "doc_count" : 37
      },
      {
        "key" : "ja-jp",
        "doc_count" : 34
      },
      {
        "key" : "zh-chs",
        "doc_count" : 8
      }
    ]
  }
}</code></pre>
</div>
</div>
</li>
<li>
<p>Use the following query to view the <code>locales</code> of some documents from
<code>blogs_fixed</code>. Notice the values of the <code>locales</code> are all in an array now:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs_fixed/_search
{
  "size": 100,
  "_source": "locales"
}</code></pre>
</div>
</div>
</li>
<li>
<p><strong>EXAM PREP</strong>: Your front-end developer forgot to tell you that he is expecting locales to be separated by an <code>underscore</code> (<strong>_</strong>) instead of a <code>hyphen</code> (<strong>-</strong>).
For instance, <code>en-en</code> should be <code>en_en</code>. To fix it, write a pipeline that satisfies the following criteria:</p>
<div class="ulist">
<ul>
<li>
<p>The name of the pipeline is <code>underscore_locales</code></p>
</li>
<li>
<p>Using a <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/foreach-processor.html" target="_blank" rel="noopener">foreach processor</a> and a <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/gsub-processor.html" target="_blank" rel="noopener">gsub processor</a>, replace all the <code>hyphen</code> by <code>underscore</code> in the locales.</p>
</li>
<li>
<p>The second set processor should set reindexBatch equal to 4 for every document</p>
</li>
</ul>
</div>
<div class="openblock solution" id="solution33"><input id="question33" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer33" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT _ingest/pipeline/underscore_locales
{
  "processors": [
    {
      "foreach": {
        "field": "locales",
        "processor": {
          "gsub": {
            "field": "_ingest._value",
            "pattern": "-",
            "replacement": "_"
          }
        }
      }
    },
    {
      "set": {
        "field": "reindexBatch",
        "value": 4
      }
    }
  ]
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Test your pipeline on this document.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>"locales": [
    "de-de",
    "fr-fr",
    "ja-jp",
    "ko-kr",
    "zh-chs"
  ]</code></pre>
</div>
</div>
<div class="paragraph">
<p>If successful, the results should look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>"_source" : {
  "locales" : [
    "de_de",
    "fr_fr",
    "ja_jp",
    "ko_kr",
    "zh_chs"
  ],
  "reindexBatch" : 4
}</code></pre>
</div>
</div>
<div class="openblock solution" id="solution34"><input id="question34" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer34" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST _ingest/pipeline/underscore_locales/_simulate
{
  "docs": [
    {
      "_source": {
        "locales": [
            "de-de",
            "fr-fr",
            "ja-jp",
            "ko-kr",
            "zh-chs"
          ]
      }
    }
  ]
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Using an <code>_update_by_query</code>, update all documents in <code>blogs_fixed</code> with a
<code>reindexBatch</code> equal to 3 with the <code>underscore_locales</code> pipeline.</p>
<div class="openblock solution" id="solution35"><input id="question35" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer35" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST blogs_fixed/_update_by_query?pipeline=underscore_locales
{
  "query": {
    "match": {
      "reindexBatch": 3
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Use the previous <code>_search</code> query to verify that your documents are successfully updated.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs_fixed/_search
{
  "size": 100,
  "_source": "locales"
}</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary:</strong> In this lab, you saw how to use ingest pipeline to apply modifications to your documents.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_2_2">End of Lab 2.2</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_2_3_painless_scripting">Lab 2.3: Painless Scripting</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab, you will familiarize yourself with the <code>painless</code> scripting language.</p>
</div>
<div class="paragraph">
<p><em>WARNING:</em> Even though the dot notation (e.g. <code>ctx.title</code>) is commonly used in
scripting languages and in the painless documentation, it <strong>doesn’t</strong> accept some
special characters (e.g <code>ctx.@timestamp</code>).
If you want to access the field <code>@timestamp</code> you need to use the brackets
notation (e.g. <code>ctx['@timestamp']</code>.
Therefore, we use the brackets notation in all the examples.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Let’s continue to clean up the <code>blogs_fixed</code> index by cleaning the <code>seo_title</code> field. Run the following query, and
notice that 1,085 blog posts have an empty <code>seo_title</code> field (which is
80% of our blogs!).</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs_fixed/_search
{
  "query": {
    "bool": {
      "filter": {
        "match": {
          "seo_title.keyword": ""
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</li>
<li>
<p><strong>EXAM PREP</strong>: Define an ingest pipeline that satisfies the following criteria:</p>
<div class="ulist">
<ul>
<li>
<p>The name of the pipeline is <code>fix_seo_title</code></p>
</li>
<li>
<p>Add a <code>script</code> processor that checks if the <code>seo_title</code> is equal to an
empty string "". If it is, set <code>seo_title</code> to the value of the document’s
<code>title</code> field.
<strong>TIP:</strong> As you are going to run this script in an ingest pipeline, the syntax
for accessing the fields of a document is <code>ctx['field_name']</code> (without the
<code>_source</code>).
For example, to access the <code>seo_title</code> in your script, use <code>ctx['seo_title']</code>.</p>
</li>
<li>
<p>Set the value of <code>reindexBatch</code> to 5 for every document</p>
</li>
</ul>
</div>
<div class="openblock solution" id="solution36"><input id="question36" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer36" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT _ingest/pipeline/fix_seo_title
{
  "processors": [
    {
      "script": {
        "source": """
if("".equals(ctx['seo_title'])) {
  ctx['seo_title'] = ctx['title'];
}
ctx['reindexBatch'] = 5;
"""
      }
    }
  ]
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>You should always test a pipeline with some sample documents before
running it on your entire index! Test your <code>fix_seo_title</code> pipeline using
the following two documents:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{
   "title": "Where in the World is Elastic? - Elastic{ON}Tour London &amp; Paris",
   "seo_title": ""
}

{
   "title": "This week in Elasticsearch and Apache Lucene",
   "seo_title": "What's new in Elasticsearch and Apache Lucene"
}</code></pre>
</div>
</div>
<div class="openblock solution" id="solution37"><input id="question37" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer37" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST _ingest/pipeline/fix_seo_title/_simulate
{
  "docs": [
    {
      "_source": {
        "title": "Where in the World is Elastic? - Elastic{ON}Tour London &amp; Paris",
        "seo_title": ""
      }
    },
    {
      "_source": {
        "title": "This week in Elasticsearch and Apache Lucene",
        "seo_title": "What's new in Elasticsearch and Apache Lucene"
      }
    }
  ]
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>EXAM PREP</strong>: Run an <code>_update_by_query</code> on <code>blogs_fixed</code>, sending each document through
your <code>fix_seo_title</code> pipeline. Your update by query should only update
documents that have a <code>reindexBatch</code> value equal to 4. You should see that
all 1,356 documents are updated.</p>
<div class="openblock solution" id="solution38"><input id="question38" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer38" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST blogs_fixed/_update_by_query?pipeline=fix_seo_title
{
  "query": {
    "match": {
      "reindexBatch": 4
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Run the following query again, and notice now that none of your
documents have an empty <code>seo_title</code> field:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs_fixed/_search
{
  "query": {
    "bool": {
      "filter": {
        "match": {
          "seo_title.keyword": ""
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</li>
<li>
<p>Next, imagine that every document in <code>blogs_fixed</code> should have the number of
views of that blog.
Run an <code>update_by_query</code> with a script that sets the <code>number_of_views</code> field
to 0 on every document.</p>
<div class="openblock solution" id="solution39"><input id="question39" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer39" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST blogs_fixed/_update_by_query
{
  "script": {
    "source": "ctx._source['number_of_views'] = 0"
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Next, you will write a script that updates the number of views that a
blog gets based on the web access logs.
Run the following query and copy the document <code>_id</code> returned, as you will need
it in later steps:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs_fixed/_search
{
  "query": {
    "bool": {
      "filter": {
        "match": {
          "url.keyword": "/blog/elasticsearch-storage-the-true-story"
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should get one hit: a blog titled <em>"The true story behind Elasticsearch storage requirements"</em>. Now run the following query, which
hits every log entry for this blog on May 12, 2017. You should get 41
hits:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_server*/_search
{
  "query": {
    "bool": {
      "filter": [
        {
          "range": {
            "@timestamp": {
              "gte": "2017-05-12",
              "lt": "2017-05-13"
            }
          }
        },
        {
          "match": {
            "originalUrl.keyword": "/blog/elasticsearch-storage-the-true-story"
          }
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
</li>
<li>
<p>Using an <code>_update</code> and an inline script, add 41 to the
<code>number_of_views</code> field of the blog above.
You will need the <code>_id</code> of the blog, which you already copied from the result
of the first query in the previous step.</p>
<div class="openblock solution" id="solution40"><input id="question40" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer40" style="display: block;">
<div class="content">
<div class="paragraph">
<p>The code below will only work if you modify the ID to match the actual
<code>_id</code> of the blog post:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST blogs_fixed/_update/G81CKmIBCLh5xF6i9JLm
{
  "script": {
    "source": "ctx._source['number_of_views'] += 41"
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Get the blog post that you just modified and verify that its
<code>number_of_views</code> is now 41.</p>
<div class="openblock solution" id="solution41"><input id="question41" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer41" style="display: block;">
<div class="content">
<div class="paragraph">
<p>Again, you will need to use the appropriate <code>_id</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs_fixed/_doc/G81CKmIBCLh5xF6i9JLm</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>This script seems to work fine, let’s store this script so you can get the most out of caching. Write a script that satisfies the following criteria:</p>
<div class="ulist">
<ul>
<li>
<p>The script is stored in the cluster state with the id
<code>add_to_number_of_views</code></p>
</li>
<li>
<p>The script increments <code>number_of_views</code> by the amount of the value in a
parameter named <code>new_views</code></p>
</li>
</ul>
</div>
<div class="openblock solution" id="solution42"><input id="question42" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer42" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT _scripts/add_to_number_of_views
{
  "script": {
    "lang": "painless",
    "source": "ctx._source['number_of_views'] += params['new_views']"
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Run the following query and notice there are 11 hits for the same blog
received on May 13, 2017:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_server*/_search
{
  "query": {
    "bool": {
      "filter": [
        {
          "range": {
            "@timestamp": {
              "gte": "2017-05-13",
              "lt": "2017-05-14"
            }
          }
        },
        {
          "match": {
            "originalUrl.keyword": "/blog/elasticsearch-storage-the-true-story"
          }
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using the script <code>add_to_number_of_views</code>, increment the <code>number_of_views</code> for this blog by 11 and verify that the new
value of <code>number_of_views</code> is 52.</p>
</div>
<div class="openblock solution" id="solution43"><input id="question43" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer43" style="display: block;">
<div class="content">
<div class="paragraph">
<p>There are 11 visits to the blog on May 13, 2017. Again, you will need to use the appropriate <code>_id</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST blogs_fixed/_update/G81CKmIBCLh5xF6i9JLm
{
  "script": {
    "id": "add_to_number_of_views",
    "params": {
      "new_views": 11
    }
  }
}

GET blogs_fixed/_doc/G81CKmIBCLh5xF6i9JLm</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>OPTIONAL:</strong> Because an ingest pipeline cannot send requests to another Elasticsearch index, you cannot automatically update every <code>number_of_views</code>. Doing so requires an external script or tools like Logstash.</p>
<div class="paragraph">
<p>Let’s simulate the number of views for the other blogs. Write a script <code>add_random_number_of_views</code> which sets the field <code>number_of_views</code> to a random integer between 0 and 10,000. You will use this script in an ingest pipeline so make sure to use the syntax accordingly.</p>
</div>
<div class="paragraph">
<p><strong>TIP:</strong> You should use the class <a href="https://www.elastic.co/guide/en/elasticsearch/painless/current/painless-api-reference-shared-java-util.html#painless-api-reference-shared-Random" target="_blank" rel="noopener">Random</a></p>
</div>
<div class="openblock solution" id="solution44"><input id="question44" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer44" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT _scripts/add_random_number_of_views
{
  "script": {
    "lang": "painless",
    "source": "Random rnd = new Random(); ctx['number_of_views'] = rnd.nextInt(10001);"
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>OPTIONAL:</strong> Create an ingest pipeline <code>number_of_views</code> which uses the script that you previously created.</p>
<div class="openblock solution" id="solution45"><input id="question45" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer45" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT _ingest/pipeline/number_of_views
{
  "processors": [
    {
      "script": {
        "id": "add_random_number_of_views"
      }
    }
  ]
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>OPTIONAL:</strong> Update every blogs except the one that you already updated (the url is <code>/blog/elasticsearch-storage-the-true-story</code>). You should update 1,355 documents.</p>
<div class="openblock solution" id="solution46"><input id="question46" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer46" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST blogs_fixed/_update_by_query?pipeline=number_of_views
{
  "query": {
    "bool": {
      "must_not": [
        {
          "match": {
            "url.keyword": "/blog/elasticsearch-storage-the-true-story"
          }
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary:</strong> In this lab, you learned how to define script using the <code>painless</code> language.
You learned how to store scripts and use it to update some documents of your index.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_2_3">End of Lab 2.3</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_3_1_securing_elasticsearch">Lab 3.1: Securing Elasticsearch</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective</strong>: In this lab, you will secure a one node Elasticsearch cluster with
Elastic security and then you will also create users and roles for your
secure cluster. <strong>This entire lab should be considered as preparation for the
certification exam.</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Elastic Stack security features enable you to lock down your cluster and
setup users and roles.
In this lab you are going to secure a separate one node cluster.
First, open a new tab and ssh to <code>server7</code>.</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>ssh server7</code></pre>
</div>
</div>
</li>
<li>
<p>Next, configure <code>node7</code> and enable elastic security.
In the <code>elasticsearch.yml</code> configuration file, <strong>delete all existing lines and
replace with the following lines</strong>:</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>cluster.name: my_secure_cluster
node.name: ${NODENAME}
network.host: _site_
xpack.security.enabled: true
discovery.type: single-node</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>NOTE: Ensure you have cleared the original contents of the <code>elasticsearch.yml</code> file and replaced the contents, exactly, with what is listed above.</strong></p>
</div>
</li>
<li>
<p>Start Elasticsearch.</p>
<div class="openblock solution" id="solution47"><input id="question47" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer47" style="display: block;">
<div class="content">
<div class="paragraph">
<p>As usual, run the following command:</p>
</div>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>./elasticsearch/bin/elasticsearch</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Open a new terminal and try running the following command:</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>curl 'server7:9200/_cat/nodes?pretty'</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should get the following security error because you are trying to access a
secure cluster without any credentials.</p>
</div>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>{
  "error" : {
    "root_cause" : [
      {
        "type" : "security_exception",
        "reason" : "missing authentication token for REST request [/_cat/nodes?pretty]",
        "header" : {
          "WWW-Authenticate" : "Basic realm=\"security\" charset=\"UTF-8\""
        }
      }
    ],
    "type" : "security_exception",
    "reason" : "missing authentication token for REST request [/_cat/nodes?pretty]",
    "header" : {
      "WWW-Authenticate" : "Basic realm=\"security\" charset=\"UTF-8\""
    }
  },
  "status" : 401
}</code></pre>
</div>
</div>
</li>
<li>
<p>You need to create some credentials. Login to <code>server7</code> and run the
<code>elasticsearch-setup-passwords</code> script:</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>ssh server7
./elasticsearch/bin/elasticsearch-setup-passwords interactive</code></pre>
</div>
</div>
<div class="paragraph">
<p>You will be prompted for a password for each one of the reserved users.
Just enter <strong>password</strong> for all the passwords to keep things simple:</p>
</div>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>Initiating the setup of passwords for reserved users elastic,apm_system,kibana,logstash_system,beats_system,remote_monitoring_user.
You will be prompted to enter passwords as the process progresses.
Please confirm that you would like to continue [y/N]y


Enter password for [elastic]:
Reenter password for [elastic]:
Enter password for [apm_system]:
Reenter password for [apm_system]:
Enter password for [kibana]:
Reenter password for [kibana]:
Enter password for [logstash_system]:
Reenter password for [logstash_system]:
Enter password for [beats_system]:
Reenter password for [beats_system]:
Enter password for [remote_monitoring_user]:
Reenter password for [remote_monitoring_user]:
Changed password for user [apm_system]
Changed password for user [kibana]
Changed password for user [logstash_system]
Changed password for user [beats_system]
Changed password for user [remote_monitoring_user]
Changed password for user [elastic]</code></pre>
</div>
</div>
</li>
<li>
<p>Now, run the same command as before but with the username and password.
(<strong>WARNING</strong>: Never provide password in plain text in sensitive environments.)</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>curl 'http://elastic:password@server7:9200/_cat/nodes'</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should get the following response.</p>
</div>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>172.18.0.8 23 14 0 0.00 0.00 0.00 dim * node7</code></pre>
</div>
</div>
<div class="paragraph">
<p>This also means that Kibana will not be able to connect without credentials.</p>
</div>
</li>
<li>
<p>Next, you are going to see how to use Kibana with security.
Navigate to the terminal window that has Kibana up and running.
Stop Kibana by pressing <code>ctrl+c</code> and then run the following command to start
Kibana connecting to <code>node7</code>.
(<strong>WARNING</strong>: Never provide password in plain text in sensitive environments.)</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>./kibana/bin/kibana --elasticsearch.hosts="http://server7:9200" --elasticsearch.username=kibana --elasticsearch.password=password</code></pre>
</div>
</div>
</li>
<li>
<p>Try connecting to your Kibana instance from a new web browser tab, and you
should see a login page.
Login as the "<strong>elastic</strong>" user with password "<strong>password</strong>":
<span class="image"><img src="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/images/security_login.png" alt="security login"></span></p>
</li>
<li>
<p>Click on the "<strong>Management</strong>" link in the left toolbar. Notice you have
some new settings to configure now that Elastic security is enabled:
<span class="image"><img src="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/images/security_management.png" alt="security management"></span></p>
</li>
<li>
<p>Create a new role named <code>read_only</code> that satisfies the following
criteria:</p>
<div class="ulist">
<ul>
<li>
<p>The user has no cluster privileges</p>
</li>
<li>
<p>The user has access to indices that match the pattern <code>*</code></p>
</li>
<li>
<p>The index privileges are only <code>read</code></p>
</li>
</ul>
</div>
<div class="openblock solution" id="solution48"><input id="question48" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer48" style="display: block;">
<div class="content">
<div class="paragraph">
<p><span class="image"><img src="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/images/security_new_role.png" alt="security new role"></span></p>
</div>
</div>
</div></div>
</li>
<li>
<p>Create a new user named <code>read_only_user</code> that satisfies the following
criteria:</p>
<div class="ulist">
<ul>
<li>
<p>password is "<strong>password</strong>"</p>
</li>
<li>
<p>enter <strong>Read Only User</strong> for the name of the user</p>
</li>
<li>
<p>use your own email address</p>
</li>
<li>
<p>assign the user to <strong>two</strong> roles: <code>read_only</code> and <code>kibana_user</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>NOTE: Make sure to add the <code>kibana_user</code> role, otherwise you won’t be able to
login to Kibana with <code>read_only_user</code>.</strong></p>
</div>
<div class="openblock solution" id="solution49"><input id="question49" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer49" style="display: block;">
<div class="content">
<div class="paragraph">
<p><span class="image"><img src="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/images/security_new_user.png" alt="security new user"></span></p>
</div>
</div>
</div></div>
</li>
<li>
<p>Logout and login again as <code>read_only_user</code> user.
Navigate to the Console and run the commands below.
Notice that the only successful command is the <code>_search</code>-request, as it is only reading data.</p>
<div class="listingblock source">
<div class="content">
<pre>GET /

GET _search

PUT new_index/_doc/1
{
  "security_test": "this will fail"
}</pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary</strong>: In this lab, you secured a one node cluster using Elastic security
and then you saw how to create a user that has limited access to specific
indices.
This lab uses a one node only cluster to simplify the lab.
To learn how to properly secure a multi-node cluster we recommend you take the
<a href="https://www.elastic.co/training/specializations/elastic-stack-management/fundamentals-of-securing-elasticsearch">Fundamentals of Securing Elasticsearch</a>
course.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_3_1">End of Lab 3.1</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_3_2_development_vs_production_mode">Lab 3.2: Development vs. Production Mode</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab, you will try to startup a node that does not
pass the bootstrap checks.
You will also see how the request cache works.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Before you start this lab, you should cleanup the previous lab
(Securing Elasticsearch):</p>
<div class="ulist">
<ul>
<li>
<p>Stop elasticsearch on <code>node7</code> and close the terminal tab</p>
</li>
<li>
<p>Stop Kibana and restart it without any command line parameter</p>
</li>
<li>
<p>Refresh your Kibana tab</p>
<div class="openblock solution" id="solution50"><input id="question50" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer50" style="display: block;">
<div class="content">
<div class="paragraph">
<p>In the <code>node7</code> Elasticsearch tab, press <code>ctrl+c</code> to stop Elasticsearch.
Then, close the tab.</p>
</div>
<div class="paragraph">
<p>In the Kibana tab, press <code>ctrl+c</code> to stop Kibana.
Then, execute the following command:</p>
</div>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>./kibana/bin/kibana</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, don’t forget to refresh your Kibana tab.</p>
</div>
</div>
</div></div>
</li>
</ul>
</div>
</li>
<li>
<p>Next, you will better understand bootstrap checks.
Open a new tab and ssh to <code>server6</code>. Edit the Elasticsearch <code>jvm.options</code>
file and set the initial heap size to <code>512m</code> and the maximum heap size to
<code>1g</code>.</p>
<div class="openblock solution" id="solution51"><input id="question51" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer51" style="display: block;">
<div class="content">
<div class="paragraph">
<p>Put the following entries in <code>elasticsearch/config/jvm.options</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>-Xms512m
-Xmx1g</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Try to startup <code>node6</code>. What happens?</p>
<div class="openblock solution" id="solution52"><input id="question52" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer52" style="display: block;">
<div class="content">
<div class="paragraph">
<p>Elasticsearch fails to start because it fails one of the bootstrap
checks. The min and max heap sizes have to be configured to the same
value. You should see the following error:</p>
</div>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>ERROR: [1] bootstrap checks failed
[1]: initial heap size [536870912] not equal to maximum heap size [1073741824]; this can cause resize pauses and prevents mlockall from locking the entire heap</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Set both the min and max heap size on <code>server6</code> to <code>512m</code>, but do not
startup Elasticsearch yet.
We will be using <code>server6</code> again in a later lab.</p>
</li>
<li>
<p>Now, you are going to explore the request cache. In order to
notice the impact of caching, you will need to put some load in the
cluster. An aggregation that has to iterate all documents many times
will help. In this example, you will run an aggregation that has three
terms aggregations (one "root" aggregation, one "sub-bucket"
aggregation, and one "sub-sub-bucket" aggregation). Run the following
search command multiple times and notice that the <code>took</code> time is going to
decrease after a few executions and become really small. Remember that
the request cache is enabled by default.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_*/_search
{
  "size": 0,
  "aggs": {
    "NAME": {
      "terms": {
        "field": "geoip.country_name.keyword",
        "size": 100
      },
      "aggs": {
        "NAME": {
          "terms": {
            "field": "geoip.region_name.keyword",
            "size": 100
          },
          "aggs": {
            "NAME": {
              "terms": {
                "field": "geoip.city_name.keyword",
                "size": 1
              }
            }
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</li>
<li>
<p>If you really want to verify if the speed is related to
the request cache, execute the same search with the <code>request_cache</code>
parameter set to <code>false</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_*/_search?request_cache=false
{
  "size": 0,
  "aggs": {
    "NAME": {
      "terms": {
        "field": "geoip.country_name.keyword",
        "size": 100
      },
      "aggs": {
        "NAME": {
          "terms": {
            "field": "geoip.region_name.keyword",
            "size": 100
          },
          "aggs": {
            "NAME": {
              "terms": {
                "field": "geoip.city_name.keyword",
                "size": 1
              }
            }
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</li>
<li>
<p>The request cache does not work by default if the search
returns hits. Update the <code>size</code> to 10 and run the aggregation a few
times without the <code>request_cache</code> parameter. Notice that the execution
time is high and it does not matter how many times you execute it, it
will not be under 50ms.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_*/_search
{
  "size": 10,
  "aggs": {
    "NAME": {
      "terms": {
        "field": "geoip.country_name.keyword",
        "size": 100
      },
      "aggs": {
        "NAME": {
          "terms": {
            "field": "geoip.region_name.keyword",
            "size": 100
          },
          "aggs": {
            "NAME": {
              "terms": {
                "field": "geoip.city_name.keyword",
                "size": 1
              }
            }
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</li>
<li>
<p>You can force any request to be cached by appending
<code>?request_cache=true</code> to the URI. Add this parameter to the previous
search and run it again.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_*/_search?request_cache=true
{
  "size": 10,
  "aggs": {
    "NAME": {
      "terms": {
        "field": "geoip.country_name.keyword",
        "size": 100
      },
      "aggs": {
        "NAME": {
          "terms": {
            "field": "geoip.region_name.keyword",
            "size": 100
          },
          "aggs": {
            "NAME": {
              "terms": {
                "field": "geoip.city_name.keyword",
                "size": 1
              }
            }
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that the first request will take a long time to execute. Then,
starting with the second request, executions will be really fast, which
means the request cache is being used. Remember that the request cache
will not work on indices under constant indexing operations.</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary:</strong> In this lab, you saw how a node will not startup properly if
it fails the bootstrap checks.
You also saw how the request cache works.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_3_2">End of Lab 3.2</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_3_3_scaling_elasticsearch">Lab 3.3: Scaling Elasticsearch</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective</strong>: In this lab, you will test over allocation of shards.
You will also explore how to scale for reads with replicas and some settings
to optimize write throughput during an initial load.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create one index called <code>temp1</code> with the following command:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT temp1</code></pre>
</div>
</div>
</li>
<li>
<p>Run the following <code>_cat</code> command to review the default number
of primary and replica shards as well as how the shards of <code>temp1</code>
got allocated:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cat/shards/temp1?v&amp;h=index,shard,prirep,state,node&amp;s=index,shard,prirep</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should get a response similar to the one below. The shards might be allocated to other nodes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>index shard prirep state   node
temp1 0     p      STARTED node2
temp1 0     r      STARTED node3</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>temp1</code> index has the default number of one primary and replica shards.
Even though these settings work great for several applications, you might want
to have more primary shards to over allocate your shards and take advantage of
your four data nodes, assuming that you are going to have a lot of data being
stored in this index.</p>
</div>
</li>
<li>
<p>Create one index called <code>temp3</code> that has three primary shards and zero replica
shards, and disable refresh.
You are creating <code>temp3</code> with <code>index.refresh_interval</code> set to <code>-1</code> and
<code>index.number_of_replicas</code> set to <code>0</code> because you are going to load a
large amount of data at once in the next steps.</p>
<div class="openblock solution" id="solution53"><input id="question53" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer53" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT temp3
{
  "settings": {
    "index.refresh_interval": -1,
    "index.number_of_replicas": 0,
    "index.number_of_shards": 3
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Before loading data into <code>temp3</code>, run the following <code>_cat</code> command to review
its shard allocation:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cat/shards/temp3?v&amp;h=index,shard,prirep,state,node&amp;s=index,shard,prirep</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should get a response similar to the one below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>index shard prirep state   node
index shard prirep state   node
temp3 0     p      STARTED node2
temp3 1     p      STARTED node3
temp3 2     p      STARTED node1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that you should have one primary shard allocated per data node.</p>
</div>
</li>
<li>
<p>Reindex all documents from <code>logs_server*</code> into <code>temp3</code>.
Set <code>wait_for_completion</code> to <code>false</code>, so you can proceed to the next steps.</p>
<div class="openblock solution" id="solution54"><input id="question54" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer54" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST _reindex?wait_for_completion=false
{
  "source": {
    "index": "logs_server*"
  },
  "dest": {
    "index": "temp3"
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>How many documents do you get if you run the following command to check
how your data load is working? Why?</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET temp3/_count</code></pre>
</div>
</div>
<div class="openblock solution" id="solution55"><input id="question55" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer55" style="display: block;">
<div class="content">
<div class="paragraph">
<p>The document count is still zero because you have disabled refreshing on <code>temp3</code>.
Note that you actually wanted this behavior because you are doing an initial
load of <code>temp3</code>.
Because you needed to load a large amount of data at once,
you disabled refresh by setting <code>index.refresh_interval</code> to <code>-1</code> and
you also disabled replicas by setting <code>index.number_of_replicas</code> to <code>0</code>.
Note that this will temporarily put your index at risk since the loss of any
shard will cause data loss, but at the same time indexing will be faster
since documents will be indexed only once.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>Use the following command to monitor whether your reindex process have
finished.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _tasks?actions=*reindex</code></pre>
</div>
</div>
<div class="paragraph">
<p>You will know that it finished when the response does not contain any
reindex task.
If you want to cross check, you can also run the following command and check
whether <code>docs.count</code> for <code>temp3</code> is <code>1751477</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cat/indices/temp3?v</code></pre>
</div>
</div>
</li>
<li>
<p>Now that you finished your initial load, enable refresh on <code>temp3</code> and
bring it back to the <code>1s</code> default configuration.</p>
<div class="openblock solution" id="solution56"><input id="question56" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer56" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT temp3/_settings
{
  "index.refresh_interval": "1s"
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>How many documents do you get now by running the following command? Why?</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET temp3/_count</code></pre>
</div>
</div>
<div class="openblock solution" id="solution57"><input id="question57" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer57" style="display: block;">
<div class="content">
<div class="paragraph">
<p>Now you get <code>1751477</code> because all the documents got refreshed after you
enabled back the refresh interval to one second.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>After your initial load finished and you enabled back the refresh interval,
it is also a good idea to add some replicas to your index.
Run the following command to auto-expand the number of replicas for the <code>temp3</code>
index based on the number of data nodes in the cluster.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT temp3/_settings
{
  "index.auto_expand_replicas": "0-all"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>IMPORTANT:</strong> Note that the auto-expanded number of replicas does not take any other
allocation rules into account, such as shard allocation awareness,
filtering or total shards per node, and this can lead to the cluster health
becoming <strong>yellow</strong> if the applicable rules prevent all the replicas from being
allocated.</p>
</div>
</li>
<li>
<p>Run the following <code>_cat</code> command to review <code>temp3</code> shard allocation.
How many replica shards do you have after enabling auto-expanded replicas?</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cat/shards/temp3?v&amp;h=index,shard,prirep,state,node&amp;s=index,shard,prirep</code></pre>
</div>
</div>
<div class="openblock solution" id="solution58"><input id="question58" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer58" style="display: block;">
<div class="content">
<div class="paragraph">
<p>You should get a response similar to the one below, indicating that you have
three replica shards for each primary shard.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>index shard prirep state   node
temp3 0     p      STARTED node2
temp3 0     r      STARTED node3
temp3 0     r      STARTED node1
temp3 1     p      STARTED node3
temp3 1     r      STARTED node2
temp3 1     r      STARTED node1
temp3 2     p      STARTED node1
temp3 2     r      STARTED node2
temp3 2     r      STARTED node3</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>NOTE:</strong> It may take some time until your shards get all started.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>Suppose that your read throughput decreased and you don’t need <code>node3</code> anymore. So, stop this node.</p>
</li>
<li>
<p>How many replica shards the <code>temp3</code> index has after you stopped <code>node3</code> ?</p>
<div class="openblock solution" id="solution59"><input id="question59" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer59" style="display: block;">
<div class="content">
<div class="paragraph">
<p>Run the following <code>_cat</code> command again to review <code>temp3</code> shard allocation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cat/shards/temp3?v&amp;h=index,shard,prirep,state,node&amp;s=index,shard,prirep</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should get a response similar to the one below, indicating that you have
one replica shard for each primary shard after you stopped <code>node3</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>index shard prirep state   node
temp3 0     p      STARTED node2
temp3 0     r      STARTED node1
temp3 1     p      STARTED node2
temp3 1     r      STARTED node1
temp3 2     p      STARTED node1
temp3 2     r      STARTED node2</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Read throughput increased back again! Restart <code>node3</code>  to scale
with replicas.
Run the <code>_cat</code> command from the previous step again to verify
that <code>temp3</code> has again two replica shards for every primary shard.</p>
</li>
<li>
<p>You are done with these tests, so it is a good idea to clean up the indices
you just created to run them.
Run the following command to delete <code>temp1</code> and <code>temp3</code> indices.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>DELETE temp*</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary</strong>: In this lab, you tested over allocation of shards.
You also explored how to scale for reads with replicas and some settings
to optimize write throughput during an initial load.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_3_3">End of Lab 3.3</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_4_1_cluster_backup">Lab 4.1: Cluster Backup</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective</strong>: In this lab, you will learn how to backup and restore your cluster.
<strong>This entire lab should be considered as preparation for the certification exam.</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>First, take a snapshot of your <code>blogs</code> and <code>logs_server*</code> indices.
To do that, stop Elasticsearch on all three of your servers, but leave the
terminal tabs open.
(This task will be easier if you are SSH’d onto each of your three servers in a
separate tab.)</p>
</li>
<li>
<p>Notice there is a single folder named <code>/shared_folder</code> that each server
can read/write to. Create a new subfolder of <code>/shared_folder/</code> called
<code>my_repo</code>. (You only need to run this command on one of the servers):</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>mkdir /shared_folder/my_repo</code></pre>
</div>
</div>
</li>
<li>
<p>Add the following <code>path.repo</code> property to the <code>elasticsearch.yml</code> files of
<code>node1</code>, <code>node2</code> and <code>node3</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>path.repo: /shared_folder/my_repo</code></pre>
</div>
</div>
</li>
<li>
<p>Start Elasticsearch on all three nodes.</p>
</li>
<li>
<p>Within the Kibana Console, register the <code>/shared_folder/my_repo</code>
directory as a repository called <code>my_local_repo</code>.</p>
<div class="openblock solution" id="solution60"><input id="question60" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer60" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT _snapshot/my_local_repo
{
  "type": "fs",
  "settings": {
    "location": "/shared_folder/my_repo"
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Now that you have a repository configured, your cluster is ready for
taking snapshots. Take a snapshot named <code>cluster_snapshot_1</code> of the
<code>logs_server*</code> indices, including the cluster state, and save the snapshot in
your new repository.</p>
<div class="openblock solution" id="solution61"><input id="question61" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer61" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT _snapshot/my_local_repo/cluster_snapshot_1
{
  "indices": "logs_server*",
  "ignore_unavailable": true,
  "include_global_state": true
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>View all of the snapshots in your repository. You should see
<code>cluster_snapshot_1</code> in the list.</p>
<div class="openblock solution" id="solution62"><input id="question62" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer62" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _snapshot/my_local_repo/_all</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Restore the <code>logs_server*</code> indices using your snapshot from the previous step.
Do not restore the cluster state (your current cluster state is fine). Rename
the indices as they get restored to <code>restored_logs_1</code>, <code>restored_logs_2</code> and
<code>restored_logs_3</code>.</p>
<div class="openblock solution" id="solution63"><input id="question63" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer63" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST _snapshot/my_local_repo/cluster_snapshot_1/_restore
{
  "indices": "logs_server*",
  "ignore_unavailable": true,
  "include_global_state": false,
  "rename_pattern": "logs_server(.+)",
  "rename_replacement": "restored_logs_$1"
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Verify that your <code>restored_logs_*</code> indices have been restored with all of
their documents. Check that the <code>restored_logs_*</code> indices have the same number
of documents as the original <code>logs_server*</code> indices, for example using the
<code>_cat</code> API:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cat/indices</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary</strong>: In this lab, you learned how to backup and restore indices.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_4_1">End of Lab 4.1</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_4_2_overview_of_upgrades_and_cluster_restart">Lab 4.2: Overview of Upgrades and Cluster Restart</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab, you will perform a rolling restart of your cluster.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Run the following in your Kibana <strong>Console</strong>. It will fail. Why?</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST _analyze
{
    "tokenizer": "icu_tokenizer",
    "text": ["星球 战是我最喜欢的电影"]
}</code></pre>
</div>
</div>
<div class="openblock solution" id="solution64"><input id="question64" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer64" style="display: block;">
<div class="content">
<div class="paragraph">
<p>It may not be obvious from the error message, but the <code>icu_tokenizer</code> is
in a plugin that is missing from your cluster. You need to install the
plugin and restart your cluster, which you will do in the next steps.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>On each of the nodes in your cluster, run the following command to
install the ICU Analysis plugin (do so from a new Strigo terminal,
ssh onto <code>server1</code>, <code>server2</code> and <code>server3</code> while your cluster is up and running):</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>./elasticsearch/bin/elasticsearch-plugin install analysis-icu</code></pre>
</div>
</div>
</li>
<li>
<p>Installing a plugin requires the cluster to be restarted. Perform a
rolling restart of your cluster by stopping and restarting <code>node1</code> first,
followed by the other two nodes, one-at-a-time.</p>
</li>
<li>
<p>Run the following command again. It should work this time!</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST _analyze
{
    "tokenizer": "icu_tokenizer",
    "text": ["星球 战是我最喜欢的电影"]
}</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary:</strong> In this lab, you performed a rolling restart of your cluster.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_4_2">End of Lab 4.2</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_4_3_topology_awareness">Lab 4.3: Topology Awareness</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab, you are going to configure shard allocation awareness along with forced awareness.
<strong>This entire lab should be considered as preparation for the certification exam.</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>You currently have 3 nodes running.
However, to better demonstrate shard awareness, you will add an extra
node (<code>node4</code>).
Suppose <code>node1</code> and <code>node3</code> are in <code>rack1</code> and that <code>node2</code> and <code>node4</code>
(newly added) are in <code>rack2</code>.
You are going to see what happens with shard allocation when you set this
configuration in your cluster and enable shard awareness.</p>
</li>
<li>
<p>Stop <code>node1</code> and <code>node3</code> and add the attribute <code>my_rack</code> set to <code>rack1</code> in
their configuration files.</p>
<div class="openblock solution" id="solution65"><input id="question65" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer65" style="display: block;">
<div class="content">
<div class="paragraph">
<p>The <code>elasticsearch.yml</code> configuration file from <code>server1</code> and <code>server3</code> should
look like as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>cluster.name: my_cluster
node.name: ${NODENAME}
network.host: _site_
discovery.seed_hosts: ["server1", "server2", "server3"]
path.repo: /shared_folder/my_repo
node.attr.my_rack: rack1</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Start <code>node1</code> and <code>node3</code> again.</p>
<div class="openblock solution" id="solution66"><input id="question66" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer66" style="display: block;">
<div class="content">
<div class="paragraph">
<p>On <code>server1</code> and <code>server3</code> do the following:</p>
</div>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>./elasticsearch/bin/elasticsearch</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Stop <code>node2</code> and add the attribute <code>my_rack</code> set to <code>rack2</code> in its
configuration file.</p>
<div class="openblock solution" id="solution67"><input id="question67" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer67" style="display: block;">
<div class="content">
<div class="paragraph">
<p>The <code>elasticsearch.yml</code> configuration file from <code>server2</code> should look like as
follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>cluster.name: my_cluster
node.name: ${NODENAME}
network.host: _site_
discovery.seed_hosts: ["server1", "server2", "server3"]
path.repo: /shared_folder/my_repo
node.attr.my_rack: rack2</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Start <code>node2</code> again.</p>
<div class="openblock solution" id="solution68"><input id="question68" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer68" style="display: block;">
<div class="content">
<div class="paragraph">
<p>On <code>server2</code> do the following:</p>
</div>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>./elasticsearch/bin/elasticsearch</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>In a new terminal tab, ssh to <code>server4</code> and edit the configuration file so
it has the same configuration as <code>server2</code>, plus <code>node.master</code> set to <code>false</code>.</p>
<div class="openblock solution" id="solution69"><input id="question69" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer69" style="display: block;">
<div class="content">
<div class="paragraph">
<p>Click the <code>+</code> button to open a new terminal and then type:</p>
</div>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>ssh server4</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, edit the <code>elasticsearch.yml</code> configuration file so it looks like as
follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>cluster.name: my_cluster
node.name: ${NODENAME}
network.host: _site_
discovery.seed_hosts: ["server1", "server2", "server3"]
path.repo: /shared_folder/my_repo
node.attr.my_rack: rack2
node.master: false</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Start <code>node4</code>.</p>
<div class="openblock solution" id="solution70"><input id="question70" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer70" style="display: none;">
<div class="content">
<div class="paragraph">
<p>On <code>server4</code> do the following:</p>
</div>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>./elasticsearch/bin/elasticsearch</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Verify your nodes are running and configured properly by running both of the
following cat commands in your Kibana console:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cat/nodes?v&amp;s=name
GET _cat/nodeattrs?v&amp;s=name</code></pre>
</div>
</div>
</li>
<li>
<p>Verify the shard allocation with the following command. Are there copies of
the same shard (both primary and replica shard) allocated to the same rack?</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cat/shards?h=index,shard,prirep,node&amp;s=index,prirep</code></pre>
</div>
</div>
<div class="openblock solution" id="solution71"><input id="question71" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer71" style="display: block;">
<div class="content">
<div class="paragraph">
<p>The answer depends on your cluster allocation, which is not always the same.
Verify index by index if primary and replica are allocated in the same rack.
For example, in the response below <code>logs_server3</code> has both shard copies
allocated to <code>rack1</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>logs_server3         0 p node1
logs_server3         0 r node3</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Use <code>transient</code> settings to configure your cluster so that it uses your
<code>my_rack</code> attribute to implement shard allocation awareness.</p>
<div class="openblock solution" id="solution72"><input id="question72" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer72" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT _cluster/settings
{
  "transient": {
    "cluster": {
      "routing": {
        "allocation.awareness.attributes": "my_rack"
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Run the following <code>cat</code> command and view your shard allocation carefully:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cat/shards?h=index,shard,prirep,node&amp;s=index,prirep</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, copies of the same shard should be on different racks.
Following the <code>logs_server3</code> example above, you should see shards that are
being relocated like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>logs_server3         0 p node1 -&gt; 172.18.0.5 dOKFSlHqTR2C6_sCY8OGyw node4</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, the primary shard <code>0</code> is being relocated from <code>node1</code> to <code>node4</code>.</p>
</div>
</li>
<li>
<p>You currently have 4 nodes running and just saw how shard awareness works. Now we want you to understand forced awareness. Stop <code>node2</code> and <code>node4</code> which are on <code>rack2</code>.</p>
</li>
<li>
<p>Run the following cat command in your Kibana console to see all shards being allocated to <code>rack1</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cat/shards?h=index,shard,prirep,node&amp;s=index,prirep</code></pre>
</div>
</div>
<div class="paragraph">
<p>This may take a minute or two so be sure to run the command until you see the desired results.</p>
</div>
</li>
<li>
<p>Once you see all shards allocated to <code>rack1</code> go back to the terminal and startup <code>node2</code> and <code>node4</code>.</p>
</li>
<li>
<p>To avoid overloading your nodes with all of the newly allocated replicas, you will
need to configure forced awareness for <code>my_rack</code>. Use the <code>persistent</code> settings to configure your cluster so that is uses your <code>my_rack</code> attribute to implement the forced awareness for the two zones you want to balance. In this case, <code>rack1</code> and <code>rack2</code>.</p>
<div class="openblock solution" id="solution73"><input id="question73" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer73" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT _cluster/settings
{
  "persistent": {
    "cluster": {
      "routing": {
        "allocation.awareness.attributes": "my_rack",
        "allocation.awareness.force.my_rack.values": "rack1,rack2"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Elasticsearch will now put exactly 1 copy of the shards in any zone that is available and listed in the forced awareness parameter.&nbsp;</p>
</div>
</div>
</div></div>
</li>
<li>
<p>To test the forced awareness configuration, bring down <code>rack2</code> by stopping <code>node2</code> and <code>node4</code>. Wait a minute and run the following command in your Kibana console:</p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cat/shards?h=index,shard,prirep,node&amp;s=index,prirep</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should now see only primary shards allocated to <code>rack1</code> (<code>node1</code> and <code>node3</code>).</p>
</div>
</div>
</div>
</li>
<li>
<p>Start back up <code>rack2</code> (<code>node2</code> and <code>node4</code>).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary:</strong> In this lab, you configured shard allocation and forced awareness.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_4_3">End of Lab 4.3</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_4_4_multi_cluster_setups">Lab 4.4: Multi Cluster Setups</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab, you will configure and test cross cluster search
as well as cross cluster replication. <strong>This entire lab should be considered as preparation for the certification exam.</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>First, you are going to implement cross cluster search by configuring
the <code>server6</code> node to be in a different cluster.</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>ssh server6</code></pre>
</div>
</div>
</li>
<li>
<p>Modify the <code>elasticsearch.yml</code> in <code>server6</code> to look like the following.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>cluster.name: my_cluster_2
node.name: ${NODENAME}
network.host: _site_
discovery.seed_hosts: ["server6"]
cluster.initial_master_nodes: ["node6"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Save your changes and startup Elasticsearch on <code>server6</code>.</p>
</div>
</li>
<li>
<p>Use the Kibana Console to create a <code>comments</code> index with the following mappings
in your original cluster, <code>my_cluster</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT comments
{
  "mappings" : {
    "properties" : {
      "comment" : {
        "type" : "text",
        "fields" : {
          "keyword" : {
            "type" : "keyword",
            "ignore_above" : 256
          }
        }
      },
      "movie" : {
        "type" : "text",
        "fields" : {
          "keyword" : {
            "type" : "keyword",
            "ignore_above" : 256
          }
        }
      },
      "rating" : {
        "type" : "long"
      },
      "username" : {
        "type" : "text",
        "fields" : {
          "keyword" : {
            "type" : "keyword",
            "ignore_above" : 256
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</li>
<li>
<p>Run the following commands to index two documents into your current cluster.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT comments/_doc/7
{"username": "ricardo", "movie": "Star Trek IV: The Voyage Home","comment": "Loved it!", "rating": 5}

PUT comments/_doc/8
{"username": "sara", "movie": "Wonder Woman","comment": "Finally a good DC Comics movie", "rating": 4}</code></pre>
</div>
</div>
</li>
<li>
<p>Now, in a terminal from any of the servers, run the following curl
commands to index some documents into your new cluster on <code>node6</code>. Notice
the index is named <code>comments</code> on both clusters.</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>curl -XPUT "http://server6:9200/comments/_doc/1?pretty" -H "Content-Type: application/json" -i -d '
{"username": "paolo", "movie": "Star Trek IV: The Voyage Home","comment": "Not my favorite star trek movie :(", "rating": 2}'

curl -XPUT "http://server6:9200/comments/_doc/2?pretty" -H "Content-Type: application/json" -i -d '
{"username": "harrison", "movie": "Blade Runner","comment": "I hope they do not remake this classic movie", "rating": 4}'</code></pre>
</div>
</div>
</li>
<li>
<p>Configure <code>my_cluster</code> so that it can run cross cluster searches onto
<code>my_cluster_2</code>.</p>
<div class="openblock solution" id="solution74"><input id="question74" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer74" style="display: block;">
<div class="content">
<div class="paragraph">
<p>Run the following command on <code>my_cluster</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT _cluster/settings
{
  "persistent": {
    "cluster.remote" : {
      "my_cluster_2" : {
        "seeds" : ["server6:9300"]
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Run a search on <code>my_cluster</code> that hits all documents in both <code>comments</code>
indices (the <code>comments</code> index on <code>my_cluster</code> <em>and</em> the <code>comments</code> index on
<code>my_cluster_2</code>). You should get 4 hits.</p>
<div class="openblock solution" id="solution75"><input id="question75" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer75" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET my_cluster_2:comments,comments/_search</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Next, you are going to implement cross cluster replication. First, start a trial
license on <code>my_cluster</code>.</p>
<div class="openblock solution" id="solution76"><input id="question76" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer76" style="display: block;">
<div class="content">
<div class="paragraph">
<p>Access Kibana in your current cluster, click on Management, License Management, and
Start Trial.
<span class="image"><img src="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/images/ccr-start-trial.png" alt="ccr start trial"></span></p>
</div>
</div>
</div></div>
</li>
<li>
<p>Now, use the following <code>curl</code> command to start a trial license
on <code>my_cluster_2</code>.</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>curl -X POST "http://server6:9200/_license/start_trial?acknowledge=true"</code></pre>
</div>
</div>
</li>
<li>
<p>Create a leader index called <code>my_replicated_blogs</code> in <code>my_cluster</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT my_replicated_blogs
{
  "settings": {
    "index": {
      "number_of_shards": 1,
      "number_of_replicas": 0,
      "soft_deletes": {
        "enabled": true
      }
    }
  },
  "mappings" : {
    "properties" : {
      "author" : {
        "type" : "text",
        "fields" : {
          "keyword" : {
            "type" : "keyword",
            "ignore_above" : 256
          }
        }
      },
      "category" : {
        "type" : "text",
        "fields" : {
          "keyword" : {
            "type" : "keyword",
            "ignore_above" : 256
          }
        }
      },
      "content" : {
        "type" : "text",
        "fields" : {
          "keyword" : {
            "type" : "keyword",
            "ignore_above" : 256
          }
        }
      },
      "locales" : {
        "type" : "text",
        "fields" : {
          "keyword" : {
            "type" : "keyword",
            "ignore_above" : 256
          }
        }
      },
      "publish_date" : {
        "type" : "date"
      },
      "seo_title" : {
        "type" : "text",
        "fields" : {
          "keyword" : {
            "type" : "keyword",
            "ignore_above" : 256
          }
        }
      },
      "some_other_field" : {
        "type" : "text"
      },
      "title" : {
        "type" : "text",
        "fields" : {
          "keyword" : {
            "type" : "keyword",
            "ignore_above" : 256
          }
        }
      },
      "url" : {
        "type" : "text",
        "fields" : {
          "keyword" : {
            "type" : "keyword",
            "ignore_above" : 256
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</li>
<li>
<p>Use <code>curl</code> to connect <code>my_cluster_2</code> to <code>my_cluster</code>, so it can pull changes
to <code>my_replicated_blogs</code> and implement cross cluster replication.</p>
<div class="openblock solution" id="solution77"><input id="question77" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer77" style="display: block;">
<div class="content">
<div class="paragraph">
<p>Run the following command from any terminal:</p>
</div>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>curl -X PUT "http://server6:9200/_cluster/settings" -H "Content-Type: application/json" -i -d '{ "persistent": { "cluster.remote" : { "my_cluster" : { "seeds" : ["server1:9300", "server2:9300", "server3:9300"] } } } }'</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Use <code>curl</code> to create a follower index called <code>my_replicated_blogs</code>,
which references to <code>my_cluster</code> and its leader index <code>my_replicated_blogs</code>.</p>
<div class="openblock solution" id="solution78"><input id="question78" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer78" style="display: block;">
<div class="content">
<div class="paragraph">
<p>Run the following command from any terminal:</p>
</div>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>curl -X PUT "http://server6:9200/my_replicated_blogs/_ccr/follow" -H "Content-Type: application/json" -i -d '{ "remote_cluster" : "my_cluster", "leader_index" : "my_replicated_blogs" }'</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Run the following <code>curl</code> command and check that there are no blogs yet.
Why?</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>curl -X GET "http://server6:9200/my_replicated_blogs/_count"</code></pre>
</div>
</div>
<div class="openblock solution" id="solution79"><input id="question79" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer79" style="display: block;">
<div class="content">
<div class="paragraph">
<p>There are no blogs yet because you just created the index and there are still
no blogs neither in the remote cluster nor in the local cluster.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>Reindex the blogs from <code>blogs</code> index into <code>my_replicated_blogs</code> index
in <code>my_cluster</code>.</p>
<div class="openblock solution" id="solution80"><input id="question80" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer80" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST _reindex?wait_for_completion=false
{
  "source": {
    "index": "blogs"
  },
  "dest": {
    "index": "my_replicated_blogs"
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Run the same <code>curl</code> command again and you should see now that the <code>1594</code>
have been replicated from <code>my_cluster</code> into <code>my_cluster_2</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary:</strong> In this lab, you implemented and tested cross cluster search
as well as cross cluster replication.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_4_4">End of Lab 4.4</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_5_1_controlling_shard_allocation">Lab 5.1: Controlling Shard Allocation</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab, you will configure a 5-node cluster and implement a hot/warm architecture with
shard filtering. <strong>This entire lab should be considered as preparation for the certification exam.</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>You currently have a 4-node cluster running on <code>server1</code>, <code>server2</code>,
<code>server3</code>, and <code>server4</code>.
You are going to deploy a 5-node cluster by adding one extra node on <code>server5</code>.
You are also going to set some dedicated nodes during this new setup.</p>
</li>
<li>
<p>Stop all four instances of Elasticsearch, but stay SSH’d onto each
server.</p>
</li>
<li>
<p>Open a new tab and SSH onto <code>server5</code>.</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>ssh server5</code></pre>
</div>
</div>
</li>
<li>
<p>Now, you are going to implement a hot/warm architecture in your 5-node cluster.</p>
</li>
<li>
<p>Configure your five nodes so that they include the dedicated <code>roles</code> and <code>my_temp</code> tag names as
described in the following table.</p>
<table class="tableblock frame-all grid-all fit-content labTable">
<colgroup>
<col>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Server</th>
<th class="tableblock halign-left valign-top">Roles</th>
<th class="tableblock halign-left valign-top">my_rack</th>
<th class="tableblock halign-left valign-top">my_temp</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">node1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">server1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">data, ingest and master-eligible</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">rack1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">hot</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">node2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">server2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">data, ingest and master-eligible</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">rack2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">hot</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">node3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">server3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">dedicated data</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">rack1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">warm</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">node4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">server4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">dedicated data</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">rack2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">warm</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">node5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">server5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">dedicated master-eligible voting-only</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">none</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">none</p></td>
</tr>
</tbody>
</table>
<div class="openblock solution" id="solution81"><input id="question81" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer81" style="display: block;">
<div class="content">
<div class="paragraph">
<p>Config file for each one of the five nodes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>#node1 config
cluster.name: my_cluster
node.name: ${NODENAME}
network.host: _site_
discovery.seed_hosts: ["server1", "server2", "server3"]
path.repo: /shared_folder/my_repo
node.attr.my_rack: rack1
node.master: true
node.data: true
node.ingest: true
node.ml: false
node.attr.my_temp: hot

#node2 config
cluster.name: my_cluster
node.name: ${NODENAME}
network.host: _site_
discovery.seed_hosts: ["server1", "server2", "server3"]
path.repo: /shared_folder/my_repo
node.attr.my_rack: rack2
node.master: true
node.data: true
node.ingest: true
node.ml: false
node.attr.my_temp: hot

#node3 config
cluster.name: my_cluster
node.name: ${NODENAME}
network.host: _site_
discovery.seed_hosts: ["server1", "server2", "server3"]
path.repo: /shared_folder/my_repo
node.attr.my_rack: rack1
node.master: false
node.data: true
node.ingest: false
node.ml: false
node.attr.my_temp: warm

#node4 config
cluster.name: my_cluster
node.name: ${NODENAME}
network.host: _site_
discovery.seed_hosts: ["server1", "server2", "server3"]
path.repo: /shared_folder/my_repo
node.attr.my_rack: rack2
node.master: false
node.data: true
node.ingest: false
node.ml: false
node.attr.my_temp: warm

#node5 config
cluster.name: my_cluster
node.name: ${NODENAME}
network.host: _site_
discovery.seed_hosts: ["server1", "server2", "server3"]
path.repo: /shared_folder/my_repo
node.master: true
node.voting_only: true
node.data: false
node.ingest: false
node.ml: false</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Start all nodes and verify they are running and configured properly by running
both of the following <code>_cat</code> commands in your Kibana console:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cat/nodes?v&amp;s=name
GET _cat/nodeattrs?v&amp;s=name</code></pre>
</div>
</div>
</li>
<li>
<p>Define a new index named <code>logs_server4</code>, if you haven’t already.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT logs_server4</code></pre>
</div>
</div>
</li>
<li>
<p>Configure the <code>logs_server1</code>, <code>logs_server2</code>, and <code>logs_server3</code> indices so
that their shards are allocated only to warm nodes, and configure <code>logs_server4</code>
to be allocated only to hot nodes.</p>
<div class="openblock solution" id="solution82"><input id="question82" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer82" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT logs_server1/_settings
{
  "index.routing.allocation.require.my_temp": "warm"
}

PUT logs_server2/_settings
{
  "index.routing.allocation.require.my_temp": "warm"
}

PUT logs_server3/_settings
{
  "index.routing.allocation.require.my_temp": "warm"
}

PUT logs_server4/_settings
{
  "index.routing.allocation.require.my_temp": "hot"
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Verify your shard filtering is working correctly by running the
following <code>_cat</code> command:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cat/shards/logs_server*?v&amp;h=index,shard,prirep,state,node&amp;s=index,shard,prirep</code></pre>
</div>
</div>
<div class="paragraph">
<p>The shards from <code>logs_server1</code>, <code>logs_server2</code>, <code>logs_server3</code> should be
allocated in <code>warm</code> nodes, while the shards from <code>logs_server4</code> should be
allocated in <code>hot</code> nodes.
You should see a shard allocation similar to the one below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>index        shard prirep state   node
logs_server1 0     p      STARTED node4
logs_server1 0     r      STARTED node3
logs_server2 0     p      STARTED node4
logs_server2 0     r      STARTED node3
logs_server3 0     p      STARTED node3
logs_server3 0     r      STARTED node4
logs_server4 0     p      STARTED node2
logs_server4 0     r      STARTED node1</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary:</strong> In this lab, you configured a 5-node cluster and implemented a hot/warm architecture with
shard filtering.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_5_1">End of Lab 5.1</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_5_2_index_management">Lab 5.2: Index Management</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab, you will learn how to rollover an alias to a new
index when the existing index meets a condition you provide.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create a new index named <code>logs-000001</code> that meets the following criteria:</p>
<div class="ulist">
<ul>
<li>
<p>it has 4 primary shards and 1 replica shard;</p>
</li>
<li>
<p>it uses shard filtering to allocate shards to <code>hot</code> nodes;</p>
</li>
<li>
<p>it has an alias named <code>logs</code> with <code>is_write_index</code> set to <code>true</code>.</p>
</li>
</ul>
</div>
<div class="openblock solution" id="solution83"><input id="question83" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer83" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT logs-000001
{
  "settings": {
    "number_of_shards": 4,
    "number_of_replicas": 1,
    "routing": {
      "allocation": {
        "require": {
          "my_temp": "hot"
        }
      }
    }
  },
  "aliases": {
    "logs": {
      "is_write_index": true
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Run the following <code>_bulk</code> command, which indexes a few simple log
documents into the <code>logs</code> alias:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST logs/_bulk
{ "index" : { "_id" : "1"}}
{ "level" : "INFO", "message" : "recovered [20] indices into cluster_state", "date" : "2018-07-04"}
{ "index" : { "_id" : "2"}}
{ "level" : "WARN", "message" : "received shard failed for shard id 0", "date" : "2018-07-04"}
{ "index" : { "_id" : "3"}}
{ "level" : "INFO", "message" : "Cluster health status changed from [YELLOW] to [GREEN]", "date" : "2018-07-04"}</code></pre>
</div>
</div>
</li>
<li>
<p>Run the following query to view the three documents.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs/_search</code></pre>
</div>
</div>
</li>
<li>
<p>Use the following conditions to rollover <code>logs</code> into a new index:</p>
<div class="ulist">
<ul>
<li>
<p>the maximum age of the index is one day;</p>
</li>
<li>
<p>the maximum number of documents the index should contain is two;</p>
</li>
<li>
<p>the maximum estimated sized of the primary shard of the index is 1 gigabyte.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Like the old index, the new one should also have 4 primary shards and 1 replica
shard and use shard filtering to allocate shards to <code>hot</code> nodes.</p>
</div>
<div class="openblock solution" id="solution84"><input id="question84" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer84" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST logs/_rollover
{
  "conditions": {
    "max_age": "1d",
    "max_docs": 2,
    "max_size": "1gb"
  },
  "settings": {
    "number_of_shards": 4,
    "number_of_replicas": 1,
    "routing": {
      "allocation": {
        "require": {
          "my_temp": "hot"
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Notice that PUT, POST &amp; DELETE requests for indexing logs do not need to know
the name of the index that you are indexing to. You can simply index
new log events to <code>logs</code> because of the clever use of aliases. Run
the following bulk command, which indexes a couple of log events into the
new index:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST logs/_bulk
{ "index" : { "_id" : "4"}}
{ "level" : "INFO", "message" : "[node2] started", "date" : "2018-07-05"}
{ "index" : { "_id" : "5"}}
{ "level" : "WARN", "message" : "not enough master nodes discovered during pinging", "date" : "2018-07-05"}</code></pre>
</div>
</div>
</li>
<li>
<p>Run the following query to verify that the two log events
ended up in the correct index. You should get 2 hits (the two docs you
just indexed):</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs-000002/_search</code></pre>
</div>
</div>
</li>
<li>
<p>Notice that searching <code>logs</code> retrieves all 5 log events:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs/_search</code></pre>
</div>
</div>
</li>
<li>
<p>Here is an interesting note about aliases. What do you
think happens if you delete the <code>logs</code> alias, which currently points
to two indices? Run the following command and see what happens:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>DELETE logs</code></pre>
</div>
</div>
<div class="openblock solution" id="solution85"><input id="question85" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer85" style="display: block;">
<div class="content">
<div class="paragraph">
<p>Starting with Elasticsearch version 6 the command fails.
In earlier versions of Elasticsearch the command deletes all the
indices the alias is associated with. Be careful, the above command is
not the correct command to remove an alias.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>Prepare <code>logs-000001</code> for shrinking by making it read-only and allocating
all the shards to <code>warm</code> nodes.</p>
<div class="openblock solution" id="solution86"><input id="question86" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer86" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT logs-000001/_settings
{
  "routing": {
    "allocation": {
      "require": {
        "my_temp": "warm"
      }
    }
  },
  "blocks.write": true
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Shrink <code>logs-000001</code> into <code>shrink-logs-000001</code> with a single primary shard.</p>
<div class="openblock solution" id="solution87"><input id="question87" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer87" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST logs-000001/_shrink/shrink-logs-000001
{
  "settings": {
    "index.number_of_shards": 1,
    "codec": "best_compression"
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Suppose you are done writing into <code>shrink-logs-000001</code>, so force merge all
of its segments into a single segment.</p>
<div class="openblock solution" id="solution88"><input id="question88" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer88" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST shrink-logs-000001/_forcemerge?max_num_segments=1</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>In a single request, remove the alias <code>logs</code> from <code>logs-000001</code> and
instead assign <code>logs</code> to <code>shrink-logs-000001</code>.</p>
<div class="openblock solution" id="solution89"><input id="question89" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer89" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST _aliases
{
  "actions": [
    {
      "remove": {
        "index": "logs-000001",
        "alias": "logs"
      }
    },
    {
      "add": {
        "index": "shrink-logs-000001",
        "alias": "logs"
      }
    }
  ]
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Delete <code>logs-000001</code>. Yes, it is fine deleting <code>logs-000001</code> since now you
are going to use <code>shrink-logs-000001</code> instead.</p>
<div class="openblock solution" id="solution90"><input id="question90" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer90" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>DELETE logs-000001</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Notice that searching <code>logs</code> still retrieves all 5 log events:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs/_search</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary:</strong> In this lab, you learned how to rollover an alias to a new
index when the existing index meets a condition you provided.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_5_2">End of Lab 5.2</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_5_3_index_lifecycle_management">Lab 5.3: Index Lifecycle Management</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab, you will explore how to setup index lifecycle
management.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>You are going to use ILM to automatically implement the same hot/warm
architecture you implemented in the previous lab along with rollover.
First, use Kibana to define an index lifecycle policy named
<code>logs-hot-warm-policy</code> that implements the following hot and warm phases:</p>
<div class="ulist">
<ul>
<li>
<p><strong>hot phase</strong></p>
<div class="ulist">
<ul>
<li>
<p>it enables rollover;</p>
</li>
<li>
<p>its maximum index size is 1 gigabyte;</p>
</li>
<li>
<p>its maximum documents is 2;</p>
</li>
<li>
<p>its maximum age is 1 day.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>warm phase</strong></p>
<div class="ulist">
<ul>
<li>
<p>it uses <code>my_temp</code> node attributes to move shards into warm phase on rollover;</p>
</li>
<li>
<p>it shrinks the index into a new index with a single primary shard;</p>
</li>
<li>
<p>it reduces the number of segments to 1.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="openblock solution" id="solution91"><input id="question91" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer91" style="display: block;">
<div class="content">
<div class="paragraph">
<p>First, click on <strong>Management</strong> on the left-hand menu, access the <strong>Index Lifecycle Policies</strong>
section and click on <strong>Create policy</strong>.
<span class="image"><img src="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/images/ilm1.png" alt="ilm1"></span>
Then, name your index lifecycle policy <code>logs-hot-warm-policy</code>.
<span class="image"><img src="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/images/ilm2.png" alt="ilm2"></span>
Next, configure the hot phase to enable rollover and set maximum index size to 1,
maximum documents to 2, and maximum age to 1 day.
<span class="image"><img src="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/images/ilm3.png" alt="ilm3"></span>
After that, enable the warm phase, select <code>my_temp:warm</code> node attribute to
control shard allocation, enable shrink index and set the number of primary
shards to 1, plus enable force merge and set the number of segments to 1.
<span class="image"><img src="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/images/ilm4.png" alt="ilm4"></span>
Finally, in this exercise you don’t need cold and delete phases for simplicity,
so just click on <strong>Save as new policy</strong>.
<span class="image"><img src="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/images/ilm5.png" alt="ilm5"></span></p>
</div>
</div>
</div></div>
</li>
<li>
<p>To apply this policy to all future log indexes that are going to be created,
define an index template named <code>logs-template</code> that uses your
<code>logs-hot-warm-policy</code> and also applies the following settings to new indices
that match the pattern <code>logs-*</code>:</p>
<div class="ulist">
<ul>
<li>
<p>the number of primary shards is 4;</p>
</li>
<li>
<p>the number of replica shards is 1;</p>
</li>
<li>
<p>shards are allocated into <code>hot</code> nodes;</p>
</li>
<li>
<p>the rollover alias is <code>logs</code>;</p>
</li>
</ul>
</div>
<div class="openblock solution" id="solution92"><input id="question92" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer92" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT _template/logs-template
{
  "index_patterns": ["logs-*"],
  "settings": {
    "number_of_shards": 4,
    "number_of_replicas": 1,
    "routing": {
      "allocation": {
        "require": {
          "my_temp": "hot"
        }
      }
    },
    "index.lifecycle.name": "logs-hot-warm-policy",
    "index.lifecycle.rollover_alias": "logs"
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>You also need to apply the policy to the existing <code>logs-000002</code> index. You can again use Kibana for that.
First, click on <strong>Management</strong> on the left-hand menu and this time select <strong>Index Management</strong>.
<span class="image"><img src="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/images/ilm6.png" alt="ilm6"></span>
Check the box of the <code>logs-000002</code> index, click the <strong>Manage index</strong> button, and select <strong>Add lifecycle policy</strong>.
<span class="image"><img src="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/images/ilm7.png" alt="ilm7"></span>
Select the <code>logs-hot-warm-policy</code> Lifecycle policy and the <code>logs</code> Index rollover alias.
Finally, click the <strong>Add policy</strong> button.
<span class="image"><img src="http://ec2-3-127-64-149.eu-central-1.compute.amazonaws.com/instructions/images/ilm8.png" alt="ilm8"></span></p>
</li>
<li>
<p>Use the following command to check the lifecycle state of <code>logs</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs/_ilm/explain</code></pre>
</div>
</div>
<div class="paragraph">
<p>You will get a response similar to the one below.
Note that <code>logs</code> is still aliasing <code>logs-000002</code>, though the index
already have matched the <code>max_docs</code> condition to rollover.
This is happening because the conditions are checked periodically and the
default lifecycle poll interval is ten minutes.
So the index might grow slightly beyond the specified threshold until the
conditions are checked again.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{
  "indices" : {
    "shrink-logs-000001" : {
      "index" : "shrink-logs-000001",
      "managed" : false
    },
    "logs-000002" : {
      "index" : "logs-000002",
      "managed" : true,
      "policy" : "logs-hot-warm-policy",
      "lifecycle_date_millis" : 1580486859628,
      "phase" : "hot",
      "phase_time_millis" : 1580492899136,
      "action" : "unfollow",
      "action_time_millis" : 1580492899232,
      "step" : "wait-for-follow-shard-tasks",
      "step_time_millis" : 1580492899265,
      "phase_execution" : {
        "policy" : "logs-hot-warm-policy",
        "phase_definition" : {
          "min_age" : "0ms",
          "actions" : {
            "rollover" : {
              "max_size" : "1gb",
              "max_age" : "1d",
              "max_docs" : 2
            },
            "set_priority" : {
              "priority" : 100
            }
          }
        },
        "version" : 1,
        "modified_date_in_millis" : 1580492736342
      }
    }
  }
}</code></pre>
</div>
</div>
</li>
<li>
<p>Ten minutes is a long wait for this lab, so use transient settings to change
the lifecycle poll interval to five seconds as follows:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT _cluster/settings
{
    "transient": {
      "indices.lifecycle.poll_interval": "5s"
    }
}</code></pre>
</div>
</div>
</li>
<li>
<p>Check the lifecycle state of <code>logs</code> again. What happened?</p>
<div class="openblock solution" id="solution93"><input id="question93" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer93" style="display: none;">
<div class="content">
<div class="paragraph">
<p>Run the following command after five seconds and you should get a response
similar to the one below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs/_ilm/explain</code></pre>
</div>
</div>
<div class="paragraph">
<p>The response means that after five seconds ILM verified that <code>logs-000002</code>
matched the <code>max_docs</code> criteria, so it rolled <code>logs</code> over into
<code>logs-000003</code>.
Also note that <code>logs-000003</code> is on <code>hot</code> phase with 4 primary shards and
1 replica shard, while <code>logs-000002</code> have moved to <code>warm</code> phase with
1 primary shard and 1 replica shard.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{
  "indices" : {
    "shrink-logs-000001" : {
      "index" : "shrink-logs-000001",
      "managed" : false
    },
    "logs-000003" : {
      "index" : "logs-000003",
      "managed" : true,
      "policy" : "logs-hot-warm-policy",
      "lifecycle_date_millis" : 1580493148436,
      "phase" : "hot",
      "phase_time_millis" : 1580493148832,
      "action" : "rollover",
      "action_time_millis" : 1580493153853,
      "step" : "check-rollover-ready",
      "step_time_millis" : 1580493153853,
      "phase_execution" : {
        "policy" : "logs-hot-warm-policy",
        "phase_definition" : {
          "min_age" : "0ms",
          "actions" : {
            "rollover" : {
              "max_size" : "1gb",
              "max_age" : "1d",
              "max_docs" : 2
            },
            "set_priority" : {
              "priority" : 100
            }
          }
        },
        "version" : 1,
        "modified_date_in_millis" : 1580492736342
      }
    },
    "shrink-logs-000002" : {
      "index" : "shrink-logs-000002",
      "managed" : true,
      "policy" : "logs-hot-warm-policy",
      "lifecycle_date_millis" : 1580493148613,
      "phase" : "completed",
      "phase_time_millis" : 1580493163397,
      "action" : "completed",
      "action_time_millis" : 1580493163397,
      "step" : "completed",
      "step_time_millis" : 1580493163397,
      "phase_execution" : {
        "policy" : "logs-hot-warm-policy",
        "version" : 1,
        "modified_date_in_millis" : 1580492736342
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Now, run the following <code>PUT</code> command and notice <code>logs</code> inserts the
new log event in the new index:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT logs/_doc/6
{
  "level": "INFO",
  "message": "[node3] started",
  "date": "2018-07-06"
}</code></pre>
</div>
</div>
</li>
<li>
<p>Notice that searching <code>logs</code> retrieves all 6 log events because you
configured <code>logs-template</code> to also include an alias to the new index,
and ILM also updates the aliases from old indices to new shrunken indices:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs/_search</code></pre>
</div>
</div>
</li>
<li>
<p>Finally, run the following <code>cat</code> command a view your shard allocation
carefully:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cat/shards/*logs-*?v&amp;h=index,shard,prirep,state,node&amp;s=index,shard,prirep</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that <code>hot</code> data is stored in either <code>node1</code> or <code>node2</code>, while
<code>warm</code> data is stored in either <code>node3</code> or <code>node4</code>.
This means that you successfully set your ILM with hot/warm architecture.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>index              shard prirep state   node
logs-000003        0     p      STARTED node1
logs-000003        0     r      STARTED node2
logs-000003        1     p      STARTED node2
logs-000003        1     r      STARTED node1
logs-000003        2     p      STARTED node1
logs-000003        2     r      STARTED node2
logs-000003        3     p      STARTED node2
logs-000003        3     r      STARTED node1
shrink-logs-000001 0     p      STARTED node3
shrink-logs-000001 0     r      STARTED node4
shrink-logs-000002 0     p      STARTED node3
shrink-logs-000002 0     r      STARTED node4</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary:</strong> In this lab, you explored how to setup index lifecycle management.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_5_3">End of Lab 5.3</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_6_1_challenges_of_distributed_operations">Lab 6.1: Challenges of Distributed Operations</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab, you will familiarize yourself with
<code>dfs_query_then_fetch</code> search type, deep pagination with <code>search_after</code>,
and how to check the precision of aggregations.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Elasticsearch uses shards to distribute data and scale. However, this
creates inaccuracy to the score calculation. Even though in many cases
this is not an issue, in some cases it might be. Run the following query
and pay attention to the score.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_server*/_search
{
  "_source": "originalUrl",
  "query": {
    "match": {
      "originalUrl": "search"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that variances occur in the scores for the hits related to
<code>/blog/guide/reference/api/search/search-type</code>, though all of them
refer to the same <code>originalUrl</code>.</p>
</div>
</li>
<li>
<p>Now, run the same query with the <code>dfs_query_then_fetch</code> search type and
pay attention to the score. Do you see any differences in the score?
Why?</p>
<div class="openblock solution" id="solution94"><input id="question94" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer94" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_server*/_search?search_type=dfs_query_then_fetch
{
  "_source": "originalUrl",
  "query": {
    "match": {
      "originalUrl": "search"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>With <code>dfs_query_then_fetch</code>, the score is the same for all hits that have
the same <code>originalUrl</code> (5.436115). This happens because
Elasticsearch is calculating the document frequency globally, instead of
at the shard level.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>Suppose that you want to implement deep pagination with <code>search_after</code>.
Test how to implement it against the <code>blogs</code> index by getting the first 3 documents from a
<code>match_phrase</code> query for "<strong>elastic stack</strong>" on the <code>content</code> field,
and then use the result of first page’s last hit for getting the second page,
which is the next set of 3 documents.</p>
<div class="openblock solution" id="solution95"><input id="question95" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer95" style="display: none;">
<div class="content">
<div class="paragraph">
<p>First, use the following query to get the first page:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "size": 3,
  "query": {
    "match_phrase": {
      "content": "elastic stack"
    }
  },
  "sort": [
    {
      "_score": {
        "order": "desc"
      }
    },
    {
      "_id": {
        "order": "asc"
      }
    }
  ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, use the <code>search_after</code> parameter along with the <code>_score</code> and <code>_id</code> that
you get after running the previous query to get the second page:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "size": 3,
  "query": {
    "match_phrase": {
      "content": "elastic stack"
    }
  },
  "sort": [
    {
      "_score": {
        "order": "desc"
      }
    },
    {
      "_id": {
        "order": "asc"
      }
    }
  ],
  "search_after": [
    4.211448,
    "4cKJQWsB0m24JgDcy7OD"
    ]
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>The aggregation below returns how many requests were received from
each of the 6 values of <code>status_code</code> for each week of log requests.
We need to be sure that it is delivering a suitable level of accuracy, so
enable <code>show_term_doc_count_error</code> in the <code>terms</code> query of the <code>status_code</code>
field. How precise are the buckets?</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_server*/_search
{
  "size": 0,
  "aggs": {
    "logs_by_week": {
      "date_histogram": {
        "field": "@timestamp",
        "interval": "week"
      },
      "aggs": {
        "status_code_buckets": {
          "terms": {
            "field": "status_code"
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="openblock solution" id="solution96"><input id="question96" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer96" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_server*/_search
{
  "size": 0,
  "aggs": {
    "logs_by_week": {
      "date_histogram": {
        "field": "@timestamp",
        "interval": "week"
      },
      "aggs": {
        "status_code_buckets": {
          "terms": {
            "field": "status_code",
            "show_term_doc_count_error": true
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Our buckets are very precise! <code>doc_count_error_upper_bound == 0</code> for all
buckets.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>The aggregation below shows what are the top 20 cities that access our blogs.
Is this city aggregation exact?</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_server*/_search
{
  "size": 0,
  "aggs": {
    "top_cities": {
      "terms": {
        "field": "geoip.city_name.keyword",
        "size": 20
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="openblock solution" id="solution97"><input id="question97" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer97" style="display: none;">
<div class="content">
<div class="paragraph">
<p>Yes. If you set <code>show_term_doc_count_error</code> to true, you can see that
the <code>doc_count_error_upper_bound</code> is 0 for each of the top 20 cities.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_server*/_search
{
  "size": 0,
  "aggs": {
    "top_cities": {
      "terms": {
        "field": "geoip.city_name.keyword",
        "size": 20,
        "show_term_doc_count_error": true
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary:</strong> In this lab, you have familiarized yourself with
<code>dfs_query_then_fetch</code> search type, deep pagination with <code>search_after</code>,
and how to check the precision of aggregations.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_6_1">End of Lab 6.1</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_6_2_aliases_and_templates">Lab 6.2: Aliases and Templates</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab, you will learn how to define aliases, as well as
how to use index and search templates.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>EXAM PREP</strong>: Your current cluster has three indices containing the web access logs.
Define an alias named <code>access_logs</code> that points to all three
<code>logs_server*</code> indices.</p>
<div class="openblock solution" id="solution98"><input id="question98" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer98" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST _aliases
{
  "actions": [
    {
      "add": {
        "index": "logs_server*",
        "alias": "access_logs"
      }
    }
  ]
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Run the following query on your <code>access_logs</code> alias to verify it
points to all three indices. You should get 1,751,476 hits:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET access_logs/_count</code></pre>
</div>
</div>
</li>
<li>
<p>Try to add a new document in the <code>access_logs</code> alias.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT access_logs/_doc/3
{
  "@timestamp": "2017-05-05T02:07:51.407Z",
  "host": "server1",
  "user_agent": "Amazon CloudFront",
  "originalUrl": "/blog/elasticsearch-5-4-0-released",
  "response_size": 49921,
  "input": {
    "type": "log"
  },
  "http_version": "1.1",
  "runtime_ms": 108,
  "method": "GET",
  "language": {
    "url": "/blog/elasticsearch-5-4-0-released",
    "code": "en-us"
  },
  "status_code": 200,
  "geoip": {
    "country_code3": "JP",
    "continent_code": "AS",
    "location": {
      "lon": 139.69,
      "lat": 35.69
    },
    "country_name": "Japan",
    "country_code2": "JP"
  },
  "level": "info"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>What is the issue ?</p>
</div>
<div class="openblock solution" id="solution99"><input id="question99" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer99" style="display: block;">
<div class="content">
<div class="paragraph">
<p>A <strong>PUT</strong> request can only target one index, so you need to specify on which index you want to write the new document</p>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>EXAM PREP</strong>: Configure <code>logs_server3</code> to be the write index in your current alias using the <code>is_write_index</code> parameters and try to index the document again.</p>
<div class="openblock solution" id="solution100"><input id="question100" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer100" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST /_aliases
{
    "actions" : [
        {
            "add" : {
                 "index" : "logs_server3",
                 "alias" : "access_logs",
                 "is_write_index" : true
            }
        }
    ]
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>EXAM PREP</strong>: Define an index template named <code>access_logs_template</code> that matches
<code>logs_server*</code> and has the same index settings and mappings as your three
current <code>logs_server*</code> indices. Use 10 for the <code>order</code> value.</p>
<div class="openblock solution" id="solution101"><input id="question101" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer101" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT _template/access_logs_template
{
  "index_patterns": "logs_server*",
  "order": 10,
  "settings": {
    "number_of_shards": 1,
    "number_of_replicas": 1
  },
  "mappings": {
    "properties": {
      "@timestamp": {
        "type": "date"
      },
      "geoip": {
        "properties": {
          "city_name": {
            "type": "text",
            "fields": {
              "keyword": {
                "type": "keyword",
                "ignore_above": 256
              }
            }
          },
          "continent_code": {
            "type": "text",
            "fields": {
              "keyword": {
                "type": "keyword",
                "ignore_above": 256
              }
            }
          },
          "country_code2": {
            "type": "text",
            "fields": {
              "keyword": {
                "type": "keyword",
                "ignore_above": 256
              }
            }
          },
          "country_code3": {
            "type": "text",
            "fields": {
              "keyword": {
                "type": "keyword",
                "ignore_above": 256
              }
            }
          },
          "country_name": {
            "type": "text",
            "fields": {
              "keyword": {
                "type": "keyword",
                "ignore_above": 256
              }
            }
          },
          "location": {
            "properties": {
              "lat": {
                "type": "float"
              },
              "lon": {
                "type": "float"
              }
            }
          },
          "region_name": {
            "type": "text",
            "fields": {
              "keyword": {
                "type": "keyword",
                "ignore_above": 256
              }
            }
          }
        }
      },
      "host": {
        "type": "text",
        "fields": {
          "keyword": {
            "type": "keyword",
            "ignore_above": 256
          }
        }
      },
      "http_version": {
        "type": "text",
        "fields": {
          "keyword": {
            "type": "keyword",
            "ignore_above": 256
          }
        }
      },
      "language": {
        "properties": {
          "code": {
            "type": "text",
            "fields": {
              "keyword": {
                "type": "keyword",
                "ignore_above": 256
              }
            }
          },
          "url": {
            "type": "text",
            "fields": {
              "keyword": {
                "type": "keyword",
                "ignore_above": 256
              }
            }
          }
        }
      },
      "level": {
        "type": "text",
        "fields": {
          "keyword": {
            "type": "keyword",
            "ignore_above": 256
          }
        }
      },
      "method": {
        "type": "text",
        "fields": {
          "keyword": {
            "type": "keyword",
            "ignore_above": 256
          }
        }
      },
      "originalUrl": {
        "type": "text",
        "fields": {
          "keyword": {
            "type": "keyword",
            "ignore_above": 256
          }
        }
      },
      "response_size": {
        "type": "long"
      },
      "runtime_ms": {
        "type": "long"
      },
      "status_code": {
        "type": "long"
      },
      "user_agent": {
        "type": "text",
        "fields": {
          "keyword": {
            "type": "keyword",
            "ignore_above": 256
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Define a new index named <code>logs_server4</code> and verify the <code>access_logs_template</code> template was applied.</p>
<div class="openblock solution" id="solution102"><input id="question102" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer102" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT logs_server4</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_server4</code></pre>
</div>
</div>
<div class="paragraph">
<p>Verify that <code>logs_server4</code> contains the same mappings and settings defined
in the template.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>In the same request, remove <code>logs_server1</code> from the <code>access_logs</code> alias
and update the same alias to write to <code>logs_server4</code> instead of <code>logs_server3</code></p>
<div class="openblock solution" id="solution103"><input id="question103" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer103" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST _aliases
{
  "actions": [
    {
      "add": {
        "alias": "access_logs",
        "index": "logs_server3",
        "is_write_index": false
      }
    },
    {
      "add": {
        "alias": "access_logs",
        "index": "logs_server4",
        "is_write_index": true
      }
    },
    {
      "remove": {
        "alias": "access_logs",
        "index": "logs_server1"
      }
    }
  ]
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Index the following document using the <code>access_logs</code> alias,
assigning the <code>_id</code> to 1. Then GET the document in the <code>logs_server4</code>
index to verify the alias worked successfully:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{
  "@timestamp": "2018-03-21T05:57:19.722Z",
  "originalUrl": "/blog/logstash-jdbc-input-plugin",
  "host": "server2",
  "response_size": 58754,
  "status_code": 200,
  "method": "GET",
  "runtime_ms": 143,
  "geoip": {
    "country_code2": "IN",
    "country_code3": "IN",
    "continent_code": "AS",
    "location": {
      "lon": 77.5833,
      "lat": 12.9833
    },
    "region_name": "Karnataka",
    "city_name": "Bengaluru",
    "country_name": "India"
  },
  "language": {
    "url": "/blog/logstash-jdbc-input-plugin",
    "code": "en-us"
  },
  "user_agent": "Amazon CloudFront",
  "http_version": "1.1",
  "level": "info"
}</code></pre>
</div>
</div>
<div class="openblock solution" id="solution104"><input id="question104" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer104" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT access_logs/_doc/1
{
  "@timestamp": "2018-03-21T05:57:19.722Z",
  "originalUrl": "/blog/logstash-jdbc-input-plugin",
  "host": "server2",
  "response_size": 58754,
  "status_code": 200,
  "method": "GET",
  "runtime_ms": 143,
  "geoip": {
    "country_code2": "IN",
    "country_code3": "IN",
    "continent_code": "AS",
    "location": {
      "lon": 77.5833,
      "lat": 12.9833
    },
    "region_name": "Karnataka",
    "city_name": "Bengaluru",
    "country_name": "India"
  },
  "language": {
    "url": "/blog/logstash-jdbc-input-plugin",
    "code": "en-us"
  },
  "user_agent": "Amazon CloudFront",
  "http_version": "1.1",
  "level": "info"
}

GET logs_server4/_doc/1</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>EXAM PREP</strong>: Now, you are going to create a search template for the following query,
which finds the number of visitors to a blog on a specific day.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_server*/_search
{
  "query": {
    "bool": {
      "filter": [
        {
          "range": {
            "@timestamp": {
              "gte": "2017-05-12",
              "lt": "2017-05-13"
            }
          }
        },
        {
          "match": {
            "originalUrl.keyword": "/blog/elasticsearch-storage-the-true-story"
          }
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Make a search template for this query named <code>daily_hits</code> that uses the
following parameters:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>url</code>: to represent the value of <code>originalUrl.keyword</code></p>
</li>
<li>
<p><code>start_date</code>: for the day we are searching for blogs</p>
</li>
<li>
<p><code>end_date</code>: for the upper end of our date range</p>
</li>
</ul>
</div>
<div class="openblock solution" id="solution105"><input id="question105" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer105" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT _scripts/daily_hits
{
  "script": {
    "lang": "mustache",
    "source": {
      "query": {
        "bool": {
          "filter": [
            {
              "range": {
                "@timestamp": {
                  "gte": "{{start_date}}",
                  "lt": "{{end_date}}"
                }
              }
            },
            {
              "match": {
                "originalUrl.keyword": "{{url}}"
              }
            }
          ]
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Test your <code>daily_hits</code> search template using the following values:</p>
<div class="ulist">
<ul>
<li>
<p><code>url: "/blog/brewing-in-beats-postgresql-module-in-filebeat"</code></p>
</li>
<li>
<p><code>start_date: "2017-08-11"</code></p>
</li>
<li>
<p><code>end_date: "2017-08-12"</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You should get 24 hits.</p>
</div>
<div class="openblock solution" id="solution106"><input id="question106" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer106" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_server*/_search/template
{
  "id": "daily_hits",
  "params": {
    "url": "/blog/brewing-in-beats-postgresql-module-in-filebeat",
    "start_date": "2017-08-11",
    "end_date": "2017-08-12"
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Modify <code>daily_hits</code> so that if the <code>end_date</code> parameter is not defined,
then it is left off of the <code>range</code> query. In other words, if we only
provide a <code>start_date</code>, then find all log events from that date onwards.
Test your new search template using the same query as the previous step,
but remove the <code>end_date</code> from the query. You should get 155 hits.</p>
<div class="openblock solution" id="solution107"><input id="question107" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer107" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT _scripts/daily_hits
{
  "script": {
    "lang": "mustache",
    "source": """
    {
      "query": {
        "bool": {
          "must": {
            "match": {
              "originalUrl.keyword": "{{url}}"
            }
          },
          "filter": {
            "range": {
              "@timestamp": {
                "gte": "{{start_date}}"
                {{#end_date}}
                  ,
                  "lt": "{{end_date}}"
                {{/end_date}}
              }
            }
          }
        }
      }
    }
"""
  }
}

GET logs_server*/_search/template
{
  "id": "daily_hits",
  "params": {
    "url": "/blog/brewing-in-beats-postgresql-module-in-filebeat",
    "start_date": "2017-08-11"
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary:</strong> In this lab, you learned how to define aliases, as well as how to
use index and search templates.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_6_2">End of Lab 6.2</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_6_3_controlling_dynamic_behaviors">Lab 6.3: Controlling Dynamic Behaviors</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab, you will learn how to disable dynamic indexes,
define dynamic templates, and control dynamic fields.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>First, work on the dynamic index feature. Execute the following
operation:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT dynamic_test/_doc/1
{
  "my_field": "A value"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This request will go through and a new index will be created. Delete the
index.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>DELETE dynamic_test</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let’s make sure that we cannot create new indices without explicitly
creating a new index.</p>
</div>
</li>
<li>
<p>Disable dynamic index creation.</p>
<div class="openblock solution" id="solution108"><input id="question108" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer108" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT _cluster/settings
{
  "persistent": {
    "action.auto_create_index" : false
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Execute the following indexation:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT dynamic_test/_doc/1
{
  "my_field": "A value"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>What is the result of the operation?</p>
</div>
<div class="openblock solution" id="solution109"><input id="question109" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer109" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{
  "error": {
    "root_cause": [
      {
        "type": "index_not_found_exception",
        "reason": "no such index",
        "resource.type": "index_expression",
        "resource.id": "dynamic_test",
        "index_uuid": "_na_",
        "index": "dynamic_test"
      }
    ],
    "type": "index_not_found_exception",
    "reason": "no such index",
    "resource.type": "index_expression",
    "resource.id": "dynamic_test",
    "index_uuid": "_na_",
    "index": "dynamic_test"
  },
  "status": 404
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Create the index <code>dynamic_test</code> with one field <code>my_field</code> of type text.
And then execute the previous indexation. The indexation should succeed.</p>
<div class="openblock solution" id="solution110"><input id="question110" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer110" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT dynamic_test
{
  "mappings": {
    "properties": {
      "my_field": {
        "type": "text"
      }
    }
  }
}

PUT dynamic_test/_doc/1
{
  "my_field": "A value"
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Delete the index.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>DELETE dynamic_test</code></pre>
</div>
</div>
</li>
<li>
<p>Whitelist the pattern <code>dynamic_test</code> along with all the X-Pack indices.</p>
<div class="openblock solution" id="solution111"><input id="question111" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer111" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT _cluster/settings
{
  "persistent": {
    "action.auto_create_index" : "dynamic_test,.monitoring*,.watches,.triggered_watches,.watcher-history*,.ml*"
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Do the two following operations:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT dynamic/_doc/1
{
  "my_field": "A value"
}

PUT dynamic_test/_doc/1
{
"my_field": "A value"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>What will be the result of the first operation? The second?</p>
</div>
<div class="openblock solution" id="solution112"><input id="question112" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer112" style="display: block;">
<div class="content">
<div class="paragraph">
<p>The first operation will fail because it doesn’t match the whitelisted
pattern. The second will succeed because it does.</p>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>EXAM PREP</strong>: Next, you are going to work with dynamic templates.
Create a new index named <code>surveys</code> that satisfies the following criteria:</p>
<div class="ulist">
<ul>
<li>
<p>The <code>job_title</code> field is mapped as <code>text</code> and <code>keyword</code></p>
</li>
<li>
<p>The <code>miles_travelled</code> field is mapped as an <code>integer_range</code></p>
</li>
<li>
<p>Any field name that ends in <code>_rating</code> is dynamically mapped as an
<code>integer</code></p>
</li>
<li>
<p>Any string field that is not already in the mapping is dynamically
mapped as <code>keyword</code> only, and is <strong>not</strong> indexed</p>
</li>
</ul>
</div>
<div class="openblock solution" id="solution113"><input id="question113" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer113" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT surveys
{
  "mappings": {
    "dynamic_templates": [
      {
        "undefined_string_fields": {
          "match_mapping_type": "string",
          "mapping": {
            "type": "keyword",
            "index": false
          }
        }
      },
      {
        "rating_fields": {
          "match": "*_rating",
          "mapping": {
            "type": "integer"
          }
        }
      }
    ],
    "properties": {
      "job_title": {
        "type": "text",
        "fields": {
          "keyword": {
            "type": "keyword"
          }
        }
      },
      "miles_travelled": {
        "type": "integer_range"
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Put the following survey response in your <code>surveys</code> index. You will
need to modify the <code>miles_travelled</code> field so that it is in the
appropriate format for an <code>integer_range</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{
  "job_title": "Elasticsearch Engineer",
  "course_rating": 9,
  "comments": "Great class. I want to get certified now!",
  "miles_travelled": "0-25"
}</code></pre>
</div>
</div>
<div class="openblock solution" id="solution114"><input id="question114" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer114" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT surveys/_doc/1
{
  "job_title": "Elasticsearch Engineer",
  "course_rating": 9,
  "comments": "Great class. I want to get certified now!",
  "miles_travelled": {
    "gte": 0,
    "lte": 25
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Add the following document to <code>surveys</code>. What should happen to the
mapping? View the <code>surveys</code> mapping to verify your dynamic templates are
working as expected.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT surveys/_doc/2
{
  "job_title": "Software Engineer",
  "labs_rating": 10,
  "city": "Berlin",
  "miles_travelled": {
    "gt": 50,
    "lte": 100
  }
}</code></pre>
</div>
</div>
<div class="openblock solution" id="solution115"><input id="question115" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer115" style="display: block;">
<div class="content">
<div class="paragraph">
<p>The <code>labs_rating</code> should have been mapped as an integer, and <code>city</code>
should be <code>keyword</code> only with <code>index</code> set to false. View your mapping to
verify:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET surveys/_mapping</code></pre>
</div>
</div>
<div class="paragraph">
<p>Your mapping should include:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>...
        "properties": {
          "city": {
            "type": "keyword",
            "index": false
          },
...
          "labs_rating": {
            "type": "integer"
          },
...</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Finally, you are going to work with dynamic fields.
Create a new index named <code>surveys2</code> that has only two fields in its mapping:</p>
<div class="ulist">
<ul>
<li>
<p>A field named <code>feedback</code> of type <code>text</code></p>
</li>
<li>
<p>A field named <code>course_rating</code> of type <code>integer</code></p>
</li>
<li>
<p>In addition, configure the mapping so that it will not be changed by
unexpected fields and any documents with unexpected fields will fail to
be indexed</p>
</li>
</ul>
</div>
<div class="openblock solution" id="solution116"><input id="question116" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer116" style="display: block;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT surveys2
{
  "mappings": {
    "dynamic": "strict",
    "properties": {
      "feedback": {
        "type": "text"
      },
      "course_rating": {
        "type": "integer"
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Review the following <strong>PUT</strong> command and predict what is the result.
After that run the <strong>PUT</strong> command to see if you are correct.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT surveys2/_doc/1
{
  "food_rating": 10
}</code></pre>
</div>
</div>
<div class="openblock solution" id="solution117"><input id="question117" data-value="answer" type="button" value="Hide answer" class="answerInput"><div id="answer117" style="display: block;">
<div class="content">
<div class="paragraph">
<p>The document does not get indexed because it contains a field not defined
in the mapping and your mapping has <code>dynamic</code> set to <code>strict</code>.</p>
</div>
</div>
</div></div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary:</strong> In this lab, you learned how to disable dynamic indexes,
define dynamic templates, and control dynamic fields.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_6_3">End of Lab 6.3</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_6_4_common_causes_of_poor_search_performance">Lab 6.4: Common Causes of Poor Search Performance</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab, you will review some design choices that may
lead to poor performance.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>What can you change in the following query? Why?</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "content": "security"
          }
        },
        {
          "term": {
            "category.keyword": "Engineering"
          }
        },
        {
          "range": {
            "publish_date": {
              "gte": "2015-01-01T00:00:00.000Z",
              "lte": "2018-01-01T00:00:00.000Z"
            }
          }
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="openblock solution" id="solution118"><input id="question118" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer118" style="display: none;">
<div class="content">
<div class="paragraph">
<p>You can move both <code>term</code> and <code>range</code> queries inside a <code>filter</code> to take
advantage of filter caching as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "content": "security"
          }
        }
      ],
      "filter": [
        {
          "term": {
            "category.keyword": "Engineering"
            }
        },
        {
          "range": {
            "publish_date": {
              "gte": "2015-01-01T00:00:00.000Z",
              "lte": "2018-01-01T00:00:00.000Z"
            }
          }
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>The following aggregation describes a relationship between run time and
response size, but it can take long to execute if you have too many
documents.
Limit the scope of the aggregation to only documents with a <code>200</code> status code.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_server*/_search
{
  "size": 0,
  "aggs": {
    "statistics": {
      "matrix_stats": {
        "fields": ["runtime_ms", "response_size"]
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="openblock solution" id="solution119"><input id="question119" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer119" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_server*/_search
{
  "size": 0,
  "query": {
    "bool": {
      "filter": {
        "term": {
          "status_code": 200
        }
      }
    }
  },
  "aggs": {
    "statistics": {
      "matrix_stats": {
        "fields": ["runtime_ms", "response_size"]
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Write an aggregation on <code>logs_server*</code> to find the top ten countries that
exceeded the <code>685</code> milliseconds run time SLA on requests to blogs mentioning
<code>elasticsearch</code>. (<strong>TIP:</strong> Use a filter bucket on <code>runtime_ms</code> to
define the aggregation scope and a match query on <code>originalUrl</code> to define
the query scope.)</p>
<div class="openblock solution" id="solution120"><input id="question120" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer120" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_server*/_search
{
  "size": 0,
  "query": {
    "bool": {
      "filter": {
        "match": {
          "originalUrl": "elasticsearch"
        }
      }
    }
  },
  "aggs": {
    "above_sla": {
      "filter": {
        "range": {
          "runtime_ms": {
            "gt": "685"
          }
        }
      },
      "aggs": {
        "top_countries": {
          "terms": {
            "field": "geoip.country_name.keyword",
            "size": 10
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Now, you are interested in analyzing the top ten countries that requested
blogs mentioning <code>elasticsearch</code>.
(<strong>TIP:</strong> Change the filter bucket aggregation from the previous exercise
to a sampler aggregation with <code>shard_size</code> 100 and compare the results.)</p>
<div class="openblock solution" id="solution121"><input id="question121" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer121" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_server*/_search
{
  "size": 0,
  "query": {
    "bool": {
      "filter": {
        "match": {
          "originalUrl": "elasticsearch"
        }
      }
    }
  },
  "aggs": {
    "my_sample": {
      "sampler": {
        "shard_size": 100
      },
      "aggs": {
        "top_countries": {
          "terms": {
            "field": "geoip.country_name.keyword",
            "size": 10
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>What might be a problem in the following mapping?</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT livetracking
{
  "mappings": {
    "properties": {
      "relation": {
        "type": "join",
        "relations": {
          "event": "athlete",
          "athlete": "livetracking"
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="openblock solution" id="solution122"><input id="question122" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer122" style="display: none;">
<div class="content">
<div class="paragraph">
<p>The mapping above represents the following tree:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>   event
     |
  athlete
     |
livetracking</code></pre>
</div>
</div>
<div class="paragraph">
<p>This tree shows a multiple level of parent/child relations.
Using multiple levels of relations to replicate a relational model is not
recommended.
Each level of relation adds an overhead at query time in terms of memory
and computation.
You should de-normalize your data if you care about performance.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>What might a problem in the following query?</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "query": {
    "regexp": {
      "content": ".*search"
    }
  }
}</code></pre>
</div>
</div>
<div class="openblock solution" id="solution123"><input id="question123" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer123" style="display: none;">
<div class="content">
<div class="paragraph">
<p>This query uses leading wildcards and they mostly lower performance.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>Suppose you really need to search the end of your content tokes.
How would you index the content of your blogs?</p>
<div class="openblock solution" id="solution124"><input id="question124" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer124" style="display: none;">
<div class="content">
<div class="paragraph">
<p>First, you can create an index where you have an extra field called <code>reverse</code>
that uses the <code>reverse</code> token filter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT blogs_reverse
{
  "settings": {
    "analysis": {
      "analyzer": {
        "reverse": {
          "type": "custom",
          "char_filter": [],
          "tokenizer": "standard",
          "filter": ["lowercase", "reverse"]
        }
      }
    }
  },
  "mappings" : {
    "properties" : {
      "author" : {
        "type" : "text",
        "fields" : {
          "keyword" : {
            "type" : "keyword",
            "ignore_above" : 256
          }
        }
      },
      "category" : {
        "type" : "text",
        "fields" : {
          "keyword" : {
            "type" : "keyword",
            "ignore_above" : 256
          }
        }
      },
      "content" : {
        "type" : "text",
        "fields" : {
          "keyword" : {
            "type" : "keyword",
            "ignore_above" : 256
          },
          "reverse": {
            "type": "text",
            "analyzer": "reverse"
          }
        }
      },
      "locales" : {
        "type" : "text",
        "fields" : {
          "keyword" : {
            "type" : "keyword",
            "ignore_above" : 256
          }
        }
      },
      "publish_date" : {
        "type" : "date"
      },
      "seo_title" : {
        "type" : "text",
        "fields" : {
          "keyword" : {
            "type" : "keyword",
            "ignore_above" : 256
          }
        }
      },
      "title" : {
        "type" : "text",
        "fields" : {
          "keyword" : {
            "type" : "keyword",
            "ignore_above" : 256
          }
        }
      },
      "url" : {
        "type" : "text",
        "fields" : {
          "keyword" : {
            "type" : "keyword",
            "ignore_above" : 256
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, you can reindex your data from the old index to the new index:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST _reindex?wait_for_completion=false
{
  "source": {
    "index": "blogs"
  },
  "dest": {
    "index": "blogs_reverse"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, you can adapt the previous query into the following one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs_reverse/_search
{
  "query": {
    "regexp": {
      "content.reverse": "hcraes.*"
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary:</strong> In this lab, you reviewed some design choices that may lead to
poor performance.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_6_4">End of Lab 6.4</h3>
<hr>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
</div>
</div>
<script type="text/javascript"> build_solutions()</script>
<p>© Elasticsearch BV 2015-2020. All rights reserved. Decompiling, copying, publishing and/or distribution without written consent of Elasticsearch BV is strictly prohibited.</p>

</body></html>