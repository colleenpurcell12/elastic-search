<!DOCTYPE html>
<!-- saved from url=(0108)http://ec2-52-59-252-50.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_2_3_combining_queries -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.8">
<title>Lab Guide: Elasticsearch Engineer I</title>
<style>
.header {
  font-size: 36px;
  line-height: 49px;
  font-family: "Open Sans","arial, helvetica, sans-serif";
  display: block;
  -webkit-font-smoothing: antialiased;
  font-weight: 300;
}

.logo {
  vertical-align: top;
  border: 0;
}

html {
  background-color: #e6e9e9;
  background-image: -webkit-linear-gradient(270deg,rgb(230,233,233) 0%,rgb(216,221,221) 100%);
  background-image: linear-gradient(270deg,rgb(230,233,233) 0%,rgb(216,221,221) 100%);
  -webkit-font-smoothing: antialiased;
}

.lab1_toggle {
  font-family: Helvetica, Arial, sans-serif;
  font-size: 2.0em;
  line-height: 1.8em;
  font-weight: bold;
  text-align: center;
}

.virtual_div {
  text-align: center;
  background-color: beige;
  border-color: black;
  border-width: thin;
  border-style: solid;
  padding: 1em 1em 1em;
}

.left {
  text-align: left;
}

body {
  margin: 0 auto;
  padding: 2em 2em 4em;
  max-width: 80%;
  font-family: Helvetica, Arial, sans-serif;
  font-size: 1.2em;
  line-height: 1.5em;
  color: #545454;
  background-color: #ffffff;
  box-shadow: 0 0 2px rgba(0, 0, 0, 0.06);
}

h1, h2, h3, h4, h5, h6 {
  color: white;
  font-weight: 400;
  line-height: 1.5em;
  background-color: rgb(7,165,222);
  font: Arial;
  padding-left: 15px;
  box-shadow: 10px 10px 5px rgb(144, 144, 145);
}
h2, h3 {
  background: #3399cc; /* Old browsers */
  background: -moz-linear-gradient(top,  #3399cc 0%, #003366 0%, #3399cc 100%); /* FF3.6-15 */
  background: -webkit-linear-gradient(top,  #3399cc 0%,#003366 0%,#3399cc 100%); /* Chrome10-25,Safari5.1-6 */
  background: linear-gradient(to bottom,  #3399cc 0%,#003366 0%,#3399cc 100%); /* W3C, IE10+, FF16+, Chrome26+, Opera12+, Safari7+ */
  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#3399cc', endColorstr='#3399cc',GradientType=0 ); /* IE6-9 */
}

h1 {
  background: #3399cc;
  background: -moz-linear-gradient(top,  #3399cc 0%, #207cca 0%, #009999 100%); /* FF3.6-15 */
  background: -webkit-linear-gradient(top,  #3399cc 0%,#207cca 0%,#009999 100%); /* Chrome10-25,Safari5.1-6 */
  background: linear-gradient(to bottom,  #3399cc 0%,#207cca 0%,#009999 100%); /* W3C, IE10+, FF16+, Chrome26+, Opera12+, Safari7+ */
  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#3399cc', endColorstr='#009999',GradientType=0 ); /* IE6-9 */
}

h3 {
  font-weight: bold;
}

p.summary {
  margin-top: 3em;
  margin-bottom: 3em;
}

a {
  color: #0083e8;
}

b, strong {
  font-weight: 600;
}

samp {
  display: none;
}

img {
  -webkit-animation: colorize 2s cubic-bezier(0, 0, .78, .36) 1;
  animation: colorize 2s cubic-bezier(0, 0, .78, .36) 1;
  background: transparent;
  border: 10px solid rgba(0, 0, 0, 0.12);
  border-radius: 4px;
  display: block;
  margin: 1.3em auto;
  max-width: 95%;
}

video {
  border: 10px solid rgba(0, 0, 0, 0.12);
  border-radius: 4px;
  display: block;
  margin: 1.3em auto;
  max-width: 95%;
}

@-webkit-keyframes colorize {
  0% {
      -webkit-filter: grayscale(100%);
  }
  100% {
      -webkit-filter: grayscale(0%);
  }
}

@keyframes colorize {
  0% {
      filter: grayscale(100%);
  }
  100% {
      filter: grayscale(0%);
  }
}

pre code {
  padding: 0;
  color: #3f3b36;
  background-color: transparent;
  font-size: 1.0rem;
  line-height: 2rem;
  text-shadow: none;
}

code {
  background-color: rgba(27,31,35,.05);
  border-radius: 3px;
  font-size: 85%;
  padding: .2em .4em;
  font-weight: lighter;
  font-family: Monaco,'MonacoRegular',monospace;
}

.answerInput {
  padding-right: 0.5rem;
  padding-left: 0.5rem;
  color: #3f3b36;
  border: 1px solid #39bdb1;
  border-radius: 5rem;
  font-weight: lighter;
  font-family: Monaco,'MonacoRegular',monospace;
  font-size: 0.8rem;
}

.answerInput:focus{
  outline: none;
}

pre {
  width: 92%;
  overflow: auto;
  margin: 1rem 0;
  margin-top: 1rem;
  margin-right: 0px;
  margin-bottom: 1rem;
  margin-left: 0px;
  padding: 1rem 0.8rem 1rem 1.2rem;
  padding-top: 1rem;
  padding-right: 0.8rem;
  padding-bottom: 1rem;
  padding-left: 1.2rem;
  color: #3f3b36;
  border: 1px solid #39bdb1;
  border-left: 1rem solid #39bdb1;
  font: lighter 1.0rem/2rem Monaco,'MonacoRegular',monospace;
  font-style: normal;
  font-variant-ligatures: normal;
  font-variant-caps: normal;
  font-variant-numeric: normal;
  font-weight: lighter;
  font-stretch: normal;
  font-size: 1.0rem;
  line-height: 1.4rem;
  font-family: Monaco, MonacoRegular, monospace;
  background: url(images/pre.png) repeat 0 -0.9rem;
  background-image: url(images/pre.png);
  background-position-x: 0px;
  background-position-y: -0.9rem;
  background-repeat-x: repeat;
  background-repeat-y: repeat;
  background-attachment: initial;
  background-origin: initial;
  background-clip: initial;
  background-color: initial;
  background-size: 1px 4rem;
  box-shadow: 10px 10px 5px rgb(144, 144, 145);
}

pre.bash {
  background-color: black;
  color: white;
  font-family: Monaco,MonacoRegular,monospace;
}

div[class="listingblock bash"] div[class="content"] pre {
  background-color: black;
}

div[class="listingblock bash"] div[class="content"] pre code {
  color: white;
  font-family: Monaco,MonacoRegular,monospace;
  line-height: 1.4rem;
}

hr {
  margin-bottom: 4em;
  margin-top: 4em;
  border : 0;
  height: 1px;
  background-image: linear-gradient(to right, #66ccff, #006699, #66ccff);
}

ol li {
  margin-top: 3rem;
}

ul li {
  margin-top: 0
}

kbd {
  font-family: Courier, Monaco,'MonacoRegular',monospace;
  font-weight: bold;
  font-size: 1.2rem;
  line-height: 1.5rem;
}

.kbd {
  font-family: Courier, Monaco,'MonacoRegular',monospace;
  font-weight: bold;
  font-size: 1.2rem;
  line-height: 1.5rem;
}

h2 {
  font-size: 2.5rem;
}

table.labTable {
  border: 1px solid #1C6EA4;
  /* background-color: #EEEEEE;*/
  width: 70%;
  text-align: left;
  border-collapse: collapse;
}

table.labTable td, table.labTable th {
  border: 3px solid #1C6EA4;
  padding: 3px 2px;
}

table.labTable tbody td {
  font-size: 16px;
}

table.labTable tr:nth-child(even) {
  background: #D0E4F5;
}

table.labTable thead {
  background: #1C6EA4;
  background: -moz-linear-gradient(top, #5592bb 0%, #327cad 66%, #1C6EA4 100%);
  background: -webkit-linear-gradient(top, #5592bb 0%, #327cad 66%, #1C6EA4 100%);
  background: linear-gradient(to bottom, #5592bb 0%, #327cad 66%, #1C6EA4 100%);
  border-bottom: 2px solid #444444;
}

table.labTable thead th {
  font-size: 15px;
  font-weight: bold;
  color: #FFFFFF;
  border-left: 2px solid #D0E4F5;
}

table.labTable thead th:first-child {
  border-left: none;
}

table.relevance {
    border: 1px solid black;
    font-size: 0.8em;
    border-collapse: collapse;
}
.relevance th {
    text-align: left;
    white-space: nowrap;
    border-top: 1px solid black;
}

.relevance tr {
    border-top: 1px solid #dddddd;
}

.relevance td, .relevance th {
  padding: 2px 5px;
  vertical-align: top;
  text-overflow: TODO;
}

</style>

<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<link rel="shortcut icon" href="http://ec2-52-59-252-50.eu-central-1.compute.amazonaws.com/instructions/images/favicon.ico" type="image/x-icon">
<script type="text/javascript" src="./Lab Guide_ Elasticsearch Engineer I_files/elastic_training.js"></script>
</head><body class="article"><img class="logo" src="./Lab Guide_ Elasticsearch Engineer I_files/elastic-logo.svg" width="300">

<!-- Include an extra training.js to make development easier. -->
<script type="text/javascript" src="./Lab Guide_ Elasticsearch Engineer I_files/elastic_training(1).js"></script>


<div id="header">
<h1>Lab Guide: Elasticsearch Engineer I</h1>
<div id="toc" class="toc">
<div id="toctitle"></div>
<ul class="sectlevel1">
<li><a href="http://ec2-52-59-252-50.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_1_1_elastic_stack_overview">Lab 1.1: Elastic Stack Overview</a></li>
<li><a href="http://ec2-52-59-252-50.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_1_2_getting_started_with_elasticsearch">Lab 1.2: Getting Started with Elasticsearch</a></li>
<li><a href="http://ec2-52-59-252-50.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_1_3_crud_operations">Lab 1.3: CRUD Operations</a></li>
<li><a href="http://ec2-52-59-252-50.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_1_4_searching_data">Lab 1.4: Searching Data</a></li>
<li><a href="http://ec2-52-59-252-50.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_2_1_relevance">Lab 2.1: Relevance</a></li>
<li><a href="http://ec2-52-59-252-50.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_2_2_full_text_queries">Lab 2.2: Full-Text Queries</a></li>
<li><a href="http://ec2-52-59-252-50.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_2_3_combining_queries">Lab 2.3: Combining Queries</a></li>
<li><a href="http://ec2-52-59-252-50.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_2_4_implementing_a_search_page">Lab 2.4: Implementing a Search Page</a></li>
<li><a href="http://ec2-52-59-252-50.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_3_1_metrics_aggregations">Lab 3.1: Metrics Aggregations</a></li>
<li><a href="http://ec2-52-59-252-50.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_3_2_bucket_aggregations">Lab 3.2: Bucket Aggregations</a></li>
<li><a href="http://ec2-52-59-252-50.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_3_3_combining_aggregations">Lab 3.3: Combining Aggregations</a></li>
<li><a href="http://ec2-52-59-252-50.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_4_1_what_is_a_mapping">Lab 4.1: What is a Mapping?</a></li>
<li><a href="http://ec2-52-59-252-50.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_4_2_text_and_keyword_strings">Lab 4.2: Text and Keyword Strings</a></li>
<li><a href="http://ec2-52-59-252-50.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_4_3_the_inverted_index_and_doc_values">Lab 4.3: The Inverted Index and Doc Values</a></li>
<li><a href="http://ec2-52-59-252-50.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_4_4_custom_mappings">Lab 4.4: Custom Mappings</a></li>
<li><a href="http://ec2-52-59-252-50.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_5_1_master_nodes">Lab 5.1: Master Nodes</a></li>
<li><a href="http://ec2-52-59-252-50.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_5_2_node_roles">Lab 5.2: Node Roles</a></li>
<li><a href="http://ec2-52-59-252-50.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_5_3_understanding_shards">Lab 5.3: Understanding Shards</a></li>
<li><a href="http://ec2-52-59-252-50.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_5_4_distributed_operations">Lab 5.4: Distributed Operations</a></li>
<li><a href="http://ec2-52-59-252-50.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_6_1_http_response_and_shard_allocation_issues">Lab 6.1: HTTP Response and Shard Allocation Issues</a></li>
<li><a href="http://ec2-52-59-252-50.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_6_2_monitoring">Lab 6.2: Monitoring</a></li>
<li><a href="http://ec2-52-59-252-50.eu-central-1.compute.amazonaws.com/instructions/labs.html#_lab_6_3_diagnosing_performance_issues">Lab 6.3: Diagnosing Performance Issues</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<hr>
</div>
</div>
<div class="sect1">
<h2 id="_lab_1_1_elastic_stack_overview">Lab 1.1: Elastic Stack Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> The goal of this lab is to introduce you to the Strigo lab
environment and give you a brief overview of its architecture.</p>
</div>
<div class="paragraph">
<p><strong>NOTE:</strong> All labs will be done using the Strigo environment.
The lab environment was tailored for this training and has everything you
need to complete the labs successfully.
After the course is completed and your lab environment is no longer available, you will be able to
complete the labs on your local machine by downloading the zip file available in your course page at training.elastic.co. Use
<a href="http://ec2-52-59-252-50.eu-central-1.compute.amazonaws.com/instructions/local_lab.html" target="_blank" rel="noopener">these instructions</a> as a reference on
how to run the labs in your own machine.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Take a moment to look at the picture below, which shows the server
architecture you are going to use in the labs:</p>
<div class="paragraph">
<p><span class="image"><img src="./Lab Guide_ Elasticsearch Engineer I_files/lab_topology.png" alt="lab topology"></span></p>
</div>
<div class="paragraph">
<p>Notice there are four different servers available.
The <code>entry server</code> is an entry point to the other three servers, and
it is the server in which you are automatically logged in to every time
you open a new terminal tab in your lab environment.</p>
</div>
</li>
<li>
<p>From within the Virtual Environment UI, click on the <strong>"My Lab"</strong> icon in
the left toolbar: <span class="image"><img src="./Lab Guide_ Elasticsearch Engineer I_files/strigo_lab_icon.png" alt="strigo lab icon"></span>
A command prompt will open, and you will be logged in to a Linux machine
that is configured to provide easy SSH access to three servers: <code>server1</code>,
<code>server2</code> and <code>server3</code>.
You will deploy an Elasticsearch cluster on these 3 servers throughout the
<em>Engineer I</em> course. For this first lab, you will perform all of the tasks on
<code>server1</code>.</p>
</li>
<li>
<p>SSH onto <code>server1</code>:</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>ssh server1</code></pre>
</div>
</div>
</li>
<li>
<p>View the contents of the <strong>elastic</strong> user home folder by entering <code>ls -l</code>.
You should see Elasticsearch, Filebeat, Kibana and Logstash tar files,
which were all simply downloaded from our website. (You will see other
files in the home folder as well):</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>[elastic@server1 ~]$ ls -l
total 1502160
drwxrwxr-x 5 elastic elastic      4096 Sep 26 20:43 datasets
-rw-rw-r-- 1 elastic elastic 285082863 Sep 26 20:43 elasticsearch-7.3.1-linux-x86_64.tar.gz
-rw-rw-r-- 1 elastic elastic  25265083 Sep 26 20:43 filebeat-7.3.1-linux-x86_64.tar.gz
-rw-rw-r-- 1 elastic elastic 236770201 Sep 26 20:43 kibana-7.3.1-linux-x86_64.tar.gz
-rw-rw-r-- 1 elastic elastic 171784034 Sep 26 20:43 logstash-7.3.1.tar.gz
-rw-rw-r-- 1 elastic elastic    551290 Sep 26 20:43 postgresql-9.1-901-1.jdbc4.jar</code></pre>
</div>
</div>
</li>
<li>
<p>Within Virtual Environment, open a new console by clicking the plus sign
<strong>"+"</strong> next to the tab of your current console, and you should see a command
prompt:
<span class="image"><img src="./Lab Guide_ Elasticsearch Engineer I_files/strigo_new_tab.png" alt="strigo new tab" width="50.0%"></span></p>
</li>
<li>
<p>Use your new console window to SSH onto <code>server1</code>.</p>
<div class="openblock solution" id="solution0"><input id="question0" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer0" style="display: none;">
<div class="content">
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>ssh server1</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>In the next labs you will start Elasticsearch, use Filebeat and Logstash to
ingest data into Elasticsearch, as well as visualize data with Kibana.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary:</strong> In this lab you familiarized yourself with the lab environment,
which you are going to use throughout this course.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_1_1">End of Lab 1.1</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_1_2_getting_started_with_elasticsearch">Lab 1.2: Getting Started with Elasticsearch</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab, you will start and stop Elasticsearch and update some
of the configuration settings.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Extract Elasticsearch using the following command:</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>tar -xf elasticsearch-7.3.1-linux-x86_64.tar.gz</code></pre>
</div>
</div>
</li>
<li>
<p>Start Elasticsearch:</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>./elasticsearch-7.3.1/bin/elasticsearch</code></pre>
</div>
</div>
</li>
<li>
<p>Wait for Elasticsearch to startup. You should see a message showing
that it started. (The output order may vary a bit.)</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>[2019-10-02T21:22:29,879][INFO ][o.e.h.AbstractHttpServerTransport] [server1] publish_address {127.0.0.1:9200}, bound_addresses {127.0.0.1:9200}
[2019-10-02T21:22:29,880][INFO ][o.e.n.Node               ] [server1] started
[2019-10-02T21:22:29,979][INFO ][o.e.g.GatewayService     ] [server1] recovered [0] indices into cluster_state
[2019-10-02T21:22:30,228][INFO ][o.e.c.m.MetaDataIndexTemplateService] [server1] adding template [.triggered_watches] for index patterns [.triggered_watches*]
[2019-10-02T21:22:30,302][INFO ][o.e.c.m.MetaDataIndexTemplateService] [server1] adding template [.watch-history-10] for index patterns [.watcher-history-10*]
[2019-10-02T21:22:30,328][INFO ][o.e.c.m.MetaDataIndexTemplateService] [server1] adding template [.watches] for index patterns [.watches*]
[2019-10-02T21:22:30,360][INFO ][o.e.c.m.MetaDataIndexTemplateService] [server1] adding template [.monitoring-logstash] for index patterns [.monitoring-logstash-7-*]
[2019-10-02T21:22:30,409][INFO ][o.e.c.m.MetaDataIndexTemplateService] [server1] adding template [.monitoring-es] for index patterns [.monitoring-es-7-*]
[2019-10-02T21:22:30,450][INFO ][o.e.c.m.MetaDataIndexTemplateService] [server1] adding template [.monitoring-beats] for index patterns [.monitoring-beats-7-*]
[2019-10-02T21:22:30,480][INFO ][o.e.c.m.MetaDataIndexTemplateService] [server1] adding template [.monitoring-alerts-7] for index patterns [.monitoring-alerts-7]
[2019-10-02T21:22:30,517][INFO ][o.e.c.m.MetaDataIndexTemplateService] [server1] adding template [.monitoring-kibana] for index patterns [.monitoring-kibana-7-*]
[2019-10-02T21:22:30,543][INFO ][o.e.x.i.a.TransportPutLifecycleAction] [server1] adding index lifecycle policy [watch-history-ilm-policy]
[2019-10-02T21:22:30,656][INFO ][o.e.l.LicenseService     ] [server1] license [46e788b4-843d-421c-869e-51df568f21ed] mode [basic] - valid
[2019-10-02T21:22:30,659][INFO ][o.e.x.s.s.SecurityStatusChangeListener] [server1] Active license is now [BASIC]; Security is disabled</code></pre>
</div>
</div>
</li>
<li>
<p>Using the other tab that you connected to <strong>server1</strong> in the previous lab, enter the following request to get basic cluster and node information:</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>curl -X GET "http://localhost:9200/"</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you execute this request, you should see a response similar to:</p>
</div>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>{
  "name" : "server1",
  "cluster_name" : "elasticsearch",
  "cluster_uuid" : "UCvdeCOgTJ2UEa__qmcP5w",
  "version" : {
    "number" : "7.3.1",
    "build_flavor" : "default",
    "build_type" : "tar",
    "build_hash" : "4749ba6",
    "build_date" : "2019-08-19T20:19:25.651794Z",
    "build_snapshot" : false,
    "lucene_version" : "8.0.0",
    "minimum_wire_compatibility_version" : "6.8.0",
    "minimum_index_compatibility_version" : "6.0.0-beta1"
  },
  "tagline" : "You Know, for Search"
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>What is the version of your Elasticsearch instance?</p>
<div class="openblock solution" id="solution1"><input id="question1" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer1" style="display: none;">
<div class="content">
<div class="paragraph">
<p>The version of the node is value of the <code>version.number</code> field (<strong>7.3.1</strong> above)</p>
</div>
</div>
</div></div>
</li>
<li>
<p>What is the name of your node?</p>
<div class="openblock solution" id="solution2"><input id="question2" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer2" style="display: none;">
<div class="content">
<div class="paragraph">
<p>The name of the node is the value of the <code>name</code> field (<strong>server1</strong> above).</p>
</div>
</div>
</div></div>
</li>
<li>
<p>What is the name of your cluster?</p>
<div class="openblock solution" id="solution3"><input id="question3" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer3" style="display: none;">
<div class="content">
<div class="paragraph">
<p>In the output above, the cluster is named <strong>"elasticsearch"</strong>. Your cluster should be named <strong>"elasticsearch"</strong> also.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>How did these names get assigned to your node and cluster?</p>
<div class="openblock solution" id="solution4"><input id="question4" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer4" style="display: none;">
<div class="content">
<div class="paragraph">
<p>By default Elasticsearch will use <strong>"elasticsearch"</strong> as the cluster name and
the hostname that the machine has when it starts as the node name.
In the next lab steps you will see how to change these settings.</p>
</div>
</div>
</div></div>
</li>
</ul>
</div>
</li>
<li>
<p>Stop Elasticsearch by hitting <strong>Ctrl+c</strong> in the terminal tab where you
have Elasticsearch running. You should see the following output, and the
command prompt should also appear:</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>[2019-10-02T21:40:09,926][INFO ][o.e.x.m.p.NativeController] [server1] Native controller process has stopped - no new native processes can be started
[2019-10-02T21:40:09,927][INFO ][o.e.n.Node               ] [server1] stopping ...
[2019-10-02T21:40:09,934][INFO ][o.e.x.w.WatcherService   ] [server1] stopping watch service, reason [shutdown initiated]
[2019-10-02T21:40:10,004][INFO ][o.e.n.Node               ] [server1] stopped
[2019-10-02T21:40:10,004][INFO ][o.e.n.Node               ] [server1] closing ...
[2019-10-02T21:40:10,016][INFO ][o.e.n.Node               ] [server1] closed
[elastic@server1 ~]$</code></pre>
</div>
</div>
</li>
<li>
<p>The current cluster and node names have been automatically defined.
Let’s change both to values that make more sense:</p>
<div class="ulist">
<ul>
<li>
<p>Open the <code>elasticsearch.yml</code> file using a text editor of your choice:
nano, emacs, or vi. If you are not familiar with command-line editors,
we suggest you use nano (click <a href="http://ec2-52-59-252-50.eu-central-1.compute.amazonaws.com/instructions/nano_tutorial.html" target="_blank" rel="noopener">here</a> for tips on
using nano). You will find the file in the <code>elasticsearch-7.3.1/config</code>
directory. For example, if you want to use nano:</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>nano elasticsearch-7.3.1/config/elasticsearch.yml</code></pre>
</div>
</div>
</li>
<li>
<p>Notice that every line in this file is commented out.
This is a good reference if you want to quickly lookup settings names.
However, having a configuration file with so many comments in between the
settings can be confusing.
At the end of the file, Set the name of the cluster to <code>my_cluster</code>:</p>
<div class="openblock solution" id="solution5"><input id="question5" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer5" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>cluster.name: "my_cluster"</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Save your changes to <code>elasticsearch.yml</code>. To save changes to a file
using nano, hit <strong>Ctrl+x</strong> to exit nano, then press "<strong>y</strong>" to save your
changes. Hit "<strong>Enter</strong>" when prompted for a file name.</p>
</li>
<li>
<p>Now, start Elasticsearch again, with the node name <code>node1</code>.</p>
<div class="openblock solution" id="solution6"><input id="question6" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer6" style="display: none;">
<div class="content">
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>./elasticsearch-7.3.1/bin/elasticsearch -E node.name=node1</code></pre>
</div>
</div>
</div>
</div></div>
</li>
</ul>
</div>
</li>
<li>
<p>Now check the cluster information to see what changed:</p>
<div class="openblock solution" id="solution7"><input id="question7" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer7" style="display: none;">
<div class="content">
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>curl -X GET "http://localhost:9200/"</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output should be very similar to the previous execution, except that
the cluster and node names have changed.
Elasticsearch internally uses cluster and node IDs — the cluster and node names
are there for humans.
This means that you can change cluster and node names at any point without
affecting the existing data, but you still need to restart the cluster (so
it’s probably not something you would do very often in your production
environment).</p>
</div>
</div>
</div></div>
</li>
<li>
<p>Let’s take a look at the log files that Elasticsearch produces.</p>
<div class="ulist">
<ul>
<li>
<p>First, list the contents of the log folder.</p>
<div class="openblock solution" id="solution8"><input id="question8" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer8" style="display: none;">
<div class="content">
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>ls -l elasticsearch-7.3.1/logs/</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>There are a lot of different log files in there.
Some file names start with <code>elasticsearch</code> while others start with <code>my_cluster</code>.
Why is that?</p>
<div class="openblock solution" id="solution9"><input id="question9" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer9" style="display: none;">
<div class="content">
<div class="paragraph">
<p>There are different log files with different purposes.
For example, you have index and search slow logs that will be discussed later.
Regardless of the log type, all log files contain the cluster name as a prefix.
<code>elasticsearch</code> was the initial cluster name and then you changed it to
<code>my_cluster</code>, hence multiple files with both prefixes.</p>
</div>
</div>
</div></div>
</li>
</ul>
</div>
</li>
<li>
<p>Elasticsearch is running using the default heap size, which is 1GB.
Let’s change it to 512MB.
Open the <code>elasticsearch-7.3.1/config/jvm.options</code> file using a
text editor of your choice.
Update both initial (<strong>-Xms</strong>) and max (<strong>-Xmx</strong>) heap sizes to 512MB:</p>
<div class="openblock solution" id="solution10"><input id="question10" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer10" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code># Xms represents the initial size of total heap space
# Xmx represents the maximum size of total heap space

-Xms512m
-Xmx512m</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Next, you need to restart the node so your changes can take effect,
so stop the Elasticsearch process again, by hitting <strong>Ctrl+c</strong> in the terminal
tab where Elasticsearch is running.</p>
</li>
<li>
<p>Start Elasticsearch <strong><em>with this exact command</em></strong>:</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>./elasticsearch-7.3.1/bin/elasticsearch -E node.name=node1 -E http.host="localhost","server1"</code></pre>
</div>
</div>
<div class="paragraph">
<p>We will discuss what the <code>http.host</code> setting means later.</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary:</strong> In this lab you started and stopped Elasticsearch and updated some
of the configuration settings.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_1_2">End of Lab 1.2</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_1_3_crud_operations">Lab 1.3: CRUD Operations</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab, you will install Kibana, define the structure of a few
documents, and use Kibana <strong>Console</strong> to perform CRUD operations.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Using Elasticsearch from the command line can be hard and time consuming.
Kibana <strong>Console</strong> allows you to write Elasticsearch commands efficiently.
First, on <code>server1</code>, extract Kibana with the following command:</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>tar -xf kibana-7.3.1-linux-x86_64.tar.gz</code></pre>
</div>
</div>
</li>
<li>
<p>Start Kibana:</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>./kibana-7.3.1-linux-x86_64/bin/kibana --host=0.0.0.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should see the following output:</p>
</div>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>log   [21:11:37.412] [info][listening] Server running at http://0.0.0.0:5601
log   [21:11:37.418] [info][server][Kibana][http] http server running</code></pre>
</div>
</div>
</li>
<li>
<p>Now that Kibana is running, click

  <script language="JavaScript">
      if (window.location.host) {
          document.write('<a target="_blank" href="/app/kibana#/management?_g=()" >here</a>' );
      } else {
          document.write('<a target="_blank" href="http://localhost:5601/app/kibana#/management?_g=()">here</a>')
      }
  </script><a target="_blank" href="http://ec2-52-59-252-50.eu-central-1.compute.amazonaws.com/app/kibana#/management?_g=()">here</a>

to connect.</p>
</li>
<li>
<p>In Kibana, click on the <strong>Dev Tools</strong> button in the side navigation pane to
open the <strong>Console</strong> application: <span class="image"><img src="./Lab Guide_ Elasticsearch Engineer I_files/dev_tools_console.png" alt="dev tools console"></span></p>
</li>
<li>
<p>Kibana has several handy <a href="https://www.elastic.co/guide/en/kibana/7.2/keyboard-shortcuts.html" target="_blank" rel="noopener">keyboard shortcuts</a>
that will make your time spent in <strong>Console</strong> more efficient.
To view the keyboard shortcuts, click on <strong>"Help"</strong> in the upper-right
corner. For example, pressing <strong>Ctrl + Enter</strong> (<strong>Cmd + Enter</strong> on a Mac)
submits a request without having to use your mouse.<br>
<br>
<strong>TIP:</strong> Click on <strong>"Help"</strong> again to close the Help panel.</p>
</li>
<li>
<p>Notice there is a <code>match_all</code> query already written in the <strong>Console</strong>.
Just skip it for now.
We will talk about it later.
Below the <code>match_all</code> query, write a request that returns the node’s basic
information.
Then run it by clicking the green "play" button that appears to
the right of the command (or using the <strong>Ctrl/Cmd + Enter</strong> keyboard shortcut).</p>
<div class="openblock solution" id="solution11"><input id="question11" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer11" style="display: none;">
<div class="content">
<div class="paragraph">
<p>The request below is the same request that you executed with curl in the
terminal in the previous lab.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET /</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Next, you will focus on the dataset.
Imagine a dataset that is row-oriented (e.g. spreadsheet or a traditional
database). How would you write a JSON document based on sample entries that
look like the following? Think about field structure and empty fields:</p>
<table class="tableblock frame-all grid-all fit-content labTable">
<colgroup>
<col>
<col>
<col>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><strong>id</strong></th>
<th class="tableblock halign-left valign-top"><strong>title</strong></th>
<th class="tableblock halign-left valign-top">category</th>
<th class="tableblock halign-left valign-top">date</th>
<th class="tableblock halign-left valign-top">author_first_name</th>
<th class="tableblock halign-left valign-top">author_last_name</th>
<th class="tableblock halign-left valign-top">author_company</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Better query execution</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Engineering</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">July 15, 2015</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Adrien</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Grand</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Elastic</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The Story of Sense</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">May 28, 2015</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boaz</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Leskes</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="openblock solution" id="solution12"><input id="question12" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer12" style="display: none;">
<div class="content">
<div class="paragraph">
<p>Each entry contains a flattened structure, so <strong>author_first_name</strong> is not
specifically related to <strong>author_last_name</strong> and <strong>author_company</strong>. While in
relational databases you can use relations to model it, in
document-oriented stores we preserve structures within a single
document. So the entry could be written as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{
  "id": "1",
  "title": "Better query execution",
  "category": "Engineering",
  "date":"July 15, 2015",
  "author":{
    "first_name": "Adrien",
    "last_name": "Grand",
    "company": "Elastic"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that author is now an object with 3 fields. For the second entry
we can do the same thing to the author structure, but there are also
empty fields. In a document store, empty fields can just be omitted.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{
  "id": "2",
  "title": "The Story of Sense",
  "date":"May 28, 2015",
  "author":{
    "first_name": "Boaz",
    "last_name": "Leskes"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice we do not have <code>category</code> or <code>author.company</code> fields in this document.
Other options would be to index these fields with a <strong>null</strong> value (similar
effect as omitting) or empty strings (completely different effect: the
field exists and its value is an empty string).</p>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>EXAM PREP</strong>: Now that we have defined the documents, let’s index them. Notice that
the <code>id</code> field defined inside the documents is just a normal field like
any other. The actual document <code>_id</code> is defined in the request URL when
you index the documents. Index both JSON documents into the <code>my_blogs</code>
index using their respective ids.</p>
<div class="openblock solution" id="solution13"><input id="question13" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer13" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT my_blogs/_doc/1
{
  "id": "1",
  "title": "Better query execution",
  "category": "Engineering",
  "date":"July 15, 2015",
  "author":{
    "first_name": "Adrien",
    "last_name": "Grand",
    "company": "Elastic"
  }
}
PUT my_blogs/_doc/2
{
  "id": "2",
  "title": "The Story of Sense",
  "date":"May 28, 2015",
  "author":{
    "first_name": "Boaz",
    "last_name": "Leskes"
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>EXAM PREP</strong>: The index operation can also be executed without specifying the <code>_id</code>.
In such a case, you use a <strong>POST</strong> instead of a <strong>PUT</strong> and an <code>_id</code> will
be generated automatically. Index the following document without an id
and check the <code>_id</code> in the response. (Make sure you use <strong>POST</strong>.)</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{
  "id": "57",
  "title": "Phrase Queries: a world without Stopwords",
  "date":"March 7, 2016",
  "category": "Engineering",
  "author":{
    "first_name": "Gabriel",
    "last_name": "Moskovicz"
  }
}</code></pre>
</div>
</div>
<div class="openblock solution" id="solution14"><input id="question14" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer14" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST my_blogs/_doc/
{
  "id": "57",
  "title": "Phrase Queries: a world without Stopwords",
  "date":"March 7, 2016",
  "category": "Engineering",
  "author":{
    "first_name": "Gabriel",
    "last_name": "Moskovicz"
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>EXAM PREP</strong>: Use a <strong>GET</strong> command to retrieve the document with <code>_id</code> of <strong>1</strong> from the
<code>my_blogs</code> index.</p>
<div class="openblock solution" id="solution15"><input id="question15" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer15" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET my_blogs/_doc/1</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>EXAM PREP</strong>: Delete the document with the <code>_id</code> of <strong>1</strong> from the <code>my_blogs</code> index.
Verify it was deleted by trying to <strong>GET</strong> it again.
You should get the following response:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{
  "_index": "my_blogs",
  "_type": "_doc"
  "_id": "1",
  "found": false
}</code></pre>
</div>
</div>
<div class="openblock solution" id="solution16"><input id="question16" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer16" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>DELETE my_blogs/_doc/1
GET my_blogs/_doc/1</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>OPTIONAL</strong>: Perform a bulk operation that executes the following operations
on the <code>my_blogs</code> index from the previous step:</p>
<div class="ulist">
<ul>
<li>
<p>Update document 2: set <code>category</code> to "<strong>Engineering</strong>" and set
<code>author.company</code> to "<strong>Elastic</strong>"</p>
</li>
<li>
<p>Index a new document with <code>_id</code> of 3 that contains the following
fields and values:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{
  "title": "Using Elastic Graph",
  "category": "Engineering",
  "date": "May 25, 2016",
  "author": {
    "first_name": "Mark",
    "last_name": "Harwood",
    "company": "Elastic"
  }
}</code></pre>
</div>
</div>
<div class="openblock solution" id="solution17"><input id="question17" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer17" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST my_blogs/_bulk
{"update": {"_id": 2}}
{"doc": {"category": "Engineering", "author.company":"Elastic"}}
{"index": {"_id": 3}}
{"title":"Using Elastic Graph","category":"Engineering","date":"May 25, 2016","author":{"first_name":"Mark","last_name":"Harwood","company":"Elastic"}}

GET my_blogs/_search</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>OPTIONAL</strong>: Use <code>_mget</code> to retrieve the documents with the ids <strong>2</strong> and <strong>3</strong>
from your <code>my_blogs</code> index and verify your two bulk operations were both
successful.</p>
<div class="openblock solution" id="solution18"><input id="question18" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer18" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET my_blogs/_mget
{
  "docs": [
    {"_id":2},
    {"_id":3}
  ]
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>OPTIONAL</strong>: What happens if you copy and paste the following curl request
to <strong>Console</strong>?</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>curl -X GET "http://localhost:9200/"</code></pre>
</div>
</div>
<div class="openblock solution" id="solution19"><input id="question19" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer19" style="display: none;">
<div class="content">
<div class="paragraph">
<p><strong>Console</strong> is smart enough to understand the syntax and apply the <strong>Console</strong>
format to it.</p>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>OPTIONAL</strong>: Sometimes it is also handy to copy from <strong>Console</strong> to the terminal.
Click the wrench icon close to the play button and select <strong>Copy as cURL</strong>.
Now go back to a terminal and paste it.</p>
</li>
<li>
<p>Finally, delete the <code>my_blogs</code> index.</p>
<div class="openblock solution" id="solution20"><input id="question20" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer20" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>DELETE my_blogs</code></pre>
</div>
</div>
</div>
</div></div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary</strong>: In this lab, you installed Kibana, defined the structure of a few
documents, and used Kibana <strong>Console</strong> to perform CRUD operations.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_1_3">End of Lab 1.3</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_1_4_searching_data">Lab 1.4: Searching Data</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab, you will see how quickly and easily the
Elastic Stack can be used to ingest data from a database, collect
data from log files, and search data.
You will use Logstash to ingest the blogs from a Postgres database into
Elasticsearch and use Filebeat to ingest the web access log data from log files.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>If you completed the previous labs, Elasticsearch and Kibana should be
running in the foreground at two separate tabs.
Next, you are going to start Logstash. Open a new tab and SSH onto <code>server1</code>:</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>ssh server1</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>WARNING</strong>: If you are running the labs in your own environment click <code>Show
answer</code> to see how to load the data.</p>
</div>
<div class="openblock solution" id="solution21"><input id="question21" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer21" style="display: none;">
<div class="content">
<div class="paragraph">
<p>If you are running the labs in your own environment, you don’t need
to install the Postgres database. Just execute the following steps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>First, download and extract Logstash 7.3.1 into the course folder.</p>
</li>
<li>
<p>Then, open a terminal and go to the course folder.</p>
</li>
<li>
<p>Finally, you can use the following command to ingest the data from a <code>csv</code>
file.</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>cat datasets/blogs.csv | logstash-7.3.1/bin/logstash -f datasets/blogs_csv.conf</code></pre>
</div>
</div>
</li>
<li>
<p>Now, you can skip steps 2, 3, and 4 and go directly to step 5.</p>
</li>
</ul>
</div>
</div>
</div></div>
</li>
<li>
<p>The first dataset you are going to ingest into Elasticsearch is the
blogs dataset using Logstash, which has been downloaded already. Extract
Logstash using the following command:</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>tar -xf logstash-7.3.1.tar.gz</code></pre>
</div>
</div>
</li>
<li>
<p>Logstash is going to retrieve the blogs from a SQL database and index
them into your running Elasticsearch instance. This is accomplished
using a Logstash config file that has been provided for you named
<code>blogs_sql.conf</code>. You do not need to modify this file in any way, but here
are its contents. Notice the <code>input</code> is all blogs from a table named
<code>blogs</code>, and the <code>output</code> is an Elasticsearch index named <code>blogs</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>input {
  jdbc {
    jdbc_connection_string =&gt; "jdbc:postgresql://db_server:5432/"
    jdbc_driver_class =&gt; "org.postgresql.Driver"
    jdbc_driver_library =&gt; "/home/elastic/postgresql-42.2.9.jar"
    jdbc_user =&gt; "postgres"
    jdbc_password =&gt; "password"
    statement =&gt; "SELECT * from blogs"
  }
}

filter {
  mutate {
    remove_field =&gt; ["@version", "host", "message", "@timestamp", "id", "tags"]
  }
}

output {
  stdout { codec =&gt; "dots"}
  elasticsearch {
    index =&gt; "blogs"
  }
}</code></pre>
</div>
</div>
</li>
<li>
<p>To run Logstash with this config file, execute the following command:</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>./logstash-7.3.1/bin/logstash -f datasets/blogs_sql.conf</code></pre>
</div>
</div>
<div class="paragraph">
<p>Logstash will take some time to start, so make sure to wait before you
go to the next step. Eventually the output will show dots, and each dot
represents a document being indexed into Elasticsearch. When Logstash is
finished, you will see a "Logstash shut down" message:</p>
</div>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>.......................................................................................................................................................................................................
..[2019-09-23T09:46:31,407][INFO ][logstash.runner          ] Logstash shut down.</code></pre>
</div>
</div>
</li>
<li>
<p>The <code>blogs</code> table in the database contains 1594 entries.
Verify that all those entries are in Elasticsearch.</p>
<div class="openblock solution" id="solution22"><input id="question22" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer22" style="display: none;">
<div class="content">
<div class="paragraph">
<p>You can check that by running a <code>_search</code> on the <code>blogs</code> index with the
following command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should see the following response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{
  "took" : 0,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 1594,
      "relation" : "eq"
    },
    "max_score" : 1.0,
    "hits" : [
      ...
    ]
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Every <code>_search</code> request to Elasticsearch will have a query when executed.
The <code>match_all</code> query is implicit if no query is defined.
Scroll up in <strong>Console</strong> and execute the default <code>match_all</code> query and see that
the results include all indices, because you reached the <code>_search</code> endpoint
without specifying an index.</p>
</li>
<li>
<p>Another option is to execute a <code>_count</code> request instead of a <code>_search</code>.
Try the following example:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_count</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should see a slightly different output.
Because you are executing a count, no hits are returned in the response.
Notice, the <code>match_all</code> query is still implicit.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{
  "count" : 1594,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  }
}</code></pre>
</div>
</div>
</li>
<li>
<p>Now that we have all blogs indexed, let’s see how the search page
works. Access the

  <script language="JavaScript">
      if (window.location.host) {
          document.write('<a target="_blank" href="' + window.location.protocol + '//' + window.location.hostname + ':443' + '" >blogs search page</a> ' );
      } else {
          document.write('<a target="_blank" href="http://localhost:443">blogs search page</a>')
      }
  </script><a target="_blank" href="http://ec2-52-59-252-50.eu-central-1.compute.amazonaws.com:443/">blogs search page</a> 

and play around with it. <span class="image"><img src="./Lab Guide_ Elasticsearch Engineer I_files/plain_search_page.png" alt="plain search page"></span>
Congratulations, the blogs data are in Elasticsearch and the webpage is
working! Make sure to familiarize yourself with different searches,
filtering by category and date, and also paging. Over the next chapters
you are going to learn how to write the queries and aggregations used to
build this application. <span class="image"><img src="./Lab Guide_ Elasticsearch Engineer I_files/search_page_lucene.png" alt="search page lucene"></span></p>
</li>
<li>
<p>Next, let’s index the access logs dataset.
You will use Filebeat to monitor the log files and ingest every line.
Filebeat is downloaded already on <code>server1</code>.
Open a new Terminal tab and extract it using the following command:</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>tar -xf filebeat-7.3.1-linux-x86_64.tar.gz</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>WARNING</strong>: If you are running the labs in your own environment click <code>Show
answer</code> to see how to load the data.</p>
</div>
<div class="openblock solution" id="solution23"><input id="question23" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer23" style="display: none;">
<div class="content">
<div class="paragraph">
<p>If you are running the labs in your own environment, execute the following
steps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>First, download and extract Filebeat 7.3.1 into the course folder.</p>
</li>
<li>
<p>Then, in the <code>datasets</code> folder, extract the
<code>elastic_blog_curated_access_logs.tar.gz</code> file.</p>
</li>
<li>
<p>In the <code>datasets</code> folder, edit the <code>filebeat.yml</code> to use the correct dataset
path.
Set <code>paths</code> under <code>filebeat.inputs</code> to <code>&lt;course_folder&gt;/datasets/elastic_blog_curated_access_logs_server*/*.log</code>.
Make sure to update <code>&lt;course_folder&gt;</code> to the correct path in your environment.</p>
</li>
<li>
<p>Then, open a terminal and go to the course folder.</p>
</li>
<li>
<p>Finally, execute the next step using this terminal tab.</p>
</li>
</ul>
</div>
</div>
</div></div>
</li>
<li>
<p>Run the following command to start Filebeat using the <code>filebeat.yml</code>
configuration file that has been provided.
There will be no output - the command prompt will just hang:</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>./filebeat-7.3.1-linux-x86_64/filebeat -c datasets/filebeat.yml</code></pre>
</div>
</div>
</li>
<li>
<p>There are 1,751,476 events that occurred between <strong>2017-04-01</strong> and
<strong>2017-09-01</strong> across multiple log files. They will be ingested into 3
indices called <code>logs_server1</code>, <code>logs_server2</code> and <code>logs_server3</code>. Use
one of the following commands to check how many files have been ingested so far:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_server1,logs_server2,logs_server3/_count
GET logs_server*/_count</code></pre>
</div>
</div>
<div class="paragraph">
<p>The ingestion might take a few minutes, feel free to go to the next task
before all logs are indexed. When all of the log events are indexed, you
can kill the Filebeat process using <strong>Ctrl+c</strong>.</p>
</div>
</li>
<li>
<p><strong>OPTIONAL</strong>: Now that you have the blogs and access log data in Elasticsearch,
you will use Kibana to analyze it. Click

  <script language="JavaScript">
      if (window.location.host) {
          document.write('<a target="_blank" href="/app/kibana#/management?_g=()" >here</a>' );
      } else {
          document.write('<a target="_blank" href="http://localhost:5601/app/kibana#/management?_g=()">here</a>')
      }
  </script><a target="_blank" href="http://ec2-52-59-252-50.eu-central-1.compute.amazonaws.com/app/kibana#/management?_g=()">here</a>

to connect to Kibana.</p>
</li>
<li>
<p><strong>OPTIONAL</strong>: You need to tell Kibana which indices to analyze, which is
accomplished by defining an <strong>Index Pattern</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>Click on the <strong>Management</strong> link in the left-hand toolbar of Kibana,
then click on <strong>Index Patterns</strong>:
<span class="image"><img src="./Lab Guide_ Elasticsearch Engineer I_files/fundamentals_create_index_pattern1.png" alt="fundamentals create index pattern1"></span></p>
</li>
<li>
<p>Type <code>logs_server*</code> in the <strong>Index pattern</strong> field:
<span class="image"><img src="./Lab Guide_ Elasticsearch Engineer I_files/fundamentals_create_index_pattern2.png" alt="fundamentals create index pattern2"></span></p>
</li>
<li>
<p>Click <strong>Next step</strong> and select <code>@timestamp</code> as the <strong>Time Filter field name</strong>
field:
<span class="image"><img src="./Lab Guide_ Elasticsearch Engineer I_files/fundamentals_create_index_pattern3.png" alt="fundamentals create index pattern3"></span></p>
</li>
<li>
<p>Click the <strong>Create index pattern</strong> button. You should see a page that
shows the 43 fields of the web log documents.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>OPTIONAL</strong>: Now that we have set up our index pattern, let’s visualize the
data.
You will first create a table with the top 5 most popular blogs:</p>
<div class="ulist">
<ul>
<li>
<p>Click on <strong>Visualize</strong> in the left-hand toolbar of Kibana, and then
click the <strong>Create a visualization</strong> button:
<span class="image"><img src="./Lab Guide_ Elasticsearch Engineer I_files/fundamentals_create_viz1.png" alt="fundamentals create viz1"></span></p>
</li>
<li>
<p>Select <strong>Data Table</strong>:
<span class="image"><img src="./Lab Guide_ Elasticsearch Engineer I_files/fundamentals_create_viz2.png" alt="fundamentals create viz2"></span></p>
</li>
<li>
<p>Click on <code>logs_server*</code>. (This is the index pattern we created, which
defines from which indices we will read data.)
<span class="image"><img src="./Lab Guide_ Elasticsearch Engineer I_files/fundamentals_create_viz3.png" alt="fundamentals create viz3"></span></p>
</li>
<li>
<p>Click on <code>Split Rows</code> under <strong>Buckets</strong>:
<span class="image"><img src="./Lab Guide_ Elasticsearch Engineer I_files/fundamentals_create_viz4.png" alt="fundamentals create viz4"></span></p>
</li>
<li>
<p>Select <code>Terms</code> under <strong>Aggregation</strong>:
<span class="image"><img src="./Lab Guide_ Elasticsearch Engineer I_files/fundamentals_create_viz5.png" alt="fundamentals create viz5"></span></p>
</li>
<li>
<p>Select <code>originalUrl.keyword</code> under <strong>Field</strong>:
<span class="image"><img src="./Lab Guide_ Elasticsearch Engineer I_files/fundamentals_create_viz6.png" alt="fundamentals create viz6"></span></p>
</li>
<li>
<p>Click on <strong>Apply changes</strong> (the button that looks like a "play"
button):
<span class="image"><img src="./Lab Guide_ Elasticsearch Engineer I_files/fundamentals_create_viz7.png" alt="fundamentals create viz7"></span></p>
</li>
<li>
<p>Kibana tells you "No results found". That’s because Kibana defaults to
showing the last 15 minutes of data. Our data is older than that. In the
top right, use the Time Picker to change <strong>Last 15 minutes</strong> into <strong>Last 3 years</strong>:
<span class="image"><img src="./Lab Guide_ Elasticsearch Engineer I_files/fundamentals_create_viz8.png" alt="fundamentals create viz8"></span>
You should see the 5 most popular URLs on Elastic’s blog site.</p>
</li>
<li>
<p>Save your visualization by clicking on <strong>Save</strong> in the top-left menu
and name the visualization <strong>"Top 5 Blogs Data Table"</strong>. Then click the
<strong>Confirm Save</strong> button to save the visualization.
<span class="image"><img src="./Lab Guide_ Elasticsearch Engineer I_files/fundamentals_create_viz9.png" alt="fundamentals create viz9" width="50.0%" height="50.0%"></span></p>
</li>
<li>
<p>Click the <strong>"Visualize"</strong> link in the left-hand column of Kibana and you
should see your data table in the list of saved visualizations.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>OPTIONAL</strong>: Let’s build another visualization - a histogram that shows the
distribution of the size of the responses from our website:</p>
<div class="ulist">
<ul>
<li>
<p>Click on <strong>Visualize</strong> and then on the "<strong>+</strong>" button to create a new
visualization:<br>
<span class="image"><img src="./Lab Guide_ Elasticsearch Engineer I_files/fundamentals_create_viz2-1.png" alt="fundamentals create viz2 1"></span></p>
</li>
<li>
<p>Select <strong>Vertical Bar</strong>, then select the
<code>logs_server*</code> index pattern.</p>
</li>
<li>
<p>Under <strong>Buckets</strong> choose <strong>X-Axis</strong></p>
</li>
<li>
<p>Under <strong>Aggregation</strong>, choose <strong>Histogram</strong>.</p>
</li>
<li>
<p>Select <strong>Field: response_size</strong> and enter 5000 for the <strong>Minimum
Interval</strong>.</p>
</li>
<li>
<p>Click <strong>Apply changes</strong> to view the bar chart:
<span class="image"><img src="./Lab Guide_ Elasticsearch Engineer I_files/fundamentals_create_viz2-2.png" alt="fundamentals create viz2 2"></span></p>
</li>
<li>
<p>Save the visualization, giving it the name <strong>"Response Size Bar Chart"</strong></p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>OPTIONAL</strong>: After creating visualizations, you can combine them onto a single
dashboard:</p>
<div class="ulist">
<ul>
<li>
<p>Click on <strong>Dashboard</strong> in the left-hand toolbar of Kibana, then click on
the <strong>Create new dashboard</strong> button:
<span class="image"><img src="./Lab Guide_ Elasticsearch Engineer I_files/fundamentals_create_dashboard1.png" alt="fundamentals create dashboard1"></span></p>
</li>
<li>
<p>Click on the <strong>Add</strong> menu item and add both of the visualizations that
you saved earlier:
<span class="image"><img src="./Lab Guide_ Elasticsearch Engineer I_files/fundamentals_create_dashboard2.png" alt="fundamentals create dashboard2"></span></p>
</li>
<li>
<p>Close the <strong>"Add Panels"</strong> dialog.</p>
</li>
<li>
<p>Feel free to resize the visualizations and move them around:<br>
<span class="image"><img src="./Lab Guide_ Elasticsearch Engineer I_files/fundamentals_create_dashboard3.png" alt="fundamentals create dashboard3"></span></p>
</li>
<li>
<p>Save your dashboard by clicking <strong>Save</strong> in the menu and naming your
dashboard <strong>"Web Logs Dashboard"</strong>. Then click the <strong>Confirm Save</strong> button to save the dashboard.
<span class="image"><img src="./Lab Guide_ Elasticsearch Engineer I_files/fundamentals_create_dashboard4.png" alt="fundamentals create dashboard4" width="50.0%" height="50.0%"></span></p>
</li>
<li>
<p>You should now see your saved dashboard on the <strong>"Dashboard"</strong> page of Kibana, so you can come back and
view the dashboard at any time.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary:</strong> In this lab, you used the Elastic Stack to ingest data from a
database, to collect data from log files, and to search data.
You used Logstash to ingest the blogs from a Postgres database into
Elasticsearch and used Filebeat to ingest the web access log data from log
files.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_1_4">End of Lab 1.4</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_2_1_relevance">Lab 2.1: Relevance</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab, you will familiarize yourself with the Query DSL.
You will write various queries that search documents in the <code>blogs</code> index
using the Search API and the <code>match</code> query.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Write and execute a query that matches all the documents in the blogs
index. You should have a total of 1594 hits:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>"hits": {
  "total": 1594</code></pre>
</div>
</div>
<div class="openblock solution" id="solution24"><input id="question24" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer24" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "query": {
    "match_all": {}
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Add the <code>size</code> parameter to your previous request and set it to <code>100</code>.
You should now see 100 blogs in the results.</p>
<div class="openblock solution" id="solution25"><input id="question25" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer25" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "size": 100,
  "query": {
    "match_all": {}
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>You probably noticed that the <code>content</code> field is large, which makes it
more difficult to navigate the result set. In these cases where the
output is too verbose you can use <code>_source</code> to filter the output, but
keep in mind that this is done in the JSON level and therefore it adds
overhead to Elasticsearch (though it decreases the amount of data
transferred in the network).</p>
<div class="ulist">
<ul>
<li>
<p>You can use <code>_source</code> with <code>excludes</code> pattern to remove the fields you
don’t want. For example, run the query below, which does
not include the content field in the output:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "size": 100,
  "_source": {
    "excludes": ["content"]
  },
  "query": {
    "match_all": {}
  }
}</code></pre>
</div>
</div>
</li>
<li>
<p>You can also use <code>_source</code> with <code>includes</code> pattern to specify the
fields you want. For example, run the following query below, which
includes only the fields <code>author</code> and <code>title</code> in the output:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "size": 100,
  "_source": {
    "includes": ["author","title"]
  },
  "query": {
    "match_all": {}
  }
}</code></pre>
</div>
</div>
</li>
<li>
<p>Alternatively, when just including fields you can list them in an
array without the <code>includes</code> clause. For example, the previous query can
be simplified as follows:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "size": 100,
  "_source": ["author","title"],
  "query": {
    "match_all": {}
  }
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Write and execute a <code>match</code> query for blogs that have the term "<strong>elastic</strong>"
in the <code>title</code> field. Your should get 260 hits:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>"hits": {
    "total": 260,</code></pre>
</div>
</div>
<div class="openblock solution" id="solution26"><input id="question26" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer26" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "query": {
    "match": {
      "title": "elastic"
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Now run a <code>match</code> query for "<strong>elastic stack</strong>" in the <code>title</code> field. Why did
the number of hits go up by adding a term to the <code>match</code> query?</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>"hits": {
    "total": 263,</code></pre>
</div>
</div>
<div class="openblock solution" id="solution27"><input id="question27" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer27" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "query": {
    "match": {
      "title": "elastic stack"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The search returns blogs with "<strong>elastic</strong>" <em>or</em> "<strong>stack</strong>", so there are
additional hits from documents with only "<strong>stack</strong>" in the <code>title</code>.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>Your search for "<strong>elastic stack</strong>" cast a very wide net. The top hits
look good, but the precision is not great for many of the lower-scoring
hits, especially those products that have "<strong>elastic</strong>" in the name but not
"<strong>stack</strong>". Change the <code>operator</code> of your previous <code>match</code> query to <code>and</code>, then
run it again. Notice this increases the precision, as there are now only
70 hits:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>"hits": {
    "total": 70,</code></pre>
</div>
</div>
<div class="openblock solution" id="solution28"><input id="question28" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer28" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "query": {
    "match": {
      "title": {
        "query": "elastic stack",
        "operator": "and"
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Run a query that answers the question: <em>"Which blogs have <strong>performance</strong>
or <strong>optimizations</strong> or <strong>improvements</strong> in the <strong>content</strong> field?"</em> You should get
the following hits:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>"hits": {
    "total": 374,</code></pre>
</div>
</div>
<div class="openblock solution" id="solution29"><input id="question29" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer29" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "query": {
    "match": {
      "content": "performance optimizations improvements"
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>OPTIONAL</strong>: Run a query that answers the question: <em>"Which blogs have a
<strong>content</strong> field that includes <strong>at least 2</strong> of the terms <strong>performance</strong> or
<strong>optimizations</strong> or <strong>improvements</strong>?"</em> You should get the following hits this
time:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>"hits": {
    "total": 82,</code></pre>
</div>
</div>
<div class="openblock solution" id="solution30"><input id="question30" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer30" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "query": {
    "match": {
      "content": {
        "query" : "performance optimizations improvements",
        "minimum_should_match" : 2
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>OPTIONAL</strong>: Let’s analyze the hits from the "<strong>performance optimizations
improvements</strong>" search:</p>
<div class="ulist">
<ul>
<li>
<p>What was the maximum <code>_score</code>?</p>
<div class="openblock solution" id="solution31"><input id="question31" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer31" style="display: none;">
<div class="content">
<div class="paragraph">
<p>The exact max score should be around 9.97</p>
</div>
</div>
</div></div>
</li>
<li>
<p>If you were searching for "<strong>performance optimizations improvements</strong>" to
do some fine tuning in your deployment, do you see any issues with some
of the results from the group of documents with the highest score?</p>
<div class="openblock solution" id="solution32"><input id="question32" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer32" style="display: none;">
<div class="content">
<div class="paragraph">
<p>Most of them talk about improvements in a specific release of the
Elastic Stack. Those blog posts don’t talk about performance tuning a
cluster. We will see how to improve it later.</p>
</div>
</div>
</div></div>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary</strong>: In this lab, you became familiar with the Query DSL.
You wrote various queries that searched documents in the <code>blogs</code> index
using the Search API and the <code>match</code> query.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_2_1">End of Lab 2.1</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_2_2_full_text_queries">Lab 2.2: Full-Text Queries</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab, you will deepen your Query DSL knowledge.
You will write various queries that search documents in the <code>blogs</code> index
using queries like <code>match</code>, <code>match_phrase</code>, and <code>multi-match</code>.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Write a query for each of the following searches:</p>
<div class="ulist">
<ul>
<li>
<p>blogs that have the word "<strong>search</strong>" in their <code>content</code> field.</p>
<div class="openblock solution" id="solution33"><input id="question33" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer33" style="display: none;">
<div class="content">
<div class="paragraph">
<p>There are 432 blogs with the word "<strong>search</strong>" in their <code>content</code> field.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "query": {
    "match": {
      "content": "search"
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>blogs that have "<strong>search</strong>" <em>or</em> "<strong>analytics</strong>" in their <code>content</code> field.</p>
<div class="openblock solution" id="solution34"><input id="question34" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer34" style="display: none;">
<div class="content">
<div class="paragraph">
<p>There are 476 blogs with the terms "<strong>search</strong>" <em>or</em> "<strong>analytics</strong>" in their
<code>content</code> field.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "query": {
    "match": {
      "content": "search analytics"
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>blogs that have "<strong>search</strong>" <em>and</em> "<strong>analytics</strong>" in their <code>content</code> field.</p>
<div class="openblock solution" id="solution35"><input id="question35" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer35" style="display: none;">
<div class="content">
<div class="paragraph">
<p>There are 110 blogs with the terms "<strong>search</strong>" <em>and</em> "<strong>analytics</strong>" in their
<code>content</code> field.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "query": {
    "match": {
      "content": {
        "query": "search analytics",
        "operator": "and"
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
</ul>
</div>
</li>
<li>
<p>Run a <code>match_phrase</code> search for "<strong>search analytics</strong>" in the <code>content</code> field
that returns the top 3 hits. You should get 6 hits total.</p>
<div class="openblock solution" id="solution36"><input id="question36" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer36" style="display: none;">
<div class="content">
<div class="paragraph">
<p>There are 6 blogs with the terms "<strong>search</strong>" and "<strong>analytics</strong>" in the <code>content</code>
field where the term "<strong>analytics</strong>" is one position after the term "<strong>search</strong>".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "size": 3,
  "query": {
    "match_phrase": {
      "content": "search analytics"
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>The phrase "<strong>search and analytics</strong>" is fairly common in the blog
content. Update the previous <code>match_phrase</code> query so that it allows for 1
term (any word - not just "<strong>and</strong>") to appear between "<strong>search</strong>" and
"<strong>analytics</strong>". How many hits do you see now?</p>
<div class="openblock solution" id="solution37"><input id="question37" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer37" style="display: none;">
<div class="content">
<div class="paragraph">
<p>There are 41 blogs with the terms "<strong>search analytics</strong>" in the <code>content</code>
field where the term "<strong>analytics</strong>" is one or two positions after the term
"<strong>search</strong>".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "query": {
    "match_phrase": {
      "content": {
        "query": "search analytics",
        "slop": 1
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Run a query on the <code>blogs</code> index for "<strong>open source</strong>" in the
<code>content</code> field. Then run a second query for "<strong>open source</strong>" on the <code>title</code>
field. Compare the total hits and top hits returned from both queries.
Do the top hits look relevant? Which query had more hits?</p>
<div class="openblock solution" id="solution38"><input id="question38" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer38" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "query": {
    "match": {
      "content": "open source"
    }
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "query": {
    "match": {
      "title": "open source"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Searching for "<strong>open source</strong>" in the <code>title</code> returns hits that look more
relevant, and it also returns far fewer hits.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>Combine the hits of the last two searches by writing a <code>multi_match</code>
query that searches both the <code>content</code> and <code>title</code> fields for "<strong>open source</strong>".
Does the <code>multi_match</code> deliver more or fewer hits? How did this affect the
relevance?</p>
<div class="openblock solution" id="solution39"><input id="question39" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer39" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "query": {
    "multi_match": {
      "query": "open source",
      "fields": [
        "title",
        "content"
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>multi_match</code> delivered many more hits, and the top hits maintained
their relevance.</p>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>EXAM PREP</strong>: Modify your <code>multi_match</code> query by giving the <code>title</code> field a boost of 2.
How does the score of the top hit compare to the previous query without
the boost?</p>
<div class="openblock solution" id="solution40"><input id="question40" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer40" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "query": {
    "multi_match": {
      "query": "open source",
      "fields": [
        "title^2",
        "content"
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The score of the top hit was multiplied by 2.</p>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>EXAM PREP</strong>: Boost affects the score without impacting recall or precision. Remove
the boost and modify your <code>multi_match</code> query to perform a <code>phrase</code> query,
which increases precision (perhaps at the expense of recall). Did the
increase in precision return more or fewer hits?</p>
<div class="openblock solution" id="solution41"><input id="question41" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer41" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "query": {
    "multi_match": {
      "query": "open source",
      "fields": [
        "title",
        "content"
      ],
      "type": "phrase"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The increased precision reduced the number of hits.</p>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>OPTIONAL</strong>: Let’s see what happens when a user misspells their query. Run the
following request, which searches for "<strong>oven sauce</strong>" in the <code>title</code> field.
Notice <code>_source</code> is used to filter the JSON response to show only the
<code>title</code> field of the document:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "_source": "title",
  "query": {
    "match": {
      "title": "oven sauce"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Were there any hits returned?</p>
</div>
<div class="openblock solution" id="solution42"><input id="question42" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer42" style="display: none;">
<div class="content">
<div class="paragraph">
<p>The query does not return any hits.</p>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>EXAM PREP</strong>: Try increasing the recall (perhaps at the expense of precision) by
adding the <code>fuzziness</code> parameter, permitting a maximum of 2 edits per
word. Did the increased recall return more of fewer hits? How relevant
are they?</p>
<div class="openblock solution" id="solution43"><input id="question43" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer43" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "_source": "title",
  "query": {
    "match": {
      "title": {
        "query" : "oven sauce",
        "fuzziness": 2
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There were lots of hits. Many of them do not seem relevant - allowing 2
edits on a 4 letter word with 2 vowels is not great for precision.</p>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>EXAM PREP</strong>: Modify your query so that Elasticsearch uses the <code>auto</code> fuzziness
level.
Were more or fewer hits returned? How relevant are they?</p>
<div class="openblock solution" id="solution44"><input id="question44" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer44" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "_source": "title",
  "query": {
    "match": {
      "title": {
        "query" : "oven sauce",
        "fuzziness": "auto"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are fewer hits, and they seem more relevant than the majority of
hits from the previous request.</p>
</div>
</div>
</div></div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary:</strong> In this lab, you deepened your Query DSL knowledge.
You wrote various queries that searched documents in the <code>blogs</code> index
using queries like <code>match</code>, <code>match_phrase</code>, and <code>multi-match</code>.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_2_2">End of Lab 2.2</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_2_3_combining_queries">Lab 2.3: Combining Queries</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab, you will learn how to logically combine multiple query
clauses to query multiple fields effectively and to manage precision and recall
to refine or broaden the query scope.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>In one of the previous labs you wrote a query that answers the question:
<em>"Which blogs have a <strong>content</strong> field that includes <strong>at least 2</strong> of the terms
<strong>performance</strong> or <strong>optimizations</strong> or <strong>improvements</strong>?"</em>
Write a query that answers the same question, but using <code>bool</code> instead of
<code>match</code>.
You should get the following hits:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>"hits": {
    "total": 82,</code></pre>
</div>
</div>
<div class="openblock solution" id="solution45"><input id="question45" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer45" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "query": {
    "bool": {
      "should": [
        {
          "match": {
            "content": "performance"
          }
        },
        {
          "match": {
            "content": "optimizations"
          }
        },
        {
          "match": {
            "content": "improvements"
          }
        }
      ],
      "minimum_should_match": 2
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>EXAM PREP</strong>: It looks like releases usually come with performance optimizations and
improvements. Assuming that you are not interested in upgrading your deployment,
change the previous query (the <code>should</code> version) so that it <code>must_not</code> contain
"<strong>released</strong>" or "<strong>releases</strong>" or "<strong>release</strong>" in the <code>title</code> field. Your top hits look
better now, and notice the number of total hits dropping down to 47.</p>
<div class="openblock solution" id="solution46"><input id="question46" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer46" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "query": {
    "bool": {
      "should": [
        {
          "match": {
            "content": "performance"
          }
        },
        {
          "match": {
            "content": "optimizations"
          }
        },
        {
          "match": {
            "content": "improvements"
          }
        }
      ],
      "minimum_should_match": 2,
      "must_not": [
        {
          "match": {
            "title": "release releases released"
          }
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>EXAM PREP</strong>: In the previous query, let’s say you are more interested in blogs about
Elasticsearch. How could you rank the results so that the documents that
mention "<strong>elasticsearch</strong>" in the <code>title</code> score higher?
(<em>TIP: you must have two separate <code>should</code> clauses.
One clause with a <code>minimum_should_match</code> will work like a <code>must</code>.
The other clause will influence the score.</em>)</p>
<div class="openblock solution" id="solution47"><input id="question47" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer47" style="display: none;">
<div class="content">
<div class="paragraph">
<p>To implement this new requirement you need to change the structure of the
current query.
As said in the tip, you must have two separate <code>should</code> clauses.
Move the original <code>should</code> clause (the one with a <code>minimum_should_match</code>)
inside a <code>must</code>.
To have a logical clause inside another logical clause, you need to use an
inner <code>bool</code> query.
Then, add the new <code>should</code> clause that will influence the score to the main
<code>bool</code> query.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "bool": {
            "should": [
              {
                "match": {
                  "content": "performance"
                }
              },
              {
                "match": {
                  "content": "optimizations"
                }
              },
              {
                "match": {
                  "content": "improvements"
                }
              }
            ],
            "minimum_should_match": 2
          }
        }
      ],
      "must_not": [
        {
          "match": {
            "title": "release releases released"
          }
        }
      ],
      "should": [
        {
          "match": {
            "title": "elasticsearch"
          }
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>OPTIONAL</strong>: If you are curious about what your query actually means when
executed in Lucene, you can use the <code>_validate</code> API along with the <code>rewrite</code>
parameter as shown below.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_validate/query?rewrite=true
{...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The validate API allows a user to validate a potentially expensive query
without executing it.
You can read more about it <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-validate.html" target="_blank" rel="noopener">here</a>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use the header above to compare the <code>match</code> and <code>should</code> versions of the
first step in this lab (copied below). Are they the same query?</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "query": {
    "match": {
      "content": {
        "query" : "performance optimizations improvements",
        "minimum_should_match" : 2
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "query": {
    "bool": {
      "should": [
        {
          "match": {
            "content": "performance"
          }
        },
        {
          "match": {
            "content": "optimizations"
          }
        },
        {
          "match": {
            "content": "improvements"
          }
        }
      ],
      "minimum_should_match": 2
    }
  }
}</code></pre>
</div>
</div>
<div class="openblock solution" id="solution48"><input id="question48" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer48" style="display: none;">
<div class="content">
<div class="paragraph">
<p>Yes, they are same query when executed at the Lucene level.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_validate/query?rewrite=true
{
  "query": {
    "match": {
      "content": {
        "query" : "performance optimizations improvements",
        "minimum_should_match" : 2
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "failed" : 0
  },
  "valid" : true,
  "explanations" : [
    {
      "index" : "blogs",
      "valid" : true,
      "explanation" : "(content:performance content:optimizations content:improvements)~2"
    }
  ]
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary:</strong> In this lab, you learned how to logically combine multiple query
clauses to query multiple fields effectively and to manage precision and recall
to refine or broaden the query scope.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_2_3">End of Lab 2.3</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_2_4_implementing_a_search_page">Lab 2.4: Implementing a Search Page</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab, you will learn how to implement some features that
users would expect to find in any good search application, which might
enable them to explore and retrieve the documents most relevant to their
needs using correct ergonomics and efficient use of system resources.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Imagine the blogs search page is implemented using the <code>multi_match</code> query
below and that a user is searching for "<strong>meetups</strong>".</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "multi_match": {
            "query": "meetups",
            "fields": ["title", "content"]
          }
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
</li>
<li>
<p>Now, imagine the user selected <strong>News</strong> on the left side bar. Update the
query above to add the user selection. The result should be 5 documents.
<span class="image"><img src="./Lab Guide_ Elasticsearch Engineer I_files/queries_filter_news.png" alt="queries filter news"></span></p>
<div class="openblock solution" id="solution49"><input id="question49" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer49" style="display: none;">
<div class="content">
<div class="paragraph">
<p>The left side selection should be implemented inside a <code>filter</code>.
If you implement a <code>match</code> query on the <code>category</code> field, it will work for
<strong>News</strong>, but it might not work for compound categories.
Therefore, the correct solution is to use the <code>keyword</code> field, which in this
particular case is <code>category.keyword</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "multi_match": {
            "query": "meetups",
            "fields": ["title", "content"]
          }
        }
      ],
      "filter": {
        "match": {
          "category.keyword": "News"
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>EXAM PREP</strong>: Next, imagine the user also selected <strong>Culture</strong> on the left side bar.
Update the query above to add the new user selection.
The result should be 7 documents. (<em>TIP: you need to implement an OR logic
combined with an AND logic. Which boolean query allows you to run ORs?</em>)</p>
<div class="openblock solution" id="solution50"><input id="question50" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer50" style="display: none;">
<div class="content">
<div class="paragraph">
<p>The solution is not straight forward.
Adding a clause to the filter has an AND behavior and returns no results.
To create a proper OR behavior, all you need is a <code>should</code> with both clauses
(the default <code>minimum_should_match</code> is 1).
Then, because this is a <strong>yes</strong> or <strong>no</strong> question, you should make use of filters.
Finally, to add a <code>should</code> clause inside a <code>filter</code> clause, you need to add
a <code>bool</code> clause in between.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "multi_match": {
            "query": "meetups",
            "fields": [
              "title",
              "content"
            ]
          }
        }
      ],
      "filter": [
        {
          "bool": {
            "should": [
              {
                "match": {
                  "category.keyword": "News"
                }
              },
              {
                "match": {
                  "category.keyword": "Culture"
                }
              }
            ]
          }
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>You might be thinking: <em>"Is this the best solution for such a common problem?"</em>.
The answer is no.
There is a better way to implement the query above.
There is a set of <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/term-level-queries.html" target="_blank" rel="noopener">Term Level Queries</a> that don’t
perform analysis.
The <strong>Terms Query</strong> is a great option to implement faceting filters.
The query would then look like the one below:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "multi_match": {
            "query": "meetups",
            "fields": [
              "title",
              "content"
            ]
          }
        }
      ],
      "filter": [
        {
          "terms": {
            "category.keyword": [
              "News",
              "Culture"
            ]
          }
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
</li>
<li>
<p><strong>EXAM PREP</strong>: Next, imagine the user adds a date to the search, so only blogs published
in <strong>2017</strong> are returned.
Update the query above to only return blogs published in <strong>2017</strong>.
The result should be 2 documents.</p>
<div class="openblock solution" id="solution51"><input id="question51" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer51" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "multi_match": {
            "query": "meetups",
            "fields": [
              "title",
              "content"
            ]
          }
        }
      ],
      "filter": [
        {
          "terms": {
            "category.keyword": [
              "News",
              "Culture"
            ]
          }
        },
        {
          "range": {
            "publish_date": {
              "gte": "2017-01-01",
              "lt": "2018-01-01"
            }
          }
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Write a <code>match_phrase</code> query that searches for "<strong>elastic stack</strong>" in the
<code>content</code> field. Sort the results so that they are returned from newest
to oldest (based on the <code>publish_date</code> field).</p>
<div class="openblock solution" id="solution52"><input id="question52" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer52" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "query": {
    "match_phrase": {
      "content": {
        "query" : "elastic stack"
      }
    }
  },
  "sort": [
    {
      "publish_date": {
        "order": "desc"
      }
    }
  ]
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>EXAM PREP</strong>: Modify your previous query so that the results are sorted first by
author name ascending, and then from newest to oldest.</p>
<div class="openblock solution" id="solution53"><input id="question53" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer53" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "query": {
    "match_phrase": {
      "content": {
        "query" : "elastic stack"
      }
    }
  },
  "sort": [
    {
      "author.keyword": {
        "order": "asc"
      }
    },
    {
      "publish_date": {
        "order": "desc"
      }
    }
  ]
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Our web application only shows three blog hits at a time. Modify the
previous query so that it only returns the top 3 hits.</p>
<div class="openblock solution" id="solution54"><input id="question54" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer54" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "size": 3,
  "query": {
    "match_phrase": {
      "content": {
        "query" : "elastic stack"
      }
    }
  },
  "sort": [
    {
      "author.keyword": {
        "order": "asc"
      }
    },
    {
      "publish_date": {
        "order": "desc"
      }
    }
  ]
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>EXAM PREP</strong>: Suppose a user clicks on page 4 of the search results from your
previous query. Write a query that returns the 3 hits of page 4.</p>
<div class="openblock solution" id="solution55"><input id="question55" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer55" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "from": 9,
  "size": 3,
  "query": {
    "match_phrase": {
      "content": {
        "query" : "elastic stack"
      }
    }
  },
  "sort": [
    {
      "author.keyword": {
        "order": "asc"
      }
    },
    {
      "publish_date": {
        "order": "desc"
      }
    }
  ]
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>EXAM PREP</strong>: Modify the previous query to implement highlighting on the
<code>content</code> field.
It should enclose the matched search terms with a <code>&lt;mark&gt;</code> HTML tag.</p>
<div class="openblock solution" id="solution56"><input id="question56" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer56" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "from": 9,
  "size": 3,
  "query": {
    "match_phrase": {
      "content": {
        "query" : "elastic stack"
      }
    }
  },
  "sort": [
    {
      "author.keyword": {
        "order": "asc"
      }
    },
    {
      "publish_date": {
        "order": "desc"
      }
    }
  ],
  "highlight": {
    "fields": {
      "content" : {}
    },
    "pre_tags": ["&lt;mark&gt;"],
    "post_tags": ["&lt;/mark&gt;"]
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary:</strong> You have implemented most of the search features used in our
blog search web application! In this lab, you controlled the
presentation of search hits using sort, pagination and highlighting, as
well as filtering results by category.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_2_4">End of Lab 2.4</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_3_1_metrics_aggregations">Lab 3.1: Metrics Aggregations</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab, you will become familiar with writing metrics
aggregations to answer some questions about the <code>logs_server*</code> indices.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>What is the runtime of the fastest request?
(<em>*TIP:* set <code>size</code> to 0.</em>)</p>
<div class="openblock solution" id="solution57"><input id="question57" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer57" style="display: none;">
<div class="content">
<div class="paragraph">
<p>It is 0.0 milliseconds.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_server*/_search
{
  "size": 0,
  "aggs": {
    "fastest_request_time": {
      "min": {
        "field": "runtime_ms"
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>What is the runtime of the slowest request?</p>
<div class="openblock solution" id="solution58"><input id="question58" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer58" style="display: none;">
<div class="content">
<div class="paragraph">
<p>It is 59756.0 milliseconds.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_server*/_search
{
  "size": 0,
  "aggs": {
    "slowest_request_time": {
      "max": {
        "field": "runtime_ms"
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>You can use the <code>stats</code> aggregation when you want to calculate all the main
metrics (min, max, avg, and sum).
Update the aggs above to use <code>stats</code> instead of <code>max</code>.
What is the average runtime?</p>
<div class="openblock solution" id="solution59"><input id="question59" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer59" style="display: none;">
<div class="content">
<div class="paragraph">
<p>The average runtime is approximately 361.64 milliseconds.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_server*/_search
{
  "size": 0,
  "aggs": {
    "request_time_stats": {
      "stats": {
        "field": "runtime_ms"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want even more details, you can use the <code>extended_stats</code> aggs to
calculate <code>sum_of_squares</code>, <code>variance</code>, <code>std_deviation</code>, and
<code>std_deviation_bounds</code>.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>Median often is a better option than average, as a single result can
significantly impact the average.
Calculate the median runtime and verify if 95% of the requests take less
than 500 milliseconds.</p>
<div class="openblock solution" id="solution60"><input id="question60" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer60" style="display: none;">
<div class="content">
<div class="paragraph">
<p>The median is calculated using the <code>percentile</code> aggregation.
The median runtime is approximately 103.510 milliseconds, which is much
lower than the average.
And 95% of the requests take less than approximately 684.404 milliseconds.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_server*/_search
{
  "size": 0,
  "aggs": {
    "runtime_median_and_95": {
      "percentiles": {
        "field": "runtime_ms",
        "percents": [
          50,
          95
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Assuming 500 milliseconds is our runtime goal, what percentage of the
requests is within this time?</p>
<div class="openblock solution" id="solution61"><input id="question61" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer61" style="display: none;">
<div class="content">
<div class="paragraph">
<p>The <code>percentile_ranks</code> aggregations allows you to provide a value and
get back the percentile it represents.
Approximately 94.3% of the requests take 500 milliseconds or less.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_server*/_search
{
  "size": 0,
  "aggs": {
    "runtime_goal": {
      "percentile_ranks": {
        "field": "runtime_ms",
        "values": [
          500
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>How many distinct URL requests were logged in the <code>logs_server*</code>
indices? URL requests are indexed in the <code>originalUrl</code> field. You should
get around 37,000 as the result.</p>
<div class="openblock solution" id="solution62"><input id="question62" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer62" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_server*/_search
{
  "size": 0,
  "aggs": {
    "my_url_value_count": {
      "cardinality": {
        "field": "originalUrl.keyword"
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>EXAM PREP</strong>: Add a query that limits the scope of your aggregation in the
previous step to only documents that contain the term "<strong>elastic</strong>" in the
<code>originalUrl</code> field. You should get around 4,500 as the result.</p>
<div class="openblock solution" id="solution63"><input id="question63" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer63" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_server*/_search
{
  "size": 0,
  "query": {
    "match": {
      "originalUrl": "elastic"
    }
  },
  "aggs": {
    "my_url_value_count": {
      "cardinality": {
        "field": "originalUrl.keyword"
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary:</strong> In this lab, you became familiar with writing metrics
aggregations to answer some questions.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_3_1">End of Lab 3.1</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_3_2_bucket_aggregations">Lab 3.2: Bucket Aggregations</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab, you will become familiar with writing bucket
aggregations to answer some questions.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>How many requests are there for each of the 6 <code>status_code</code> values?
(<em>*TIP:* set size to 0.</em>)</p>
<div class="openblock solution" id="solution64"><input id="question64" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer64" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_server*/_search
{
  "size": 0,
  "aggs": {
    "status_code_buckets": {
      "terms": {
        "field": "status_code"
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>EXAM PREP</strong>: A <code>terms</code> aggregation is sorted by <code>doc_count</code> by default.
Modify your previous search so that its <code>terms</code> are sorted alphabetically.</p>
<div class="openblock solution" id="solution65"><input id="question65" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer65" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_server*/_search
{
  "size": 0,
  "aggs": {
    "status_code_buckets": {
      "terms": {
        "field": "status_code",
        "order": {
          "_key": "asc"
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>The following query has 165 hits. Our search page has a UI that allows
users to filter those hits by category, and notice that our UI shows how
many hits belong to each category. Add an aggregation to the following
query that returns the number of hits in each category.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "query": {
    "bool": {
      "must": {
        "multi_match": {
          "query": "open source",
          "fields": [
            "title^2",
            "content"
          ],
          "type": "phrase"
        }
      }
    }
  },
  "highlight": {
    "fields": {
      "title": {},
      "content": {}
    },
    "require_field_match": false,
    "pre_tags": [
      "&lt;mark&gt;"
    ],
    "post_tags": [
      "&lt;/mark&gt;"
    ]
  }
}</code></pre>
</div>
</div>
<div class="openblock solution" id="solution66"><input id="question66" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer66" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "query": {
    "bool": {
      "must": {
        "multi_match": {
          "query": "open source",
          "fields": [
            "title^2",
            "content"
          ],
          "type": "phrase"
        }
      }
    }
  },
  "highlight": {
    "fields": {
      "title": {},
      "content": {}
    },
    "require_field_match": false,
    "pre_tags": [
      "&lt;mark&gt;"
    ],
    "post_tags": [
      "&lt;/mark&gt;"
    ]
  },
  "aggs": {
    "category_terms": {
      "terms": {
        "field": "category.keyword",
        "size": 10
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Write an aggregation that returns the <code>response_size</code> distribution for the
logs indices with an interval of 10000.</p>
<div class="openblock solution" id="solution67"><input id="question67" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer67" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_server*/_search
{
  "size": 0,
  "aggs": {
    "runtime_histogram": {
      "histogram": {
        "field": "response_size",
        "interval": 10000
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>EXAM PREP</strong>: Notice that some of the returned buckets have few documents. Update the
aggregation to exclude the buckets that have less than 1000 documents.</p>
<div class="openblock solution" id="solution68"><input id="question68" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer68" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_server*/_search
{
  "size": 0,
  "aggs": {
    "runtime_histogram": {
      "histogram": {
        "field": "response_size",
        "interval": 10000,
        "min_doc_count": 1000
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>How many log requests are there for each week?</p>
<div class="openblock solution" id="solution69"><input id="question69" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer69" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_server*/_search
{
  "size": 0,
  "aggs": {
    "logs_by_week": {
      "date_histogram": {
        "field": "@timestamp",
        "calendar_interval": "week"
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Modify the previous aggregation to return how many requests per minute.
What happened?</p>
<div class="openblock solution" id="solution70"><input id="question70" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer70" style="display: none;">
<div class="content">
<div class="paragraph">
<p>The request looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_server*/_search
{
  "size": 0,
  "aggs": {
    "logs_by_week": {
      "date_histogram": {
        "field": "@timestamp",
        "interval": "minute"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Elasticsearch returns the following error:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{
  "type": "too_many_buckets_exception",
  "reason": "Trying to create too many buckets. Must be less than or equal to: [10000] but was [161112]. This limit can be set by changing the [search.max_buckets] cluster level setting.",
  "max_buckets": 10000
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It means the requested aggregation would generate too many buckets and
put the cluster in danger.
Therefore, Elasticsearch will not execute it.
The maximum number of buckets allowed in a single response is limited by a
dynamic cluster setting named <code>search.max_buckets</code>.
As you can see in the response, it defaults to 10000 and requests that try to
return more than the limit fail with an exception.</p>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>OPTIONAL:</strong> Congratulations, you have answered a lot of questions
using aggregations in Elasticsearch. Now you will render an aggregation
in Kibana:</p>
<div class="ulist">
<ul>
<li>
<p>Click on the <strong>Visualize</strong> icon on the left hand side bar</p>
</li>
<li>
<p>Click on <strong>+</strong> to create a visualization</p>
</li>
<li>
<p>Click on the <strong>Vertical Bar</strong> icon</p>
</li>
<li>
<p>Click on the hyperlinked index pattern <code>logs_server*</code></p>
</li>
<li>
<p>In the <strong>Buckets</strong> control select Buckets type X-Axis</p>
</li>
<li>
<p>In the <strong>Aggregation</strong> drop-down select Terms (you may have to scroll down)</p>
</li>
<li>
<p>In the <strong>Field</strong> drop-down select <code>status_code</code></p>
</li>
<li>
<p>Set <strong>Size</strong> to 6</p>
</li>
<li>
<p>Click on <strong>the Apply Changes</strong> icon and you should see the following bar
chart (make sure your time range is "Last 5 years"):
<span class="image"><img src="./Lab Guide_ Elasticsearch Engineer I_files/aggs-kibana1.png" alt="aggs kibana1"></span></p>
</li>
<li>
<p>Now Click on <strong>Metrics &amp; Axes</strong></p>
</li>
<li>
<p>In the Y-Axes control click on <strong>LeftAxis-1</strong></p>
</li>
<li>
<p>Change <strong>Scale Type</strong> from <strong>linear</strong> to <strong>log</strong> and click <strong>Apply Changes</strong> again to
improve visibility of the smaller buckets:
<span class="image"><img src="./Lab Guide_ Elasticsearch Engineer I_files/aggs-kibana2.png" alt="aggs kibana2"></span></p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary:</strong> In this lab, you became familiar with writing bucket aggregations to
answer some questions.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_3_2">End of Lab 3.2</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_3_3_combining_aggregations">Lab 3.3: Combining Aggregations</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab, you will become familiar with writing aggregations
that combine multiple metrics and/or bucket aggregations to answer some
questions.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>How many blog requests are there for each week?
(<em>*TIP:* set <code>size</code> to 0.</em>)</p>
<div class="openblock solution" id="solution71"><input id="question71" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer71" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_server*/_search
{
  "size": 0,
  "aggs": {
    "logs_by_week": {
      "date_histogram": {
        "field": "@timestamp",
        "calendar_interval": "week"
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>EXAM PREP</strong>: For each week of blog requests, how many requests were received from
each of the 6 values of <code>status_code</code>?</p>
<div class="openblock solution" id="solution72"><input id="question72" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer72" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_server*/_search
{
  "size": 0,
  "aggs": {
    "logs_by_week": {
      "date_histogram": {
        "field": "@timestamp",
        "calendar_interval": "week"
      },
      "aggs": {
        "status_code_buckets": {
          "terms": {
            "field": "status_code"
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>EXAM PREP</strong>: What is the median runtime for each <code>status_code</code>?
(<strong>TIP:</strong> This is not per week.)</p>
<div class="openblock solution" id="solution73"><input id="question73" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer73" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_server*/_search
{
  "size": 0,
  "aggs": {
    "status_code_buckets": {
      "terms": {
        "field": "status_code"
      },
      "aggs": {
        "runtime": {
          "percentiles": {
            "field": "runtime_ms",
            "percents": [50]
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>EXAM PREP</strong>: What are the top 3 URLs accessed from each of the top 20 cities?
Analyze the results closely and notice there is a common set of URLs for
most cities.</p>
<div class="openblock solution" id="solution74"><input id="question74" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer74" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_server*/_search
{
  "size": 0,
  "aggs": {
    "top_cities": {
      "terms": {
        "field": "geoip.city_name.keyword",
        "size": 20
      },
      "aggs": {
        "top_urls": {
          "terms": {
            "field": "originalUrl.keyword",
            "size": 3
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Change the <code>terms</code> aggregation of the top 3 URLs to a <code>significant_terms</code>
aggregation and compare the results of the two different queries. Notice
how the URLs have changed to be less generic and more specific topics.</p>
<div class="openblock solution" id="solution75"><input id="question75" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer75" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_server*/_search
{
  "size": 0,
  "aggs": {
    "top_cities": {
      "terms": {
        "field": "geoip.city_name.keyword",
        "size": 20
      },
      "aggs": {
        "top_urls": {
          "significant_terms": {
            "field": "originalUrl.keyword",
            "size": 3
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>EXAM PREP</strong>: Write a query that searches for "<strong>elasticsearch siem</strong>" in the
<code>content</code> field and use this scope of documents to list only the <code>title</code> field
of the top three blogs of each one of the top 5 categories.</p>
<div class="openblock solution" id="solution76"><input id="question76" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer76" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "size": 0,
  "query": {
    "match": {
      "content": "elasticsearch siem"
    }
  },
  "aggs": {
    "top5_categories": {
      "terms": {
        "field": "category.keyword",
        "size": 5
      },
      "aggs": {
        "top3_blogs": {
          "top_hits": {
            "size": 3,
            "_source": ["title"]
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary:</strong> In this lab, you became familiar with writing aggregations
that combine multiple metrics and/or bucket aggregations to answer some
questions.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_3_3">End of Lab 3.3</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_4_1_what_is_a_mapping">Lab 4.1: What is a Mapping?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab, you will become familiar with how to read an index
mapping and how to define your own mappings.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Let’s start this lab by analyzing the dynamic mapping behavior. Index
the following sample document into a temporary index named <code>tmp_index</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT tmp_index/_doc/1
{
  "@timestamp": "2019-07-08T03:00:00.000Z",
  "ip" : "105.32.126.44",
  "bytes" : 8261,
  "coordinates" : {
    "lat" : 30.42769722,
    "lon" : -87.70082
  }
}</code></pre>
</div>
</div>
</li>
<li>
<p>View the mappings of <code>tmp_index</code> that were dynamically created.</p>
<div class="openblock solution" id="solution77"><input id="question77" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer77" style="display: none;">
<div class="content">
<div class="paragraph">
<p>The output of:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET tmp_index/_mappings</code></pre>
</div>
</div>
<div class="paragraph">
<p>should return the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{
  "tmp_index" : {
    "mappings" : {
      "properties" : {
        "@timestamp" : {
          "type" : "date"
        },
        "bytes" : {
          "type" : "long"
        },
        "coordinates" : {
          "properties" : {
            "lat" : {
              "type" : "float"
            },
            "lon" : {
              "type" : "float"
            }
          }
        },
        "ip" : {
          "type" : "text",
          "fields" : {
            "keyword" : {
              "type" : "keyword",
              "ignore_above" : 256
            }
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>The <code>@timestamp</code> field was mapped as type <code>date</code>, <code>bytes</code> as type <code>long</code>,
<code>coordinates</code> as an <code>object</code> with two properties <code>lat</code> and <code>lon</code> of type
<code>float</code>, and finally <code>ip</code> was mapped as type <code>text</code> (which will be discussed
in the next lesson).</p>
<div class="paragraph">
<p>Which of the fields' mappings could be improved?</p>
</div>
<div class="openblock solution" id="solution78"><input id="question78" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer78" style="display: none;">
<div class="content">
<div class="paragraph">
<p><code>@timestamp</code> and <code>bytes</code> have probably been mapped correctly, but <code>coordinates</code>
could be better mapped as <code>geo_point</code> and <code>ip</code> could be better mapped as <code>ip</code>.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>To illustrate why the mapping of the <code>ip</code> field needs to be improved, execute
the following query to find documents with an IP within the <code>105.32.0.0/16</code>
range:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET tmp_index/_search
{
  "query": {
    "term": {
      "ip": "105.32.0.0/16"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Even though the IP in our document falls within this range, the document is not
a match. This is because it has been mapped as type <code>text</code> instead of <code>ip</code>.
Let’s improve the mapping!</p>
</div>
</li>
<li>
<p><strong>EXAM PREP</strong>: Create a new index <code>my_logs</code> with the <code>ip</code> field mapped explicitly as type
<code>ip</code>.</p>
<div class="openblock solution" id="solution79"><input id="question79" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer79" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT my_logs
{
  "mappings": {
    "properties": {
      "ip": {
        "type": "ip"
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Index the following document with the same IP as before into <code>my_logs</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST my_logs/_doc
{
  "ip" : "105.32.126.44"
}</code></pre>
</div>
</div>
</li>
<li>
<p>Execute the query again, now against the new index. The document should now
be returned as a hit:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET my_logs/_search
{
  "query": {
    "term": {
      "ip": "105.32.0.0/16"
    }
  }
}</code></pre>
</div>
</div>
</li>
<li>
<p>Let’s also fix the <code>location</code> field. To see why, execute the following
<code>geo_distance</code> query on the <code>tmp_index</code> index.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET tmp_index/_search
{
  "query": {
    "geo_distance": {
      "distance": "200km",
      "coordinates": {
        "lat": 30,
        "lon": -87
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>What is the result?</p>
</div>
<div class="openblock solution" id="solution80"><input id="question80" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer80" style="display: none;">
<div class="content">
<div class="paragraph">
<p>The query fails, with the following message: <code>"failed to find geo_point field
[coordinates]"</code>.
The <code>coordinates</code> field is not mapped as a <code>geo_point</code>.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>Add a new field <code>coordinates</code> to the mapping of the <code>my_logs</code> index, and map
the field as type <code>geo_point</code>.</p>
<div class="openblock solution" id="solution81"><input id="question81" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer81" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT my_logs/_mapping
{
  "properties": {
    "coordinates": {
      "type": "geo_point"
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Now that the <code>ip</code> and <code>coordinates</code> fields have been fixed, let’s index
the same document to <code>my_logs</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT my_logs/_doc/1
{
  "@timestamp": "2019-07-08T03:00:00.000Z",
  "ip" : "105.32.126.44",
  "bytes" : 8261,
  "coordinates" : {
    "lat" : 30.42769722,
    "lon" : -87.70082
  }
}</code></pre>
</div>
</div>
</li>
<li>
<p>To validate that the <code>coordinates</code> field is now mapped correctly, run the
previous <code>geo_distance</code> query again, but now against the new index:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET my_logs/_search
{
  "query": {
    "geo_distance": {
      "distance": "200km",
      "coordinates": {
        "lat": 30,
        "lon": -87
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The document should now be returned as a hit.</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary:</strong> In this lab, you became familiar with how to read an index mapping
and how to define your own mappings.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_4_1">End of Lab 4.1</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_4_2_text_and_keyword_strings">Lab 4.2: Text and Keyword Strings</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab you will take a close look at how strings are mapped dynamically and learn how different analyzers work.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Let’s start this lab by indexing this sample document into the temporary index <code>tmp_index</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT tmp_index/_doc/2
{
    "country_name": "United Kingdom"
}</code></pre>
</div>
</div>
</li>
<li>
<p>How has this field been dynamically mapped by Elasticsearch?</p>
<div class="openblock solution" id="solution82"><input id="question82" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer82" style="display: none;">
<div class="content">
<div class="paragraph">
<p>The output of:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET tmp_index/_mappings</code></pre>
</div>
</div>
<div class="paragraph">
<p>shows that this field has been mapped as a <code>text</code> field, with a multifield
called <code>keyword</code> of type <code>keyword</code>.
This is how Elasticsearch will dynamically map any string by default.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>"country_name" : {
  "type" : "text",
  "fields" : {
    "keyword" : {
      "type" : "keyword",
      "ignore_above" : 256
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>To see the different behavior of the <code>text</code> and <code>keyword</code> fields, try to query both the <code>country_name</code> and the <code>country_name.keyword</code> field for the search term <code>kingdom</code>. Which of the two queries do you expect to return a hit?</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET tmp_index/_search
{
  "query": {
    "match": {
      "country_name": "kingdom"
    }
  }
}

GET tmp_index/_search
{
  "query": {
    "match": {
      "country_name.keyword": "kingdom"
    }
  }
}</code></pre>
</div>
</div>
<div class="openblock solution" id="solution83"><input id="question83" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer83" style="display: none;">
<div class="content">
<div class="paragraph">
<p>The second query returns no hits. You can only query <code>keyword</code> field for exact values.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>How would you have to rewrite the query so it returns the sample document you indexed earlier?</p>
<div class="openblock solution" id="solution84"><input id="question84" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer84" style="display: none;">
<div class="content">
<div class="paragraph">
<p>The <code>keyword</code> field is not analyzed. As a result, you can only find this document if you use the exact string <code>United Kingdom</code> (exactly as it occurs in the sample document) as the query string, with all the exact capitalization and whitespaces:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET tmp_index/_search
{
  "query": {
    "match": {
      "country_name.keyword": "United Kingdom"
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>To help you understand how text analysis works, Elasticsearch provides an
<code>_analyze</code> API.
For example, to see what would happen to the string <code>"United Kingdom"</code> if you
applied the <code>standard</code> analyzer, you can use:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _analyze
{
  "text": "United Kingdom",
  "analyzer": "standard"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>What two tokens are the output of the request above?</p>
</div>
<div class="openblock solution" id="solution85"><input id="question85" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer85" style="display: none;">
<div class="content">
<div class="paragraph">
<p>The two tokens are <code>united</code> and <code>kingdom</code> (both lowercased).</p>
</div>
</div>
</div></div>
</li>
<li>
<p>Let’s take a closer look at analyzers. Compare the output of the <code>_analyze</code>
API on the string <code>"Nodes and Shards"</code> using the <code>standard</code> analyzer and using
the <code>english</code> analyzer.</p>
<div class="openblock solution" id="solution86"><input id="question86" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer86" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _analyze
{
  "text": "Nodes and Shards",
  "analyzer": "standard"
}


GET _analyze
{
  "text": "Nodes and Shards",
  "analyzer": "english"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>standard</code> analyzer outputs three tokens: <code>nodes</code>, <code>and</code>, and <code>shards</code>.
The <code>english</code> analyzer however only outputs two tokens: <code>node</code> and <code>shard</code>.
There are two things that happened here:</p>
</div>
<div class="paragraph">
<p>First, the <code>english</code> analyzer removed so called "stop words".
Certain words, like the word "and" in English do not add a lot of relevance to
queries. Almost every document will contain the word "and", if your documents
are in English. That’s why you can choose to ignore those words to save on
disk space, by not indexing those.</p>
</div>
<div class="paragraph">
<p>Secondly, the tokens <code>nodes</code> and <code>shards</code> were stemmed by the <code>english</code>
analyzer,  meaning they were reduced to their root form. In this case, the
plural <code>nodes</code> and <code>shards</code> became the singular <code>node</code> and <code>shard</code>.
By applying stemming to both the indexed data as well as the queries, the user
does not need to worry about whether a search term is singular or plural.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>Considering the datasets that you are using in this training, what would be
good fields to apply the <code>english</code> analyzer to?</p>
<div class="openblock solution" id="solution87"><input id="question87" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer87" style="display: none;">
<div class="content">
<div class="paragraph">
<p>Given that most of the blog posts are in English, the <code>english</code> analyzer would
work great on fields like <code>title</code> and <code>content</code> in the blogs dataset.</p>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>EXAM PREP</strong>: Add a new field named <code>title</code> to the mapping of the <code>tmp_index</code> index.
Map the field as type <code>text</code>, with the <code>english</code> analyzer.</p>
<div class="openblock solution" id="solution88"><input id="question88" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer88" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT tmp_index/_mapping
{
  "properties": {
    "title": {
      "type": "text",
      "analyzer": "english"
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Index the following document into the <code>tmp_index</code> index:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT tmp_index/_doc/3
{
  "title": "Nodes and Shards"
}</code></pre>
</div>
</div>
</li>
<li>
<p>Validate that you can indeed find this document when you query the <code>title</code>
field for <code>node</code> (singular):</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET tmp_index/_search
{
  "query": {
    "match": {
      "title": "node"
    }
  }
}</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary:</strong> In this lab you learned how to work with <code>text</code> and <code>keyword</code> fields and took a closer look at the behavior of the <code>english</code> analyzer.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_4_2">End of Lab 4.2</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_4_3_the_inverted_index_and_doc_values">Lab 4.3: The Inverted Index and Doc Values</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab you are going to take a closer look at the inverted
index and doc values.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>In the previous lab you indexed a document with the value <code>"United Kingdom"</code>
for the <code>country_name</code> field. Run the following <code>terms</code> aggregation on all the
documents in the <code>tmp_index</code> index to find the most common values for
<code>country_name</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET tmp_index/_search
{
  "size": 0,
  "aggs": {
    "top_countries": {
      "terms": {
        "field": "country_name",
        "size": 10
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>What is the result?</p>
</div>
<div class="openblock solution" id="solution89"><input id="question89" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer89" style="display: none;">
<div class="content">
<div class="paragraph">
<p>The operation returns an error.
Instead of aggregating on the <code>country_name</code> field, you should aggregate on the
<code>country_name.keyword</code> field, because <code>keyword</code> fields have doc values enabled.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET tmp_index/_search
{
  "size": 0,
  "aggs": {
    "top_countries": {
      "terms": {
        "field": "country_name.keyword",
        "size": 10
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Add two new fields <code>region_name</code> and <code>city_name</code> to the mapping of the
<code>tmp_index</code> index.
Map both as type <code>keyword</code>.
Disable the inverted index for <code>region_name</code>.
Disable doc values for <code>city_name</code>.</p>
<div class="openblock solution" id="solution90"><input id="question90" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer90" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT tmp_index/_mapping
{
  "properties": {
    "region_name": {
      "type": "keyword",
      "index": false
    },
    "city_name": {
      "type": "keyword",
      "doc_values": false
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Index the following sample document:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST tmp_index/_doc/4
{
  "region_name": "Hertfordshire",
  "city_name": "Hatfield"
}</code></pre>
</div>
</div>
</li>
<li>
<p>Out of the following two operations, which one do you expect to fail? Why?</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET tmp_index/_search
{
  "query": {
    "match": {
      "region_name": "Hertfordshire"
    }
  }
}

GET tmp_index/_search
{
  "size": 0,
  "aggs": {
    "top_regions": {
      "terms": {
        "field": "region_name"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="openblock solution" id="solution91"><input id="question91" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer91" style="display: none;">
<div class="content">
<div class="paragraph">
<p>You have disabled the inverted index for <code>region_name</code>.
As a result, you cannot query that field.
The <code>region_name</code> still has doc values enabled though, so the <code>terms</code>
aggregation can execute without any problems.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>Try the same for the <code>city_name</code> field. Which one will fail now?</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET tmp_index/_search
{
  "query": {
    "match": {
      "city_name": "Hatfield"
    }
  }
}

GET tmp_index/_search
{
  "size": 0,
  "aggs": {
    "top_regions": {
      "terms": {
        "field": "city_name"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="openblock solution" id="solution92"><input id="question92" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer92" style="display: none;">
<div class="content">
<div class="paragraph">
<p>This time it is the <code>terms</code> aggregation that fails.
You have disabled doc values for <code>city_name</code>.
As a result, you cannot aggregate on that field.
The <code>city_name</code> still has the inverted index enabled though, so you can still
query that field.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>Let’s take a close look at the logs in the <code>logs_server*</code> indexes, and see
how you could optimize the way those documents are indexed.
Here is a sample document:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{
  "@timestamp" : "2017-05-25T00:30:26.806Z",
  "user_agent" : "Amazon CloudFront",
  "input" : {
    "type" : "log"
  },
  "ecs" : {
    "version" : "1.0.0"
  },
  "level" : "info",
  "response_size" : 54067,
  "log" : {
    "offset" : 40587,
    "file" : {
      "path" : "/home/elastic/datasets/elastic_blog_curated_access_logs_server1/elastic_blog_curated_access_logs_server1-2017-05-25.log"
    }
  },
  "status_code" : 200,
  "geoip" : {
    "city_name" : "Seoul",
    "country_name" : "Republic of Korea",
    "country_code2" : "KR",
    "country_code3" : "KR",
    "continent_code" : "AS",
    "region_name" : "Seoul",
    "location" : {
      "lat" : 37.5111,
      "lon" : 126.9743
    }
  },
  "http_version" : "1.1",
  "originalUrl" : "/kr/blog/introducing-machine-learning-for-the-elastic-stack",
  "method" : "GET",
  "host" : "server1",
  "agent" : {
    "version" : "7.1.1",
    "type" : "filebeat",
    "ephemeral_id" : "8c726d99-51d6-4669-bebc-9461e100731b",
    "hostname" : "server1",
    "id" : "16bc0a64-d4a5-4f90-bcc8-08b76b604b55"
  },
  "runtime_ms" : 107,
  "language" : {
    "url" : "/blog/introducing-machine-learning-for-the-elastic-stack",
    "code" : "ko-kr"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is some information in these logs that you may never use in your Kibana
dashboards.
In other words, you will never aggregate or query on those fields.
For example, the fields inside of the <code>log</code> object.
These fields contain information about the log file that this entry was
ingested from:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>"log" : {
  "offset" : 40587,
  "file" : {
    "path" : "/home/elastic/datasets/elastic_blog_curated_access_logs_server1/elastic_blog_curated_access_logs_server1-2017-05-25.log"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, the <code>agent</code> object contains information about the Filebeat instance
that shipped the log file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>"agent" : {
  "version" : "7.1.1",
  "type" : "filebeat",
  "ephemeral_id" : "8c726d99-51d6-4669-bebc-9461e100731b",
  "hostname" : "server1",
  "id" : "16bc0a64-d4a5-4f90-bcc8-08b76b604b55"
}</code></pre>
</div>
</div>
</li>
<li>
<p>Let’s assume we are never going to query or aggregate on the <code>log</code> and
<code>agent</code> objects.
Let’s optimize Elasticsearch such that the fields inside these objects don’t
take up disk space for an inverted index or doc values.</p>
<div class="paragraph">
<p>Create a new index <code>logs_fixed</code> with a mapping in which the <code>log</code> and <code>agent</code>
objects have been completely disabled.</p>
</div>
<div class="openblock solution" id="solution93"><input id="question93" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer93" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT logs_fixed
{
  "mappings": {
    "properties": {
      "log": {
        "enabled": false
      },
      "agent": {
        "enabled": false
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
</ol>
</div>
<div class="paragraph">
<p>In the next lab you are going to continue to optimize the <code>logs_fixed</code> index
and you will see how much disk space can be saved.</p>
</div>
<div class="paragraph">
<p><strong>Summary:</strong> In this labs, you explored what happens when you disable the
inverted index and doc values for a field.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_4_3">End of Lab 4.3</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_4_4_custom_mappings">Lab 4.4: Custom Mappings</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab you are going to further optimize the <code>logs_fixed</code>
index by using a dynamic template.
You are also going to see how some of the mapping parameters work.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>EXAM PREP</strong>: Update the mappings for the <code>logs_fixed</code> index (that you created in the last
lab) with a dynamic template:</p>
<div class="ulist">
<ul>
<li>
<p>that matches all unmapped fields with a value of JSON type <code>string</code></p>
</li>
<li>
<p>and maps those as type <code>keyword</code></p>
<div class="openblock solution" id="solution94"><input id="question94" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer94" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT logs_fixed/_mapping
{
  "dynamic_templates": [
    {
      "my_string_fields": {
        "match_mapping_type": "string",
        "mapping": {
          "type": "keyword"
        }
      }
    }
  ]
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
</ul>
</div>
</li>
<li>
<p><strong>EXAM PREP</strong>: With the mappings for the <code>logs_fixed</code> index in place, let’s populate the
index.
Copy over all documents from the <code>logs_server1</code> index to the <code>logs_fixed</code>
index by using the <code>_reindex</code> API:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST _reindex?wait_for_completion=false
{
  "source": {
    "index": "logs_server1"
  },
  "dest": {
    "index": "logs_fixed"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will run in the background and may take a few minutes to complete.</p>
</div>
</li>
<li>
<p>Retrieve the mapping of the <code>logs_fixed</code> index.
How have the string fields (like <code>geoip.country_name</code>) been dynamically mapped?</p>
<div class="openblock solution" id="solution95"><input id="question95" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer95" style="display: none;">
<div class="content">
<div class="paragraph">
<p>The output of <code>GET logs_fixed/_mapping</code> will show you that all string fields
have been mapped only as type <code>keyword</code>.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>Use <code>GET _cat/indices?v</code> to get a listing of all the indexes in your cluster.
Compare the <code>store.size</code> of the <code>logs_fixed</code> and <code>logs_server1</code> indexes.
Which <code>index</code> takes up less disk space?</p>
<div class="openblock solution" id="solution96"><input id="question96" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer96" style="display: none;">
<div class="content">
<div class="paragraph">
<p>The <code>logs_fixed</code> index takes up about 15% less disk space.
By disabling fields you will not use (in the last lab), and by mapping all
strings as type <code>keyword</code> you have optimized Elasticsearch for more efficient
storage.</p>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>EXAM PREP</strong>: Let’s review some of the mapping parameters, like <code>copy_to</code> and defining
default null values.
Create a new index named <code>surveys</code> that is going to hold some survey results.
Create the index with only four fields in its mapping:</p>
<div class="ulist">
<ul>
<li>
<p>A field named <code>all_feedback</code> of type <code>text</code></p>
</li>
<li>
<p>A field named <code>instructor_feedback</code> of type <code>text</code> that gets copied to
the <code>all_feedback</code> field</p>
</li>
<li>
<p>A field named <code>labs_feedback</code> of type <code>text</code> that is also copied to
the <code>all_feedback</code> field</p>
</li>
<li>
<p>A field named <code>course_rating</code> of type <code>integer</code> in which <code>null</code> values
default to 1, and also has coercion disabled</p>
</li>
</ul>
</div>
<div class="openblock solution" id="solution97"><input id="question97" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer97" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT surveys
{
  "mappings": {
    "properties": {
      "all_feedback": {
        "type": "text"
      },
      "instructor_feedback": {
        "type": "text",
        "copy_to": "all_feedback"
      },
      "labs_feedback": {
        "type": "text",
        "copy_to": "all_feedback"
      },
      "course_rating": {
        "type": "integer",
        "null_value": 1,
        "coerce": false
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Put the following document into <code>surveys</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT surveys/_doc/1
{
  "instructor_feedback": "She was great!",
  "labs_feedback": "Labs were hard!"
}</code></pre>
</div>
</div>
</li>
<li>
<p>Write a query that searches the <code>all_feedback</code> field for the term <code>great</code>.
The document above should be a hit.</p>
<div class="openblock solution" id="solution98"><input id="question98" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer98" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET surveys/_search
{
  "query": {
    "match": {
      "all_feedback": "great"
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>What is the value of <code>course_rating</code> for your document in <code>surveys</code>?
Write a <code>range</code> query that finds all documents with a <code>course_rating</code>
greater than or equal to 1.</p>
<div class="openblock solution" id="solution99"><input id="question99" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer99" style="display: none;">
<div class="content">
<div class="paragraph">
<p>The document does not have a <code>course_rating</code> field. The <code>null_value</code>
parameter is only applied to fields that exist and have <strong>null</strong> as their
value. The following query does not match the document in <code>surveys</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET surveys/_search
{
  "query": {
    "bool": {
      "filter": {
        "range": {
          "course_rating": {
            "gte": 1
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Review the following two <strong>PUT</strong> commands and predict what the result
is of each one. Run each <strong>PUT</strong> command to see if you are correct:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT surveys/_doc/2
{
  "course_rating": null
}

PUT surveys/_doc/3
{
  "course_rating": "8"
}</code></pre>
</div>
</div>
<div class="openblock solution" id="solution100"><input id="question100" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer100" style="display: none;">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>The document with id of 2 indexes fine, and its indexed value of
<code>course_rating</code> is 1. To verify, run the <code>range</code> query again from the
previous step.</p>
</li>
<li>
<p>The document with id of 3 does not get indexed because "8" can not be
coerced into an integer, since coercion is disabled for the
<code>course_rating</code> field.</p>
</li>
</ul>
</div>
</div>
</div></div>
</li>
<li>
<p>It is always a good practice to cleanup your tests.
Make sure to delete the indices that were created for practice in this lab.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>DELETE surveys,tmp_index,my_logs,logs_fixed</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary:</strong> In this lab you saw how you can optimize Elasticsearch for more
efficient storage using dynamic templates.
You also explored some of the mapping parameters like <code>copy_to</code> and <code>coerce</code>.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_4_4">End of Lab 4.4</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_5_1_master_nodes">Lab 5.1: Master Nodes</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective</strong>: In this lab, you will add a node to the cluster as well as become
familiar with the cluster state and the discovery module.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Before you make changes to your cluster, let’s start by understanding
its current state. Use the Cluster State API to answer the following
questions.</p>
<div class="ulist">
<ul>
<li>
<p>What is the cluster name?</p>
</li>
<li>
<p>How many nodes are there in the cluster?</p>
</li>
<li>
<p>Which node is the elected master node?</p>
</li>
<li>
<p>How many indices are there in the cluster?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You probably know the answers to these questions because your current
cluster only has 1 node and uses a lot of default settings, but these
are great questions to ask about any cluster.</p>
</div>
<div class="openblock solution" id="solution101"><input id="question101" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer101" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cluster/state</code></pre>
</div>
</div>
<div class="paragraph">
<p>The cluster name should be <code>my_cluster</code>. You only have a single node,
which is the elected master node. You should have at least 5 indices in
the cluster.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>Another way to answer some of the previous questions is to use the
<code>_cat</code> API, which often returns less information per API, but it is
typically easier to read. Run each of the following commands:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cat/nodes?v</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>nodes</code> command gives you information about all the nodes in the
cluster, including their roles. You can see that <code>node1</code> is a
<code>data</code>, <code>ingest</code> and <code>master-eligible</code> node (<strong>dim</strong>) and that <code>node1</code> is the
elected-master in the cluster. (Remember to use <strong>?v</strong> to see the header.)</p>
</div>
</li>
<li>
<p>Next, you will scale your cluster by adding another node.
But first, you need to make a few changes to the <code>node1</code> configuration.</p>
<div class="ulist">
<ul>
<li>
<p>The <code>node.name</code> setting is currently defined in the command line when you
execute Elasticsearch.
Update the configuration file to have the node name set to <code>node1</code>, so you
don’t need to define it in the command line.</p>
<div class="openblock solution" id="solution102"><input id="question102" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer102" style="display: none;">
<div class="content">
<div class="paragraph">
<p>Add the <code>node.name</code> setting at the end of the configuration file.
You should have something like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>cluster.name: my_cluster
node.name: node1</code></pre>
</div>
</div>
</div>
</div></div>
</li>
</ul>
</div>
</li>
<li>
<p>Currently, <code>node1</code> transport protocol is bound to <code>localhost</code> and, therefore,
nodes cannot connect to it.
Update the configuration file to bind both transport and HTTP protocols to a
site-local address.</p>
<div class="openblock solution" id="solution103"><input id="question103" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer103" style="display: none;">
<div class="content">
<div class="paragraph">
<p>Add the <code>network.host</code> setting at the end of the configuration file.
You should have something like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>cluster.name: my_cluster
node.name: node1
network.host:  _site_</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>network.host</code> setting will update both <code>bind_host</code> and <code>publish_host</code> for
both the transport and HTTP protocols.
The <code>_site_</code> value binds to any site-local addresses on the system, in this
case the server IP.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>As discussed in this lesson, when you start a brand new Elasticsearch cluster
for the very first time, there is a cluster bootstrapping step, which
determines the set of master-eligible nodes whose votes are counted in the
very first election.
Even though this is a one node-only cluster, you should set the
<code>initial_master_nodes</code> setting.</p>
<div class="openblock solution" id="solution104"><input id="question104" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer104" style="display: none;">
<div class="content">
<div class="paragraph">
<p>Add the <code>cluster.initial_master_nodes</code> setting at the end of the
configuration file.
As this is a one node cluster, you should only add <code>node1</code> to the list.
You should have something like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>cluster.name: my_cluster
node.name: node1
network.host:  _site_
cluster.initial_master_nodes: ["node1"]</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>As discussed in this lesson, nodes should be able to discover the cluster
using the seed hosts.
Even though the cluster currently has a single node, there will be more soon.
Update the configuration file so that <code>node1</code> discovers the cluster via
<code>server1</code> or <code>server2</code> or <code>server3</code>.</p>
<div class="openblock solution" id="solution105"><input id="question105" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer105" style="display: none;">
<div class="content">
<div class="paragraph">
<p>Add the <code>discovery.seed_hosts</code> setting at the end of the configuration file.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>cluster.name: my_cluster
node.name: node1
network.host:  _site_
cluster.initial_master_nodes: ["node1"]
discovery.seed_hosts: ["server1", "server2", "server3"]</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Now, stop Elasticsearch on <code>node1</code> and then start it using the
following command:</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>./elasticsearch-7.3.1/bin/elasticsearch</code></pre>
</div>
</div>
</li>
<li>
<p>Notice that Kibana will fail to connect because now the HTTP protocol is
not bound to <code>localhost</code> anymore:</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>  log   [21:06:43.707] [warning][admin][elasticsearch] Unable to revive connection: http://localhost:9200/
  log   [21:06:43.708] [warning][admin][elasticsearch] No living connections</code></pre>
</div>
</div>
</li>
<li>
<p>To solve this problem, stop Kibana and start it using the following command:</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>./kibana-7.3.1-linux-x86_64/bin/kibana --elasticsearch.hosts="http://server1:9200" --host=0.0.0.0</code></pre>
</div>
</div>
</li>
<li>
<p>Next, you need to setup and start <code>node2</code>.
First, open a new terminal tab in the Virtual Environment UI and <code>ssh</code>
onto <code>server2</code>:</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>ssh server2</code></pre>
</div>
</div>
</li>
<li>
<p>Then, Extract Elasticsearch on <code>server2</code>:</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>tar -zxf elasticsearch-7.3.1-linux-x86_64.tar.gz</code></pre>
</div>
</div>
</li>
<li>
<p>Now, configure the node with the following basic characteristics.</p>
<div class="ulist">
<ul>
<li>
<p>it joins <code>my_cluster</code></p>
</li>
<li>
<p>the name of the node is <code>node2</code></p>
</li>
<li>
<p>binds and publishes both the transport and HTTP protocols to the site-local address</p>
<div class="openblock solution" id="solution106"><input id="question106" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer106" style="display: none;">
<div class="content">
<div class="paragraph">
<p>Add the following settings at the end of the <code>elasticsearch.yml</code> configuration
file.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>cluster.name: my_cluster
node.name: node2
network.host: _site_</code></pre>
</div>
</div>
</div>
</div></div>
</li>
</ul>
</div>
</li>
<li>
<p>Next, update the configuration file with the following discovery and cluster
formation settings.</p>
<div class="ulist">
<ul>
<li>
<p><code>node1</code> is the only initial master node in the cluster</p>
</li>
<li>
<p>it discovers the cluster via <code>server1</code>, <code>server2</code>, or <code>server3</code></p>
<div class="openblock solution" id="solution107"><input id="question107" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer107" style="display: none;">
<div class="content">
<div class="paragraph">
<p>The <code>cluster.initial_master_nodes</code> setting is very important to avoid <code>node2</code>
to create its own cluster if it cannot connect to <code>node1</code> for any reason (e.g.
typo in the cluster name).
The <code>discovery.seed_hosts</code> setting allows <code>node2</code> to connect to <code>node1</code> and
<code>node3</code> (after it is added).
The <code>elasticsearch.yml</code> should look like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>cluster.name: my_cluster
node.name: node2
network.host: _site_
cluster.initial_master_nodes: ["node1"]
discovery.seed_hosts: ["server1", "server2", "server3"]</code></pre>
</div>
</div>
</div>
</div></div>
</li>
</ul>
</div>
</li>
<li>
<p>Next, configure <code>node2</code> to use only 512 megabytes of memory.
(<em>TIP</em>: make sure to set both the min and max heap size to <strong>512m</strong>.)</p>
<div class="openblock solution" id="solution108"><input id="question108" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer108" style="display: none;">
<div class="content">
<div class="paragraph">
<p>In the <code>jvm.options</code> configuration file you will see a <code>-Xms</code> and a <code>-Xmx</code>
setting configured to <code>1gb</code>. Update both values to <code>512m</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>-Xms512m
-Xmx512m</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Finally, start <code>node2</code>. You should see the following output:</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>[2018-11-23T19:03:54,245][INFO ][o.e.c.s.ClusterApplierService] [node2] detected_master {node1}{Xe6KFUYCTA6AWRpbw84qaQ}{CKxs8gcTRoiYEiutL4BERw}{172.18.0.2}{172.18.0.2:9300}{ml.machine_memory=3892260864, ml.max_open_jobs=20, xpack.installed=true, ml.enabled=true}, added {{node1}{Xe6KFUYCTA6AWRpbw84qaQ}{CKxs8gcTRoiYEiutL4BERw}{172.18.0.2}{172.18.0.2:9300}{ml.machine_memory=3892260864, ml.max_open_jobs=20, xpack.installed=true, ml.enabled=true},}, reason: apply cluster state (from master [master {node1}{Xe6KFUYCTA6AWRpbw84qaQ}{CKxs8gcTRoiYEiutL4BERw}{172.18.0.2}{172.18.0.2:9300}{ml.machine_memory=3892260864, ml.max_open_jobs=20, xpack.installed=true, ml.enabled=true} committed version [27]])
[2018-11-23T19:03:54,981][INFO ][o.e.x.s.a.TokenService   ] [node2] refresh keys
[2018-11-23T19:03:55,345][INFO ][o.e.x.s.a.TokenService   ] [node2] refreshed keys
[2018-11-23T19:03:55,386][INFO ][o.e.l.LicenseService     ] [node2] license [423ed674-41a3-4284-9a95-e16ea01f8ecd] mode [trial] - valid
[2018-11-23T19:03:55,442][INFO ][o.e.x.s.t.n.SecurityNetty4HttpServerTransport] [node2] publish_address {172.18.0.3:9200}, bound_addresses {172.18.0.3:9200}
[2018-11-23T19:03:55,442][INFO ][o.e.n.Node               ] [node2] started</code></pre>
</div>
</div>
<div class="openblock solution" id="solution109"><input id="question109" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer109" style="display: none;">
<div class="content">
<div class="paragraph">
<p>Start Elasticsearch using the following command:</p>
</div>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>./elasticsearch-7.3.1/bin/elasticsearch</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Use <code>_cat/nodes</code> to view the nodes in the cluster. You should see two
nodes now:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>ip         heap.percent ram.percent cpu load_1m load_5m load_15m node.role master name
172.18.0.2           31          98  11    0.01    0.15     0.08 dim       *      node1
172.18.0.3           37          98  11    0.01    0.15     0.08 dim       -      node2</code></pre>
</div>
</div>
<div class="openblock solution" id="solution110"><input id="question110" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer110" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cat/nodes?v&amp;s=name</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>OPTIONAL</strong>: Now that you started your 2-node cluster, use the following
command to check the voting configuration:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET /_cluster/state?filter_path=metadata.cluster_coordination.last_committed_config</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should get an output similar to the one below, which shows the id of a
single master-eligible node that is allowed to vote within your cluster.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{
  "metadata" : {
    "cluster_coordination" : {
      "last_committed_config" : [
        "OvD79L1lQme1hi06Ouiu7Q",
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Why the cluster coordination has a single master-eligible node, if there are
two master-eligible nodes in the cluster?</p>
</div>
<div class="openblock solution" id="solution111"><input id="question111" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer111" style="display: none;">
<div class="content">
<div class="paragraph">
<p>If there is an even number of master-eligible nodes, Elasticsearch leaves one
of them out of the voting configuration to ensure that it has an odd size.
This omission does not decrease the failure-tolerance of the cluster.
In fact, improves it slightly: if the cluster suffers from a network partition
that divides it into two equally-sized halves then one of the halves will
contain a majority of the voting configuration and will be able to keep
operating.</p>
</div>
</div>
</div></div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary</strong>: In this lab, you started a 2-node cluster as well as became
familiar with the cluster state and the discovery module.
As discussed in this lesson, having a two node cluster is not a best practice
and, in the next lab, you will see a better solution.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_5_1">End of Lab 5.1</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_5_2_node_roles">Lab 5.2: Node Roles</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab, you will familiarize yourself with node roles.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>At the end of the previous lab, we discussed that having an even number of
master-eligible nodes is not a good practice.
In cases like this, adding a third node is the preferred solution.
In this lab, you will configure a dedicated master-eligible node on <code>server3</code>.
First, open another terminal window in the Virtual Environment UI and <code>ssh</code>
onto <code>server3</code>:</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>ssh server3</code></pre>
</div>
</div>
</li>
<li>
<p>Extract Elasticsearch on <code>server3</code>:</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>tar -zxf elasticsearch-7.3.1-linux-x86_64.tar.gz</code></pre>
</div>
</div>
</li>
<li>
<p><strong>EXAM PREP</strong>: Then, configure the node settings in the appropriate config files
(either <code>elasticsearch.yml</code> or <code>jvm.options</code>) to have the following:</p>
<div class="ulist">
<ul>
<li>
<p>it joins <code>my_cluster</code></p>
</li>
<li>
<p>the name of the node is <code>node3</code></p>
</li>
<li>
<p>binds and publishes both the transport and HTTP protocols to the site-local address</p>
</li>
<li>
<p>set the min and max heap size to <strong>512m</strong></p>
<div class="openblock solution" id="solution112"><input id="question112" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer112" style="display: none;">
<div class="content">
<div class="paragraph">
<p>The <code>elasticsearch.yml</code> configuration file should look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>cluster.name: my_cluster
node.name: node3
network.host: _site_</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>jvm.options</code> configuration file should contain:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>-Xms512m
-Xmx512m</code></pre>
</div>
</div>
</div>
</div></div>
</li>
</ul>
</div>
</li>
<li>
<p><strong>EXAM PREP</strong>: Next, update the node settings to have the following:</p>
<div class="ulist">
<ul>
<li>
<p><code>node1</code> is the only initial master node in the cluster</p>
</li>
<li>
<p>it discovers the cluster via <code>server1</code>, <code>server2</code>, or <code>server3</code></p>
<div class="openblock solution" id="solution113"><input id="question113" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer113" style="display: none;">
<div class="content">
<div class="paragraph">
<p>The <code>elasticsearch.yml</code> configuration file should look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>cluster.name: my_cluster
node.name: node3
network.host: _site_
cluster.initial_master_nodes: ["node1"]
discovery.seed_hosts: ["server1", "server2", "server3"]</code></pre>
</div>
</div>
</div>
</div></div>
</li>
</ul>
</div>
</li>
<li>
<p>Update the node settings with the following to make <code>node3</code> a dedicated master-eligible node:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>node.data: false
node.ingest: false
node.ml: false
node.master: true</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="openblock solution" id="solution114"><input id="question114" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer114" style="display: none;">
<div class="content">
<div class="paragraph">
<p>The <code>elasticsearch.yml</code> configuration file should look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>cluster.name: my_cluster
node.name: node3
network.host: _site_
cluster.initial_master_nodes: ["node1"]
discovery.seed_hosts: ["server1", "server2", "server3"]
node.data: false
node.ingest: false
node.ml: false
node.master: true</code></pre>
</div>
</div>
</div>
</div></div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Start Elasticsearch on <code>server3</code>. You should entries similar to the following output:</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>[2018-11-23T19:13:18,009][INFO ][o.e.c.s.ClusterApplierService] [node3] detected_master {node1}{Xe6KFUYCTA6AWRpbw84qaQ}{CKxs8gcTRoiYEiutL4BERw}{172.18.0.2}{172.18.0.2:9300}{ml.machine_memory=3892260864, ml.max_open_jobs=20, xpack.installed=true, ml.enabled=true}, added {{node1}{Xe6KFUYCTA6AWRpbw84qaQ}{CKxs8gcTRoiYEiutL4BERw}{172.18.0.2}{172.18.0.2:9300}{ml.machine_memory=3892260864, ml.max_open_jobs=20, xpack.installed=true, ml.enabled=true},{node2}{7IrQlPdBRJaA12OlrbdpZQ}{0mVQTduVQJuaQavC6PAHlA}{172.18.0.3}{172.18.0.3:9300}{ml.machine_memory=3892260864, ml.max_open_jobs=20, xpack.installed=true, ml.enabled=true},}, reason: apply cluster state (from master [master {node1}{Xe6KFUYCTA6AWRpbw84qaQ}{CKxs8gcTRoiYEiutL4BERw}{172.18.0.2}{172.18.0.2:9300}{ml.machine_memory=3892260864, ml.max_open_jobs=20, xpack.installed=true, ml.enabled=true} committed version [116]])
[2018-11-23T19:13:18,420][INFO ][o.e.x.s.a.TokenService   ] [node3] refresh keys
[2018-11-23T19:13:18,774][INFO ][o.e.x.s.a.TokenService   ] [node3] refreshed keys
[2018-11-23T19:13:18,934][INFO ][o.e.l.LicenseService     ] [node3] license [423ed674-41a3-4284-9a95-e16ea01f8ecd] mode [trial] - valid
[2018-11-23T19:13:19,018][INFO ][o.e.x.s.t.n.SecurityNetty4HttpServerTransport] [node3] publish_address {172.18.0.4:9200}, bound_addresses {172.18.0.4:9200}
[2018-11-23T19:13:19,019][INFO ][o.e.n.Node               ] [node3] started</code></pre>
</div>
</div>
<div class="openblock solution" id="solution115"><input id="question115" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer115" style="display: none;">
<div class="content">
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>./elasticsearch-7.3.1/bin/elasticsearch</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Verify your nodes are configured the way you want:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cat/nodes?s=name</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should see an output similar to the one as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>172.18.0.2 10 98 18 0.74 0.93 0.64 dim * node1
172.18.0.3  8 98 18 0.74 0.93 0.64 dim - node2
172.18.0.4 17 98 48 0.74 0.93 0.64 m   - node3</code></pre>
</div>
</div>
<div class="paragraph">
<p>The role of <code>node3</code> should be only "<strong>m</strong>", while the role of both <code>node1</code> and <code>node2</code> should be "<strong>dim</strong>".</p>
</div>
</li>
<li>
<p>Now that you have a 3-node cluster, use the following command to check
the voting configuration:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET /_cluster/state?filter_path=metadata.cluster_coordination.last_committed_config</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should get an output similar to the one below, which shows the ids of three
master-eligible nodes that are allowed to vote within your cluster (your ids will be different).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{
  "metadata" : {
    "cluster_coordination" : {
      "last_committed_config" : [
        "Xe6KFUYCTA6AWRpbw84qaQ",
        "OvD79L1lQme1hi06Ouiu7Q",
        "e6KF9L1lQUYbw84CTAemQl"
      ]
    }
  }
}</code></pre>
</div>
</div>
</li>
<li>
<p>Check that the voting configuration is working by stopping the master node
(probably <code>node1</code>) and check the terminal output in the other nodes.
Among the logged lines you will see something similar to the following:</p>
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>[2018-11-23T19:15:47,301][INFO ][o.e.d.z.ZenDiscovery     ] [node2] master_left [{node1}{Xe6KFUYCTA6AWRpbw84qaQ}{CKxs8gcTRoiYEiutL4BERw}{172.18.0.2}{172.18.0.2:9300}{ml.machine_memory=3892260864, ml.max_open_jobs=20, xpack.installed=true, ml.enabled=true}], reason [shut_down]
[2018-11-23T19:15:47,303][WARN ][o.e.d.z.ZenDiscovery     ] [node2] master left (reason = shut_down), current nodes: nodes:
   {node2}{7IrQlPdBRJaA12OlrbdpZQ}{0mVQTduVQJuaQavC6PAHlA}{172.18.0.3}{172.18.0.3:9300}{ml.machine_memory=3892260864, xpack.installed=true, ml.max_open_jobs=20, ml.enabled=true}, local
   {node1}{Xe6KFUYCTA6AWRpbw84qaQ}{CKxs8gcTRoiYEiutL4BERw}{172.18.0.2}{172.18.0.2:9300}{ml.machine_memory=3892260864, ml.max_open_jobs=20, xpack.installed=true, ml.enabled=true}, master
   {node3}{tWpzRPKfTrujh02kPpMHiA}{W4P1zuy_TauS0GGCGMq8Bg}{172.18.0.4}{172.18.0.4:9300}{ml.machine_memory=3892260864, ml.max_open_jobs=20, xpack.installed=true, ml.enabled=true}

[2018-11-23T19:15:50,432][INFO ][o.e.c.s.MasterService    ] [node2] zen-disco-elected-as-master ([1] nodes joined)[{node3}{tWpzRPKfTrujh02kPpMHiA}{W4P1zuy_TauS0GGCGMq8Bg}{172.18.0.4}{172.18.0.4:9300}{ml.machine_memory=3892260864, ml.max_open_jobs=20, xpack.installed=true, ml.enabled=true}], reason: new_master {node2}{7IrQlPdBRJaA12OlrbdpZQ}{0mVQTduVQJuaQavC6PAHlA}{172.18.0.3}{172.18.0.3:9300}{ml.machine_memory=3892260864, xpack.installed=true, ml.max_open_jobs=20, ml.enabled=true}
[2018-11-23T19:15:50,461][WARN ][o.e.d.z.PublishClusterStateAction] [node2] publishing cluster state with version [150] failed for the following nodes: [[{node1}{Xe6KFUYCTA6AWRpbw84qaQ}{CKxs8gcTRoiYEiutL4BERw}{172.18.0.2}{172.18.0.2:9300}{ml.machine_memory=3892260864, ml.max_open_jobs=20, xpack.installed=true, ml.enabled=true}]]
[2018-11-23T19:15:50,465][INFO ][o.e.c.s.ClusterApplierService] [node2] new_master {node2}{7IrQlPdBRJaA12OlrbdpZQ}{0mVQTduVQJuaQavC6PAHlA}{172.18.0.3}{172.18.0.3:9300}{ml.machine_memory=3892260864, xpack.installed=true, ml.max_open_jobs=20, ml.enabled=true}, reason: apply cluster state (from master [master {node2}{7IrQlPdBRJaA12OlrbdpZQ}{0mVQTduVQJuaQavC6PAHlA}{172.18.0.3}{172.18.0.3:9300}{ml.machine_memory=3892260864, xpack.installed=true, ml.max_open_jobs=20, ml.enabled=true} committed version [150] source [zen-disco-elected-as-master ([1] nodes joined)[{node3}{tWpzRPKfTrujh02kPpMHiA}{W4P1zuy_TauS0GGCGMq8Bg}{172.18.0.4}{172.18.0.4:9300}{ml.machine_memory=3892260864, ml.max_open_jobs=20, xpack.installed=true, ml.enabled=true}]]])</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice the other nodes realized that the elected master left the
cluster, and then elected a new master.</p>
</div>
</li>
<li>
<p>Next, imagine <code>node1</code> is not as powerful as <code>node2</code> and you don’t want it to
run ingest pipelines or machine learning jobs.
Update its configuration file to make it a <code>data</code> and <code>master-eligible</code> only
node.
<em>(<strong>NOTE</strong>: don’t disable all ingest nodes in your cluster. Ingest nodes are
often used in the Elastic Stack ecosystem — e.g. beats and monitoring.)</em></p>
<div class="openblock solution" id="solution116"><input id="question116" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer116" style="display: none;">
<div class="content">
<div class="paragraph">
<p>Add the following to the <code>node1</code> configuration file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>node.ingest: false
node.ml: false</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Finally, restart <code>node1</code> and verify your nodes are configured the
way you want:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cat/nodes?s=name</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should see an output similar to the one as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>172.18.0.4 11 98  3 0.67 0.22 0.26 m   - node3
172.18.0.3 19 98  3 0.67 0.22 0.26 dim * node2
172.18.0.2 13 98 30 0.67 0.22 0.26 dm  - node1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Your master node might be different, but the role of <code>node2</code> should be
only "<strong>dim</strong>", while the role of <code>node1</code> should be "<strong>dm</strong>" and <code>node3</code> should
still be "<strong>m</strong>".</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary:</strong> In this lab, you familiarized yourself with node roles by
updating your current nodes to become dedicated nodes.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_5_2">End of Lab 5.2</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_5_3_understanding_shards">Lab 5.3: Understanding Shards</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab, you will become familiar with shard
distribution. You will create new indices with a specific number of
shards and replicas and analyze shard allocation along with cluster status.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>First, use the <code>_cat</code> API to see information about the indices in the
cluster.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cat/indices?v</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>indices</code> command gives you information about the indices in the
cluster. You can see the number of primary shards, replica shards,
documents and deleted documents. You can also see the size on disk for
primary shards and in total (primary shards + replica shards). Finally,
notice that every index has a name and a uuid.</p>
</div>
</li>
<li>
<p>Then, use the <code>_cat</code> API to see information about the shards in the
cluster. How many shards does the index <code>logs_server2</code> have? And in which
node are they allocated?</p>
<div class="openblock solution" id="solution117"><input id="question117" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer117" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cat/shards?v</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>shards</code> command gives you information about the shards in the
cluster. You can see information about primaries and replicas, the
number of documents, size on disk, and which node a shard has been
allocated. If you are interested in a specific index, add the index name
after <code>/shards</code>, like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cat/shards/logs_server2?v</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>logs_server2</code> index has 1 primary shard and 1 replica shard
configured. The allocation of primaries and replicas will be distributed
across <code>node1</code> and <code>node2</code>, as <code>node3</code> is a dedicated master-eligible node.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>Now, use <code>_cluster/health</code> to check the status of your cluster, which should
be green.</p>
<div class="openblock solution" id="solution118"><input id="question118" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer118" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cluster/health</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>To better understand shard allocation, create an index named <code>test1</code> with
4 primary shards and 2 replicas.</p>
<div class="openblock solution" id="solution119"><input id="question119" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer119" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT test1
{
  "settings": {
    "number_of_shards": 4,
    "number_of_replicas": 2
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Use the following to check the shard allocation of your <code>test1</code> index.
You should see 4 <strong>STARTED</strong> primary shards, 4 <strong>STARTED</strong> replica shards and
4 <strong>UNASSIGNED</strong> replica shards.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cat/shards/test1?v</code></pre>
</div>
</div>
<div class="paragraph">
<p>For better readability, you can use the following query to see the
results sorted:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cat/shards/test1?v&amp;s=shard,prirep</code></pre>
</div>
</div>
</li>
<li>
<p>What is the status of your cluster? Why?</p>
<div class="openblock solution" id="solution120"><input id="question120" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer120" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cluster/health</code></pre>
</div>
</div>
<div class="paragraph">
<p>It should be yellow because there are unassigned replicas.
Remember that Elasticsearch never allocates more than 1 copy of the same shard
to the same node.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>Update the <code>test1</code> index to have 1 replicas and check the new shard
distribution.</p>
<div class="openblock solution" id="solution121"><input id="question121" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer121" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT test1/_settings
{
  "settings": {
    "number_of_replicas": 1
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cat/shards/test1?v&amp;s=node,shard</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>What is the status of your cluster?</p>
<div class="openblock solution" id="solution122"><input id="question122" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer122" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cluster/health</code></pre>
</div>
</div>
<div class="paragraph">
<p>It should be back to green.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>It is a good practice to run tests on a new index and, then, cleanup
the cluster as you finish the test. Therefore, delete the
<code>test1</code> index, which was created in this lab.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>DELETE test1</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary</strong>: In this lab, you became familiar with shard distribution. You
created new indices with a specific number of shards and replicas and
analyzed shard allocation along with cluster status.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_5_3">End of Lab 5.3</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_5_4_distributed_operations">Lab 5.4: Distributed Operations</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab, you will use the <code>refresh_interval</code> setting and the
<code>refresh</code> parameter to better understand how Elasticsearch refreshes.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The <code>refresh_interval</code> setting defines the maximum time that a document can
be unavailable for search after an index operation.
Create a new index named <code>my_refresh_test</code> with a refresh interval of 1 hour.
(The refresh interval is very high, but we will use it for test purposes.)</p>
<div class="openblock solution" id="solution123"><input id="question123" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer123" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT my_refresh_test
{
  "settings": {
    "index.refresh_interval": "1h"
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Execute the following command to index three documents:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT my_refresh_test/_bulk
{ "index" : { "_id" : "1"}}
{ "level" : "test"}
{ "index" : { "_id" : "2"}}
{ "level" : "test"}
{ "index" : { "_id" : "3"}}
{ "level" : "test"}</code></pre>
</div>
</div>
</li>
<li>
<p>Execute a search request on <code>my_refresh_test</code>.
How many documents are returned? Why?</p>
<div class="openblock solution" id="solution124"><input id="question124" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer124" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET my_refresh_test/_search</code></pre>
</div>
</div>
<div class="paragraph">
<p>The request above should return 0 documents because the <code>refresh_interval</code>
is very high (1 hour). It will take a long time until the documents are
available for search.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>Send a GET request to retrieve document 1. Do you think the document
will be returned? Why or why not?</p>
<div class="openblock solution" id="solution125"><input id="question125" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer125" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET my_refresh_test/_doc/1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Document 1 is returned. By default, the GET API is realtime, and is not
affected by the refresh rate of the index (when data will become visible
for search).</p>
</div>
</div>
</div></div>
</li>
<li>
<p>There is no point in waiting 1 hour for a refresh to happen.
Force a refresh and try running the search again.
Will you get any hits this time?</p>
<div class="openblock solution" id="solution126"><input id="question126" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer126" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST my_refresh_test/_refresh</code></pre>
</div>
</div>
<div class="paragraph">
<p>Yes, all three documents are hits. Calling <code>_refresh</code> forces a shard refresh
so that the latest operations are visible immediately.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>Sometimes in tests (or even in production) you want to write a document
and make sure it is available as soon as possible.
Regardless of the current <code>refresh_interval</code>, you can use the <code>refresh</code>
parameter in an index request to control it.
Index a new document that will be available for search right away,
even though the refresh interval is set to 1 hour.
The search result should contain 4 documents.</p>
<div class="openblock solution" id="solution127"><input id="question127" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer127" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT my_refresh_test/_doc/4?refresh=true
{
  "level" : "test"
}

GET my_refresh_test/_search</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Using <code>refresh=true</code> will likely degrade Elasticsearch performance.
To make sure that documents are available as soon as the client receives
the response without impacting Elasticsearch performance, use the
<code>refresh=wait_for</code> option. To test it, first change the <code>refresh_interval</code> of
the <code>my_refresh_test</code> index to ten seconds.</p>
<div class="openblock solution" id="solution128"><input id="question128" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer128" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT my_refresh_test/_settings
{
  "index.refresh_interval": "10s"
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Next, index a document using the <code>wait_for</code> value.
What happens to the request? Why?</p>
<div class="openblock solution" id="solution129"><input id="question129" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer129" style="display: none;">
<div class="content">
<div class="paragraph">
<p>The request hangs for a few seconds before returning the response.
This happens because the <code>wait_for</code> option only returns the request response
after the operation is visible.</p>
</div>
</div>
</div></div>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT my_refresh_test/_doc/5?refresh=wait_for
{
  "level" : "test"
}</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>It is a good practice to run tests on a new index and, then, cleanup
the cluster as you finish the test. Therefore, delete the
<code>my_refresh_test</code> index, which was created in this lab.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>DELETE my_refresh_test</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary:</strong> In this lab, you have used the <code>refresh_interval</code> setting and the
<code>refresh</code> parameter to better understand how Elasticsearch refreshes.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_5_4">End of Lab 5.4</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_6_1_http_response_and_shard_allocation_issues">Lab 6.1: HTTP Response and Shard Allocation Issues</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective</strong>: In this lab you will become familiar with some of the
errors that Elasticsearch returns, and how to understand and fix some of
them. Then, you will execute search requests that return partial results
and hunt down the cause.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Let’s start with a very common error. Run the following command in
Console. What is the error returned? And how can you fix it?</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT test1/_doc/
{
  "test": "test"
}</code></pre>
</div>
</div>
<div class="openblock solution" id="solution130"><input id="question130" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer130" style="display: none;">
<div class="content">
<div class="paragraph">
<p>The error returned is <strong>405</strong> ("Method not allowed"). The error message from
Elasticsearch is saying that POST is allowed, but not PUT, which is
correct as our document does not have an id. To fix this problem you can
either give an id to the document or use a POST instead of a PUT.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>Run the following command. What is the error returned? And how can you
fix it?</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET test2/_doc/1</code></pre>
</div>
</div>
<div class="openblock solution" id="solution131"><input id="question131" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer131" style="display: none;">
<div class="content">
<div class="paragraph">
<p>The error returned is <strong>404</strong> ("Not found"). The error message from
Elasticsearch is clear and states that the index does not exist. You
probably want to make sure you have the correct index name. If you do,
you want to investigate why the index does not exist or was deleted.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>Run the following command. What is the error returned? And how can you
fix it?</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "query": {
    "match": {
      "title": "open source software",
      "minimum_should_match": 2
    }
  }
}</code></pre>
</div>
</div>
<div class="openblock solution" id="solution132"><input id="question132" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer132" style="display: none;">
<div class="content">
<div class="paragraph">
<p>The error returned is a <strong>400</strong> ("Bad Request"). There was a parsing
exception as the <code>match</code> query does not support multiple fields. In order
to use the <code>minimum_should_match</code> parameter you need to use the extended
form of the <code>match</code> query, like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{
  "query": {
    "match": {
      "title": {
        "query": "open source software",
        "minimum_should_match": 2
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Run the following command. What is the error returned? And how can you
fix it?</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET blogs/_search
{"query":{"match":{"title":{"query":"open source software,"minimum_should_match":2}}}}</code></pre>
</div>
</div>
<div class="openblock solution" id="solution133"><input id="question133" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer133" style="display: none;">
<div class="content">
<div class="paragraph">
<p>The error returned is <strong>500</strong> ("Internal Server Error"). The error message
from Elasticsearch is clear and states that there was a JSON parse
exception. The JSON is indeed not valid, which happens often when you
have it in a single line, or you have a string in your application with
the JSON that should be executed. To fix the above query, add a double
quote after <strong>software</strong>.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>Run the following commands that index two documents and run a query. What is the error
returned from the query? And how can you fix it?
<strong><em>NOTE: This step and some of the following steps might have slightly different results when you execute them, because Elasticsearch does not always allocate the same shards to the same nodes.</em></strong></p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT test2/_doc/1
{
  "date": "2017-09-10"
}

PUT test3/_doc/1
{
  "date": "September 10, 2017"
}

GET test*/_search
{
  "query": {
    "match": {
      "date": "September"
    }
  }
}</code></pre>
</div>
</div>
<div class="openblock solution" id="solution134"><input id="question134" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer134" style="display: none;">
<div class="content">
<div class="paragraph">
<p>No error code is returned in this example, the status returned is <strong>200</strong>
("OK"). However, the search results state that out of 2 shards, only 1
was successful and that 1 shard failed. WHAT? One shard is missing?!
We will look into that in a bit. For now, by looking into the failures,
you can see that there was an exception in which <strong>September</strong> could not be
parsed as a date. The example is very simple, but this happens often
when your search request contains a wildcard in the index name and you
have fields with the same name but different types. If the <code>date</code> field in
the <code>test2</code> index should be a "<strong>string</strong>", make sure to define the mapping
before indexing the first document (or correct the mapping and reindex
the data). If mappings are correct, feel free to ignore the failures and
work with the partial results.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>Now, you are going to simulate the failure of primary shards to see how it
looks like. So, first create an index named <code>test4</code> with 4 primaries and
0 replicas.</p>
<div class="openblock solution" id="solution135"><input id="question135" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer135" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT test4
{
  "settings": {
    "number_of_shards": 4,
    "number_of_replicas": 0
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Index the following documents inside <code>test4</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT test4/_doc/1
{
  "test": "document 1"
}

PUT test4/_doc/2
{
  "test": "document 2"
}

PUT test4/_doc/3
{
  "test": "document 3"
}

PUT test4/_doc/4
{
  "test": "document 4"
}</code></pre>
</div>
</div>
</li>
<li>
<p>Stop <code>node2</code> to simulate a node failure and see what’s going to happen.</p>
</li>
<li>
<p>Run the following query, check the number of hits, and also check the
<code>_shards</code> section.
How many hits did you get?
How many shards successfully executed your query?</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET test4/_search
{
  "query": {
    "match": {
      "test": "document"
    }
  }
}</code></pre>
</div>
</div>
<div class="openblock solution" id="solution136"><input id="question136" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer136" style="display: none;">
<div class="content">
<div class="paragraph">
<p>You probably got less than 4 hits.
If you check the <code>_shards</code> section you will note that despite the fact you
have 4 primary shards for <code>test4</code> your query didn’t reach all of them,
that is, the number of <code>successful</code> shards is probably lower than 4,
which is the <code>total</code> number of shards.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>Investigate what is wrong.
First, check how the cluster is doing by viewing the cluster health.
Is everything ok? What is the problem?</p>
<div class="openblock solution" id="solution137"><input id="question137" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer137" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cluster/health</code></pre>
</div>
</div>
<div class="paragraph">
<p>The cluster has red status, which means that at least one primary shard
is not available. Looking at the Cluster Health API response we can see
that there are unassigned shards.</p>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>EXAM PREP</strong>: Keep digging it. Figure out which index is red and which shard is
unassigned. Feel free to use the <code>_cluster</code> or <code>_cat</code> APIs.</p>
<div class="openblock solution" id="solution138"><input id="question138" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer138" style="display: none;">
<div class="content">
<div class="paragraph">
<p>Let’s figure out which index has the problem. Using the Cluster API, the
command would be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cluster/health?level=indices</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using the <code>_cat</code> API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cat/indices?v</code></pre>
</div>
</div>
<div class="paragraph">
<p>As expected, the <code>test4</code> index is red. Run the following to check which shard
has the issue:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cluster/health/test4?level=shards</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using the <code>_cat</code> API, the similar command would be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cat/shards/test4?v</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p><strong>EXAM PREP</strong>: Now that we know which shard has the issue, use the Cluster Allocation
Explain API to understand it. Can you discover what the problem is?</p>
<div class="openblock solution" id="solution139"><input id="question139" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer139" style="display: none;">
<div class="content">
<div class="paragraph">
<p>You can run the short form of the allocation API because there is only
one unassigned shard in the cluster. If you have more unassigned shards
in the cluster, you would need to run the long form.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cluster/allocation/explain</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cluster/allocation/explain
{
  "index": "test4",
  "shard": 0,
  "primary": true
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Change the value of "<strong>shard</strong>" in the request above into the shard that
you identified earlier as being unassigned.</em></p>
</div>
</div>
</div></div>
</li>
<li>
<p>Analyzing the results, you can see that there are some primary shards
that couldn’t be allocated because the node that used to hold them left
the cluster, which was the expected outcome of our simulation.
Now, assume that you fixed the issue of <code>node2</code> and restart it.</p>
<div class="openblock solution" id="solution140"><input id="question140" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer140" style="display: none;">
<div class="content">
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>./elasticsearch-7.3.1/bin/elasticsearch</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Usually it is a good practice to have at least one replica shards to avoid
your cluster going red when you lose one node that holds primary shards.
Update the settings of <code>test4</code> index so it has 1 replica shards.</p>
<div class="openblock solution" id="solution141"><input id="question141" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer141" style="display: none;">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT test4/_settings
{
  "number_of_replicas": 1
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Simulate a failure on <code>node2</code> again by stopping it and also rerun the
following query, check the number of hits, and check the <code>_shards</code> section.
How many hits did you get?
How many shards successfully executed your query?</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET test4/_search
{
  "query": {
    "match": {
      "test": "document"
    }
  }
}</code></pre>
</div>
</div>
<div class="openblock solution" id="solution142"><input id="question142" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer142" style="display: none;">
<div class="content">
<div class="paragraph">
<p>Now you should have gotten the 4 hits and all shards successfully executed your
query.
Even though you lost <code>node2</code>, <code>node1</code> promoted its replica shards to
primary shards so your cluster can work as usual.
However, note that probably your cluster is yellow due to some missing
replicas.</p>
</div>
</div>
</div></div>
</li>
<li>
<p>Enough of failure simulation on your cluster. Restart <code>node2</code>.</p>
<div class="openblock solution" id="solution143"><input id="question143" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer143" style="display: none;">
<div class="content">
<div class="listingblock bash">
<div class="content">
<pre class="highlight"><code>./elasticsearch-7.3.1/bin/elasticsearch</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>Now that you have finished your tests and you will not use the created
indices anymore, make sure to cleanup your cluster by deleting <code>test*</code> indices.</p>
<div class="openblock solution" id="solution144"><input id="question144" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer144" style="display: none;">
<div class="content">
<div class="paragraph">
<p>You can either delete one index at a time or use the wildcard.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>DELETE test*</code></pre>
</div>
</div>
</div>
</div></div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary</strong>: In this lab you became familiar with some of the errors that
Elasticsearch returns, and how to understand and fix some of them. Then
you executed search requests that returned partial results and hunted
down and fixed the cause.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_6_1">End of Lab 6.1</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_6_2_monitoring">Lab 6.2: Monitoring</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab, you will use the Monitoring UI to monitor the
health of your cluster.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Even though we have monitoring enabled, data collection is disabled by
default.
To enable it, click on the Monitoring icon in the left toolbar.
<span class="image"><img src="./Lab Guide_ Elasticsearch Engineer I_files/monitoring_enable0.png" alt="monitoring enable0"></span></p>
</li>
<li>
<p>Then, click the button <strong>Turn on monitoring</strong> to enable data collection.
<span class="image"><img src="./Lab Guide_ Elasticsearch Engineer I_files/monitoring_enable1.png" alt="monitoring enable1"></span></p>
<div class="paragraph">
<p>Note that we could have also used the <strong>Cluster Update Settings API</strong> to enable
data collection:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT /_cluster/settings
{
  "persistent" : {
    "xpack.monitoring.collection.enabled" : true
  }
}</code></pre>
</div>
</div>
</li>
<li>
<p>After enabling data collection it will take a few seconds to start monitoring and collect some data.
<span class="image"><img src="./Lab Guide_ Elasticsearch Engineer I_files/monitoring_enable2.png" alt="monitoring enable2"></span></p>
</li>
<li>
<p>Finally, you will be able to view your <strong>Clusters</strong> dashboard.
<span class="image"><img src="./Lab Guide_ Elasticsearch Engineer I_files/monitoring_dashboard1.png" alt="monitoring dashboard1"></span></p>
</li>
<li>
<p>Change the time interval from "Last 1 hour" to "Last 15 minutes" to
view only the data from the last 15 minutes. Since your cluster is just
starting to collect metrics, this view will actually provide more
details (until more data is collected over a longer interval).
<span class="image"><img src="./Lab Guide_ Elasticsearch Engineer I_files/monitoring_timepicker1.png" alt="monitoring timepicker1"></span></p>
</li>
<li>
<p>Update the refresh interval to 5 seconds (instead of the current 10
second interval). You should see events come in twice as often now.
<span class="image"><img src="./Lab Guide_ Elasticsearch Engineer I_files/monitoring_timepicker2.png" alt="monitoring timepicker2"></span></p>
</li>
<li>
<p>From the Monitoring home page, click on <strong>Nodes</strong>, then <code>node2</code>. Scroll down
to the bottom of the page and view the <strong>Shard Legend</strong> section. You should
see all of your indices, each with a mix of primary and replica shards,
similar to:
<span class="image"><img src="./Lab Guide_ Elasticsearch Engineer I_files/monitoring_shards1.png" alt="monitoring shards1"></span></p>
</li>
<li>
<p>Next, you will simulate a node failure in the cluster. Stop <code>node3</code>.</p>
</li>
<li>
<p>Go back to the <strong>Nodes</strong> page of Monitoring.
Notice that the <code>node3</code> is now <code>offline</code> and all stats show up as <strong>N/A</strong>.
<span class="image"><img src="./Lab Guide_ Elasticsearch Engineer I_files/monitoring_nodes1.png" alt="monitoring nodes1"></span></p>
</li>
<li>
<p>Startup the unavailable node.</p>
</li>
<li>
<p>Next, you will put some stress on your cluster by reindexing some data.
Open Kibana Dev Tools on a new tab and execute the command below to reindex
all logs data (1.7M documents) into a single index named <code>logs_test2</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST _reindex?wait_for_completion=false
{
  "source": {
    "index": "logs_server*"
  },
  "dest": {
    "index": "logs_test2"
  }
}</code></pre>
</div>
</div>
</li>
<li>
<p>What happened to the cluster overview?</p>
<div class="openblock solution" id="solution145"><input id="question145" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer145" style="display: none;">
<div class="content">
<div class="paragraph">
<p>Both search and indexing rates probably increased during the reindex process.
<span class="image"><img src="./Lab Guide_ Elasticsearch Engineer I_files/monitoring_reindex.png" alt="monitoring reindex"></span></p>
</div>
</div>
</div></div>
</li>
<li>
<p>Feel free to explore the Monitoring UI and try to get a sense of the
information being provided as well as how to navigate the UI.
Before finishing this lab, remember that in production you probably want to
have a dedicated monitoring cluster, though during this lab you enabled
monitoring in the same cluster for simplicity.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary:</strong> In this lab, you enabled data collection to monitor the details
of your cluster using the Monitoring UI.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_6_2">End of Lab 6.2</h3>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_6_3_diagnosing_performance_issues">Lab 6.3: Diagnosing Performance Issues</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Objective:</strong> In this lab, you will explore the cat and task management APIs.
You will also learn how to check for slow operations and profiling queries.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>JSON is great for computers, but it usually is hard for human eyes.
The cat API aims to meet this need, so you can use them to check several
information about your cluster on a more user friendly way.
Use the <code>_cat</code> command alone to list all the available commands:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cat</code></pre>
</div>
</div>
</li>
<li>
<p>The <code>shards</code> command is one of the available commands within the cat APIs and
it gives you a detailed view of each shard in the cluster.
It will tell you whether it is a primary or replica, the number of the docs,
the bytes it takes on disk, and the node where it is located.
Run <code>_cat/shards</code> to check all this shard information about your cluster.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cat/shards</code></pre>
</div>
</div>
</li>
<li>
<p>If you are not familiar with cat APIs it might be difficult to grasp what
kind information is being returned.
To overcome this you can turn on verbose output and it will show you a header
along with the results, which makes it easier to identify what all the
information returned is about.
Run <code>_cat/shards</code> again with the query string parameter <code>v</code> to turn on
verbose output as follows:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cat/shards?v</code></pre>
</div>
</div>
</li>
<li>
<p>The cat APIs also allows you to define what columns you want to see in the
output.
You can use the query string parameter <code>h</code> to do that and if you set it to
<code>*</code> you will see all the available information.
Run <code>_cat/shards</code> again with verbose output on and also set it to show all
available columns as follows:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cat/shards?v&amp;h=*</code></pre>
</div>
</div>
</li>
<li>
<p>You probably noticed in the last exercise that showing all the columns might
be too much information.
If you are not sure what information you want to see, but still don’t want to
see all of them, you can use the <code>help</code> parameter to check what are the
available columns.
Use the <code>help</code> parameter on <code>_cat/shards</code> to see what are all the available
columns.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cat/shards?help</code></pre>
</div>
</div>
</li>
<li>
<p>Suppose you want to see the columns <code>index</code>, <code>shard</code>, <code>prirep</code>, <code>node</code>,
<code>search.query_time</code>, and <code>search.query_total</code>.
You can run <code>_cat/shards</code> again specifying these columns through the <code>h</code>
parameter as follows.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cat/shards?v&amp;h=index,shard,prirep,node,search.query_time,search.query_total</code></pre>
</div>
</div>
</li>
<li>
<p>You might also want to sort the output of the cat APIs to make them even
easier to read.
You can do that through the query string parameter <code>s</code> which sorts the table
by the columns specified as the parameter value.
Run <code>_cat/shards</code> again as follows and you will see the output sorted out by
<code>index</code> and <code>search.query_time</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _cat/shards?v&amp;h=index,shard,prirep,node,search.query_time,search.query_total&amp;s=index,search.query_time</code></pre>
</div>
</div>
</li>
<li>
<p>Now, you are going to reindex some documents to put some stress on your
cluster and use the task management API to check what is going on.
So, start by running the following reindex request.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST _reindex?wait_for_completion=false
{
  "source": {
    "index": "logs_server*"
  },
  "dest": {
    "index": "logs_test4"
  }
}</code></pre>
</div>
</div>
</li>
<li>
<p>Even though you can use <code>_cat/tasks</code> to check the information about the
current tasks in your cluster, it still does not provide all the same tools
that are provided by the task management API itself.
For this reason, you are going to rely on the JSON back again.
Use the <code>_tasks</code> command to retrieve all tasks currently running on all nodes
in your cluster.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _tasks</code></pre>
</div>
</div>
</li>
<li>
<p>You probably noticed that <code>_tasks</code> might return too much information.
Since you know that a <code>reindex</code> is going on in your cluster, you can use
the <code>actions</code> parameter to filter out the results to show only tasks
related to reindex processes.
Run the command below to check your reindex.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _tasks?actions=*reindex</code></pre>
</div>
</div>
</li>
<li>
<p>You can also use the <code>detailed</code> request parameter to get more information
about the running tasks.
This is useful when you need to see what is the difference among the tasks
running in your cluster, though it is more costly to execute.
Run the command below and notice that the <code>detailed</code> parameter will show
you a <code>description</code> about your <code>reindex</code> request, which makes a lot
easier to understand what is going on.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _tasks?actions=*reindex&amp;detailed</code></pre>
</div>
</div>
</li>
<li>
<p>You can also use the task API to check information about a specific task.
Use the output of the previous exercise to see what is the id of your reindex
task and use it in place of <code>&lt;id&gt;</code> in the command below.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET _tasks/&lt;id&gt;</code></pre>
</div>
</div>
<div class="openblock solution" id="solution146"><input id="question146" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer146" style="display: none;">
<div class="content">
<div class="paragraph">
<p>The output of the previous exercise should be similar to the one below.
In this example the id is <code>EA_RwTlZQ-OWjwL8kXc3DQ:916598</code>, which is one
task inside the <code>tasks</code> field.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{
  "nodes" : {
    "EA_RwTlZQ-OWjwL8kXc3DQ" : {
      "name" : "node1",
      "transport_address" : "172.18.0.2:9300",
      "host" : "172.18.0.2",
      "ip" : "172.18.0.2:9300",
      "roles" : [
        "master",
        "data"
      ],
      "attributes" : {
        "xpack.installed" : "true"
      },
      "tasks" : {
        "<strong>EA_RwTlZQ-OWjwL8kXc3DQ:916598</strong>" : {
          "node" : "EA_RwTlZQ-OWjwL8kXc3DQ",
          "id" : 916598,
          "type" : "transport",
          "action" : "indices:data/write/reindex",
          "status" : {
            "total" : 1751476,
            "updated" : 0,
            "created" : 20000,
            "deleted" : 0,
            "batches" : 21,
            "version_conflicts" : 0,
            "noops" : 0,
            "retries" : {
              "bulk" : 0,
              "search" : 0
            },
            "throttled_millis" : 0,
            "requests_per_second" : -1.0,
            "throttled_until_millis" : 0
          },
          "description" : "reindex from [logs_server*] to [logs_test4][_doc]",
          "start_time_in_millis" : 1560261112904,
          "running_time_in_nanos" : 4190151032,
          "cancellable" : true,
          "headers" : { }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div></div>
</li>
<li>
<p>You can use the task management API to cancel long-running tasks.
Run the command below to cancel your <code>reindex</code>.
Remember to change <code>&lt;id&gt;</code> by the task id that you used in the previous exercise.
<em>(This command will fail if the task has finished.)</em></p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST _tasks/&lt;id&gt;/_cancel</code></pre>
</div>
</div>
</li>
<li>
<p>Now, you are going to update the shard level slow search log and run a slow
aggregation query to see how they appear in the logs.
Run the command below to update the slow log level to log any queries
that take more than <code>500ms</code> to run.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PUT logs_server*/_settings
{
  "index.search.slowlog" : {
    "threshold.query" : {
      "warn" : "1s",
      "info" : "500ms",
      "debug" : "0ms"
    },
    "level" : "info"
  }
}</code></pre>
</div>
</div>
</li>
<li>
<p>Run the aggregation below.
After this aggregation finishes running you can check that it was logged in
<code>elasticsearch-7.3.1/logs/my_cluster_index_search_slowlog.log</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>GET logs_server*/_search
{
  "size": 0,
  "aggs": {
    "top_10_countries": {
      "terms": {
        "field": "geoip.country_name.keyword",
        "size": 10
      },
      "aggs": {
        "top_5_blogs": {
          "significant_text": {
            "field": "originalUrl.keyword",
            "size": 5
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</li>
<li>
<p>When you find a query in your slow logs, a good idea is to use the search
profiler in Kibana to check why that query is slow.
Use the search profiler in Kibana to check why the query from the previous
exercise is slow.</p>
<div class="openblock solution" id="solution147"><input id="question147" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer147" style="display: none;">
<div class="content">
<div class="paragraph">
<p><span class="image"><img src="./Lab Guide_ Elasticsearch Engineer I_files/troubleshooting_search_profiler.png" alt="troubleshooting search profiler"></span></p>
</div>
</div>
</div></div>
</li>
<li>
<p>Now that you have finished your tests and you will not use the created
indices anymore, make sure to cleanup your cluster by deleting
<code>log_test*</code> indices.</p>
<div class="openblock solution" id="solution148"><input id="question148" data-value="answer" type="button" value="Show answer" class="answerInput"><div id="answer148" style="display: none;">
<div class="content">
<div class="paragraph">
<p>You can either delete one index at a time or use the wildcard.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>DELETE logs_test*</code></pre>
</div>
</div>
</div>
</div></div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Summary:</strong> In this lab, you explored the cat and task management APIs.
You also learned how to check for slow operations and profiling queries.</p>
</div>
<div class="sect2">
<h3 id="_end_of_lab_6_3">End of Lab 6.3</h3>
<hr>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
</div>
</div>
<script type="text/javascript"> build_solutions()</script>
<p>© Elasticsearch BV 2015-2020. All rights reserved. Decompiling, copying, publishing and/or distribution without written consent of Elasticsearch BV is strictly prohibited.</p>

</body></html>